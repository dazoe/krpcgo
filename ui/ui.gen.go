// Package ui provides methods to invoke procedures in the UI service.
//
// From service docs: provides functionality for drawing and interacting with
// in-game user interface elements.
package ui

import (
	krpcgo "github.com/atburke/krpc-go"
	krpc "github.com/atburke/krpc-go/krpc"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	types "github.com/atburke/krpc-go/types"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// FontStyle - font style.
type FontStyle int32

const (
	// Normal.
	FontStyle_Normal FontStyle = 0
	// Bold.
	FontStyle_Bold FontStyle = 1
	// Italic.
	FontStyle_Italic FontStyle = 2
	// Bold and italic.
	FontStyle_BoldAndItalic FontStyle = 3
)

func (v FontStyle) Value() int32 {
	return int32(v)
}
func (v *FontStyle) SetValue(val int32) {
	*v = FontStyle(val)
}

// MessagePosition - message position.
type MessagePosition int32

const (
	// Bottom center.
	MessagePosition_BottomCenter MessagePosition = 0
	// Top center.
	MessagePosition_TopCenter MessagePosition = 1
	// Top left.
	MessagePosition_TopLeft MessagePosition = 2
	// Top right.
	MessagePosition_TopRight MessagePosition = 3
)

func (v MessagePosition) Value() int32 {
	return int32(v)
}
func (v *MessagePosition) SetValue(val int32) {
	*v = MessagePosition(val)
}

// TextAlignment - text alignment.
type TextAlignment int32

const (
	// Left aligned.
	TextAlignment_Left TextAlignment = 0
	// Right aligned.
	TextAlignment_Right TextAlignment = 1
	// Center aligned.
	TextAlignment_Center TextAlignment = 2
)

func (v TextAlignment) Value() int32 {
	return int32(v)
}
func (v *TextAlignment) SetValue(val int32) {
	*v = TextAlignment(val)
}

// TextAnchor - text alignment.
type TextAnchor int32

const (
	// Lower center.
	TextAnchor_LowerCenter TextAnchor = 0
	// Lower left.
	TextAnchor_LowerLeft TextAnchor = 1
	// Lower right.
	TextAnchor_LowerRight TextAnchor = 2
	// Middle center.
	TextAnchor_MiddleCenter TextAnchor = 3
	// Middle left.
	TextAnchor_MiddleLeft TextAnchor = 4
	// Middle right.
	TextAnchor_MiddleRight TextAnchor = 5
	// Upper center.
	TextAnchor_UpperCenter TextAnchor = 6
	// Upper left.
	TextAnchor_UpperLeft TextAnchor = 7
	// Upper right.
	TextAnchor_UpperRight TextAnchor = 8
)

func (v TextAnchor) Value() int32 {
	return int32(v)
}
func (v *TextAnchor) SetValue(val int32) {
	*v = TextAnchor(val)
}

// Button - a text label. See <see cref="M:UI.Panel.AddButton" />.
type Button struct {
	service.BaseClass
}

// NewButton creates a new Button.
func NewButton(id uint64, client *krpcgo.KRPCClient) *Button {
	c := &Button{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Canvas - a canvas for user interface elements. See <see
// cref="M:UI.StockCanvas" /> and <see cref="M:UI.AddCanvas" />.
type Canvas struct {
	service.BaseClass
}

// NewCanvas creates a new Canvas.
func NewCanvas(id uint64, client *krpcgo.KRPCClient) *Canvas {
	c := &Canvas{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// InputField - an input field. See <see cref="M:UI.Panel.AddInputField" />.
type InputField struct {
	service.BaseClass
}

// NewInputField creates a new InputField.
func NewInputField(id uint64, client *krpcgo.KRPCClient) *InputField {
	c := &InputField{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Panel - a container for user interface elements. See <see
// cref="M:UI.Canvas.AddPanel" />.
type Panel struct {
	service.BaseClass
}

// NewPanel creates a new Panel.
func NewPanel(id uint64, client *krpcgo.KRPCClient) *Panel {
	c := &Panel{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// RectTransform - a Unity engine Rect Transform for a UI object. See the <a
// href="https://docs.unity3d.com/Manual/class-RectTransform.html">Unity
// manual</a> for more details.
type RectTransform struct {
	service.BaseClass
}

// NewRectTransform creates a new RectTransform.
func NewRectTransform(id uint64, client *krpcgo.KRPCClient) *RectTransform {
	c := &RectTransform{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Text - a text label. See <see cref="M:UI.Panel.AddText" />.
type Text struct {
	service.BaseClass
}

// NewText creates a new Text.
func NewText(id uint64, client *krpcgo.KRPCClient) *Text {
	c := &Text{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// UI - provides functionality for drawing and interacting with in-game user
// interface elements.
type UI struct {
	Client *krpcgo.KRPCClient
}

// New creates a new UI.
func New(client *krpcgo.KRPCClient) *UI {
	return &UI{Client: client}
}

// AddCanvas - add a new canvas.
//
// Allowed game scenes: any.
func (s *UI) AddCanvas() (*Canvas, error) {
	var err error
	var vv Canvas
	request := &types.ProcedureCall{
		Procedure: "AddCanvas",
		Service:   "UI",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Message - display a message on the screen.
//
// Allowed game scenes: any.
func (s *UI) Message(content string, duration float32, position MessagePosition, color types.Tuple3[float64, float64, float64], size float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Message",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(content)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(duration)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(color)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(size)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Clear - remove all user interface elements.
//
// Allowed game scenes: any.
func (s *UI) Clear(clientOnly bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Clear",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(clientOnly)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// StockCanvas - the stock UI canvas.
//
// Allowed game scenes: any.
func (s *UI) StockCanvas() (*Canvas, error) {
	var err error
	var vv Canvas
	request := &types.ProcedureCall{
		Procedure: "get_StockCanvas",
		Service:   "UI",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Remove - remove the UI object.
//
// Allowed game scenes: any.
func (s *Button) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Button_Remove",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RectTransform - the rect transform for the text.
//
// Allowed game scenes: any.
func (s *Button) RectTransform() (*RectTransform, error) {
	var err error
	var argBytes []byte
	var vv RectTransform
	request := &types.ProcedureCall{
		Procedure: "Button_get_RectTransform",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Text - the text for the button.
//
// Allowed game scenes: any.
func (s *Button) Text() (*Text, error) {
	var err error
	var argBytes []byte
	var vv Text
	request := &types.ProcedureCall{
		Procedure: "Button_get_Text",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Clicked - whether the button has been clicked.
//
// Allowed game scenes: any.
func (s *Button) Clicked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Button_get_Clicked",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ClickedStream - whether the button has been clicked.
//
// Allowed game scenes: any.
func (s *Button) ClickedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Button_get_Clicked",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetClicked - whether the button has been clicked.
//
// Allowed game scenes: any.
func (s *Button) SetClicked(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Button_set_Clicked",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Visible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Button) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Button_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VisibleStream - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Button) VisibleStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Button_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVisible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Button) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Button_set_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AddPanel - create a new container for user interface elements.
//
// Allowed game scenes: any.
func (s *Canvas) AddPanel(visible bool) (*Panel, error) {
	var err error
	var argBytes []byte
	var vv Panel
	request := &types.ProcedureCall{
		Procedure: "Canvas_AddPanel",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddText - add text to the canvas.
//
// Allowed game scenes: any.
func (s *Canvas) AddText(content string, visible bool) (*Text, error) {
	var err error
	var argBytes []byte
	var vv Text
	request := &types.ProcedureCall{
		Procedure: "Canvas_AddText",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(content)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddInputField - add an input field to the canvas.
//
// Allowed game scenes: any.
func (s *Canvas) AddInputField(visible bool) (*InputField, error) {
	var err error
	var argBytes []byte
	var vv InputField
	request := &types.ProcedureCall{
		Procedure: "Canvas_AddInputField",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddButton - add a button to the canvas.
//
// Allowed game scenes: any.
func (s *Canvas) AddButton(content string, visible bool) (*Button, error) {
	var err error
	var argBytes []byte
	var vv Button
	request := &types.ProcedureCall{
		Procedure: "Canvas_AddButton",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(content)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Remove - remove the UI object.
//
// Allowed game scenes: any.
func (s *Canvas) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Canvas_Remove",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RectTransform - the rect transform for the canvas.
//
// Allowed game scenes: any.
func (s *Canvas) RectTransform() (*RectTransform, error) {
	var err error
	var argBytes []byte
	var vv RectTransform
	request := &types.ProcedureCall{
		Procedure: "Canvas_get_RectTransform",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Visible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Canvas) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Canvas_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VisibleStream - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Canvas) VisibleStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Canvas_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVisible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Canvas) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Canvas_set_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Remove - remove the UI object.
//
// Allowed game scenes: any.
func (s *InputField) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "InputField_Remove",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RectTransform - the rect transform for the input field.
//
// Allowed game scenes: any.
func (s *InputField) RectTransform() (*RectTransform, error) {
	var err error
	var argBytes []byte
	var vv RectTransform
	request := &types.ProcedureCall{
		Procedure: "InputField_get_RectTransform",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Value - the value of the input field.
//
// Allowed game scenes: any.
func (s *InputField) Value() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "InputField_get_Value",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ValueStream - the value of the input field.
//
// Allowed game scenes: any.
func (s *InputField) ValueStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "InputField_get_Value",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetValue - the value of the input field.
//
// Allowed game scenes: any.
func (s *InputField) SetValue(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "InputField_set_Value",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Text - the text component of the input field.
//
// Allowed game scenes: any.
func (s *InputField) Text() (*Text, error) {
	var err error
	var argBytes []byte
	var vv Text
	request := &types.ProcedureCall{
		Procedure: "InputField_get_Text",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Changed - whether the input field has been changed.
//
// Allowed game scenes: any.
func (s *InputField) Changed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "InputField_get_Changed",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ChangedStream - whether the input field has been changed.
//
// Allowed game scenes: any.
func (s *InputField) ChangedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "InputField_get_Changed",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetChanged - whether the input field has been changed.
//
// Allowed game scenes: any.
func (s *InputField) SetChanged(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "InputField_set_Changed",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Visible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *InputField) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "InputField_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VisibleStream - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *InputField) VisibleStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "InputField_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVisible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *InputField) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "InputField_set_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AddPanel - create a panel within this panel.
//
// Allowed game scenes: any.
func (s *Panel) AddPanel(visible bool) (*Panel, error) {
	var err error
	var argBytes []byte
	var vv Panel
	request := &types.ProcedureCall{
		Procedure: "Panel_AddPanel",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddText - add text to the panel.
//
// Allowed game scenes: any.
func (s *Panel) AddText(content string, visible bool) (*Text, error) {
	var err error
	var argBytes []byte
	var vv Text
	request := &types.ProcedureCall{
		Procedure: "Panel_AddText",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(content)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddInputField - add an input field to the panel.
//
// Allowed game scenes: any.
func (s *Panel) AddInputField(visible bool) (*InputField, error) {
	var err error
	var argBytes []byte
	var vv InputField
	request := &types.ProcedureCall{
		Procedure: "Panel_AddInputField",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddButton - add a button to the panel.
//
// Allowed game scenes: any.
func (s *Panel) AddButton(content string, visible bool) (*Button, error) {
	var err error
	var argBytes []byte
	var vv Button
	request := &types.ProcedureCall{
		Procedure: "Panel_AddButton",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(content)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Remove - remove the UI object.
//
// Allowed game scenes: any.
func (s *Panel) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Panel_Remove",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RectTransform - the rect transform for the panel.
//
// Allowed game scenes: any.
func (s *Panel) RectTransform() (*RectTransform, error) {
	var err error
	var argBytes []byte
	var vv RectTransform
	request := &types.ProcedureCall{
		Procedure: "Panel_get_RectTransform",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Visible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Panel) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Panel_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VisibleStream - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Panel) VisibleStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Panel_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVisible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Panel) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Panel_set_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position - position of the rectangles pivot point relative to the anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) Position() (types.Tuple2[float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Position",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionStream - position of the rectangles pivot point relative to the
// anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) PositionStream() (*krpcgo.Stream[types.Tuple2[float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Position",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[float64, float64] {
		var value types.Tuple2[float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPosition - position of the rectangles pivot point relative to the anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) SetPosition(value types.Tuple2[float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_Position",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LocalPosition - position of the rectangles pivot point relative to the
// anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) LocalPosition() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_LocalPosition",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LocalPositionStream - position of the rectangles pivot point relative to the
// anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) LocalPositionStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_LocalPosition",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLocalPosition - position of the rectangles pivot point relative to the
// anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) SetLocalPosition(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_LocalPosition",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Size - width and height of the rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) Size() (types.Tuple2[float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Size",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SizeStream - width and height of the rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) SizeStream() (*krpcgo.Stream[types.Tuple2[float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Size",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[float64, float64] {
		var value types.Tuple2[float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSize - width and height of the rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) SetSize(value types.Tuple2[float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_Size",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// UpperRight - position of the rectangles upper right corner relative to the
// anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) UpperRight() (types.Tuple2[float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_UpperRight",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// UpperRightStream - position of the rectangles upper right corner relative to
// the anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) UpperRightStream() (*krpcgo.Stream[types.Tuple2[float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_UpperRight",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[float64, float64] {
		var value types.Tuple2[float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetUpperRight - position of the rectangles upper right corner relative to the
// anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) SetUpperRight(value types.Tuple2[float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_UpperRight",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LowerLeft - position of the rectangles lower left corner relative to the
// anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) LowerLeft() (types.Tuple2[float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_LowerLeft",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LowerLeftStream - position of the rectangles lower left corner relative to
// the anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) LowerLeftStream() (*krpcgo.Stream[types.Tuple2[float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_LowerLeft",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[float64, float64] {
		var value types.Tuple2[float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLowerLeft - position of the rectangles lower left corner relative to the
// anchors.
//
// Allowed game scenes: any.
func (s *RectTransform) SetLowerLeft(value types.Tuple2[float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_LowerLeft",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetAnchor - set the minimum and maximum anchor points as a fraction of the
// size of the parent rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) SetAnchor(value types.Tuple2[float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_Anchor",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AnchorMax - the anchor point for the lower left corner of the rectangle
// defined as a fraction of the size of the parent rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) AnchorMax() (types.Tuple2[float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_AnchorMax",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AnchorMaxStream - the anchor point for the lower left corner of the rectangle
// defined as a fraction of the size of the parent rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) AnchorMaxStream() (*krpcgo.Stream[types.Tuple2[float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_AnchorMax",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[float64, float64] {
		var value types.Tuple2[float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAnchorMax - the anchor point for the lower left corner of the rectangle
// defined as a fraction of the size of the parent rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) SetAnchorMax(value types.Tuple2[float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_AnchorMax",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AnchorMin - the anchor point for the upper right corner of the rectangle
// defined as a fraction of the size of the parent rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) AnchorMin() (types.Tuple2[float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_AnchorMin",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AnchorMinStream - the anchor point for the upper right corner of the
// rectangle defined as a fraction of the size of the parent rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) AnchorMinStream() (*krpcgo.Stream[types.Tuple2[float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_AnchorMin",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[float64, float64] {
		var value types.Tuple2[float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAnchorMin - the anchor point for the upper right corner of the rectangle
// defined as a fraction of the size of the parent rectangle.
//
// Allowed game scenes: any.
func (s *RectTransform) SetAnchorMin(value types.Tuple2[float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_AnchorMin",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Pivot - location of the pivot point around which the rectangle rotates,
// defined as a fraction of the size of the rectangle itself.
//
// Allowed game scenes: any.
func (s *RectTransform) Pivot() (types.Tuple2[float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Pivot",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PivotStream - location of the pivot point around which the rectangle rotates,
// defined as a fraction of the size of the rectangle itself.
//
// Allowed game scenes: any.
func (s *RectTransform) PivotStream() (*krpcgo.Stream[types.Tuple2[float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Pivot",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[float64, float64] {
		var value types.Tuple2[float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPivot - location of the pivot point around which the rectangle rotates,
// defined as a fraction of the size of the rectangle itself.
//
// Allowed game scenes: any.
func (s *RectTransform) SetPivot(value types.Tuple2[float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_Pivot",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Rotation - rotation, as a quaternion, of the object around its pivot point.
//
// Allowed game scenes: any.
func (s *RectTransform) Rotation() (types.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple4[float64, float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Rotation",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationStream - rotation, as a quaternion, of the object around its pivot
// point.
//
// Allowed game scenes: any.
func (s *RectTransform) RotationStream() (*krpcgo.Stream[types.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Rotation",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple4[float64, float64, float64, float64] {
		var value types.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRotation - rotation, as a quaternion, of the object around its pivot
// point.
//
// Allowed game scenes: any.
func (s *RectTransform) SetRotation(value types.Tuple4[float64, float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_Rotation",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Scale - scale factor applied to the object in the x, y and z dimensions.
//
// Allowed game scenes: any.
func (s *RectTransform) Scale() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Scale",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ScaleStream - scale factor applied to the object in the x, y and z
// dimensions.
//
// Allowed game scenes: any.
func (s *RectTransform) ScaleStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_get_Scale",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetScale - scale factor applied to the object in the x, y and z dimensions.
//
// Allowed game scenes: any.
func (s *RectTransform) SetScale(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RectTransform_set_Scale",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Remove - remove the UI object.
//
// Allowed game scenes: any.
func (s *Text) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_Remove",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RectTransform - the rect transform for the text.
//
// Allowed game scenes: any.
func (s *Text) RectTransform() (*RectTransform, error) {
	var err error
	var argBytes []byte
	var vv RectTransform
	request := &types.ProcedureCall{
		Procedure: "Text_get_RectTransform",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AvailableFonts - a list of all available fonts.
//
// Allowed game scenes: any.
func (s *Text) AvailableFonts() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "Text_get_AvailableFonts",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableFontsStream - a list of all available fonts.
//
// Allowed game scenes: any.
func (s *Text) AvailableFontsStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_AvailableFonts",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Content - the text string
//
// Allowed game scenes: any.
func (s *Text) Content() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Text_get_Content",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ContentStream - the text string
//
// Allowed game scenes: any.
func (s *Text) ContentStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Content",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetContent - the text string
//
// Allowed game scenes: any.
func (s *Text) SetContent(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Content",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Font - name of the font
//
// Allowed game scenes: any.
func (s *Text) Font() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Text_get_Font",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FontStream - name of the font
//
// Allowed game scenes: any.
func (s *Text) FontStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Font",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetFont - name of the font
//
// Allowed game scenes: any.
func (s *Text) SetFont(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Font",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Size - font size.
//
// Allowed game scenes: any.
func (s *Text) Size() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "Text_get_Size",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SizeStream - font size.
//
// Allowed game scenes: any.
func (s *Text) SizeStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Size",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSize - font size.
//
// Allowed game scenes: any.
func (s *Text) SetSize(value int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Size",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Style - font style.
//
// Allowed game scenes: any.
func (s *Text) Style() (FontStyle, error) {
	var err error
	var argBytes []byte
	var vv FontStyle
	request := &types.ProcedureCall{
		Procedure: "Text_get_Style",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StyleStream - font style.
//
// Allowed game scenes: any.
func (s *Text) StyleStream() (*krpcgo.Stream[FontStyle], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Style",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) FontStyle {
		var value FontStyle
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetStyle - font style.
//
// Allowed game scenes: any.
func (s *Text) SetStyle(value FontStyle) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Style",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Alignment - alignment.
//
// Allowed game scenes: any.
func (s *Text) Alignment() (TextAnchor, error) {
	var err error
	var argBytes []byte
	var vv TextAnchor
	request := &types.ProcedureCall{
		Procedure: "Text_get_Alignment",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AlignmentStream - alignment.
//
// Allowed game scenes: any.
func (s *Text) AlignmentStream() (*krpcgo.Stream[TextAnchor], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Alignment",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) TextAnchor {
		var value TextAnchor
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAlignment - alignment.
//
// Allowed game scenes: any.
func (s *Text) SetAlignment(value TextAnchor) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Alignment",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LineSpacing - line spacing.
//
// Allowed game scenes: any.
func (s *Text) LineSpacing() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Text_get_LineSpacing",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LineSpacingStream - line spacing.
//
// Allowed game scenes: any.
func (s *Text) LineSpacingStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_LineSpacing",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLineSpacing - line spacing.
//
// Allowed game scenes: any.
func (s *Text) SetLineSpacing(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_LineSpacing",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color - set the color
//
// Allowed game scenes: any.
func (s *Text) Color() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Text_get_Color",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ColorStream - set the color
//
// Allowed game scenes: any.
func (s *Text) ColorStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Color",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetColor - set the color
//
// Allowed game scenes: any.
func (s *Text) SetColor(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Color",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Visible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Text) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Text_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VisibleStream - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Text) VisibleStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVisible - whether the UI object is visible.
//
// Allowed game scenes: any.
func (s *Text) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Visible",
		Service:   "UI",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}
