// Package infernalrobotics provides methods to invoke procedures in the
// InfernalRobotics service.
//
// From service docs: this service provides functionality to interact with <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/184787-infernal-robotics-next/">Infernal
// Robotics</a>.
package infernalrobotics

import (
	krpcgo "github.com/atburke/krpc-go"
	krpc "github.com/atburke/krpc-go/krpc"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	spacecenter "github.com/atburke/krpc-go/spacecenter"
	types "github.com/atburke/krpc-go/types"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// Servo - represents a servo. Obtained using <see
// cref="M:InfernalRobotics.ServoGroup.Servos" />, <see
// cref="M:InfernalRobotics.ServoGroup.ServoWithName" /> or <see
// cref="M:InfernalRobotics.ServoWithName" />.
type Servo struct {
	service.BaseClass
}

// NewServo creates a new Servo.
func NewServo(id uint64, client *krpcgo.KRPCClient) *Servo {
	c := &Servo{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// ServoGroup - a group of servos, obtained by calling <see
// cref="M:InfernalRobotics.ServoGroups" /> or <see
// cref="M:InfernalRobotics.ServoGroupWithName" />. Represents the "Servo
// Groups" in the InfernalRobotics UI.
type ServoGroup struct {
	service.BaseClass
}

// NewServoGroup creates a new ServoGroup.
func NewServoGroup(id uint64, client *krpcgo.KRPCClient) *ServoGroup {
	c := &ServoGroup{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// InfernalRobotics - this service provides functionality to interact with <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/184787-infernal-robotics-next/">Infernal
// Robotics</a>.
type InfernalRobotics struct {
	Client *krpcgo.KRPCClient
}

// New creates a new InfernalRobotics.
func New(client *krpcgo.KRPCClient) *InfernalRobotics {
	return &InfernalRobotics{Client: client}
}

// ServoGroups - a list of all the servo groups in the given <paramref
// name="vessel" />.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) ServoGroups(vessel *spacecenter.Vessel) ([]*ServoGroup, error) {
	var err error
	var argBytes []byte
	var vv []*ServoGroup
	request := &types.ProcedureCall{
		Procedure: "ServoGroups",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ServoGroupsStream - a list of all the servo groups in the given <paramref
// name="vessel" />.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) ServoGroupsStream(vessel *spacecenter.Vessel) (*krpcgo.Stream[[]*ServoGroup], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroups",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*ServoGroup {
		var value []*ServoGroup
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ServoGroupWithName - returns the servo group in the given <paramref
// name="vessel" /> with the given <paramref name="name" />, or nil if none
// exists. If multiple servo groups have the same name, only one of them is
// returned.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) ServoGroupWithName(vessel *spacecenter.Vessel, name string) (*ServoGroup, error) {
	var err error
	var argBytes []byte
	var vv ServoGroup
	request := &types.ProcedureCall{
		Procedure: "ServoGroupWithName",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// ServoWithName - returns the servo in the given <paramref name="vessel" />
// with the given <paramref name="name" /> or nil if none exists. If multiple
// servos have the same name, only one of them is returned.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) ServoWithName(vessel *spacecenter.Vessel, name string) (*Servo, error) {
	var err error
	var argBytes []byte
	var vv Servo
	request := &types.ProcedureCall{
		Procedure: "ServoWithName",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// Available - whether Infernal Robotics is installed.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) Available() (bool, error) {
	var err error
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "get_Available",
		Service:   "InfernalRobotics",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableStream - whether Infernal Robotics is installed.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) AvailableStream() (*krpcgo.Stream[bool], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Available",
		Service:   "InfernalRobotics",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Ready - whether Infernal Robotics API is ready.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) Ready() (bool, error) {
	var err error
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "get_Ready",
		Service:   "InfernalRobotics",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReadyStream - whether Infernal Robotics API is ready.
//
// Allowed game scenes: any.
func (s *InfernalRobotics) ReadyStream() (*krpcgo.Stream[bool], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Ready",
		Service:   "InfernalRobotics",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MoveRight - moves the servo to the right.
//
// Allowed game scenes: any.
func (s *Servo) MoveRight() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_MoveRight",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveLeft - moves the servo to the left.
//
// Allowed game scenes: any.
func (s *Servo) MoveLeft() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_MoveLeft",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveCenter - moves the servo to the center.
//
// Allowed game scenes: any.
func (s *Servo) MoveCenter() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_MoveCenter",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveTo - moves the servo to <paramref name="position" /> and sets the speed
// multiplier to <paramref name="speed" />.
//
// Allowed game scenes: any.
func (s *Servo) MoveTo(position float32, speed float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_MoveTo",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(speed)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Stop - stops the servo.
//
// Allowed game scenes: any.
func (s *Servo) Stop() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_Stop",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name - the name of the servo.
//
// Allowed game scenes: any.
func (s *Servo) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Servo_get_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the name of the servo.
//
// Allowed game scenes: any.
func (s *Servo) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetName - the name of the servo.
//
// Allowed game scenes: any.
func (s *Servo) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_set_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part containing the servo.
//
// Allowed game scenes: any.
func (s *Servo) Part() (*spacecenter.Part, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.Part
	request := &types.ProcedureCall{
		Procedure: "Servo_get_Part",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetHighlight - whether the servo should be highlighted in-game.
//
// Allowed game scenes: any.
func (s *Servo) SetHighlight(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_set_Highlight",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position - the position of the servo.
//
// Allowed game scenes: any.
func (s *Servo) Position() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Servo_get_Position",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionStream - the position of the servo.
//
// Allowed game scenes: any.
func (s *Servo) PositionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_Position",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MinConfigPosition - the minimum position of the servo, specified by the part
// configuration.
//
// Allowed game scenes: any.
func (s *Servo) MinConfigPosition() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Servo_get_MinConfigPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MinConfigPositionStream - the minimum position of the servo, specified by the
// part configuration.
//
// Allowed game scenes: any.
func (s *Servo) MinConfigPositionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_MinConfigPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxConfigPosition - the maximum position of the servo, specified by the part
// configuration.
//
// Allowed game scenes: any.
func (s *Servo) MaxConfigPosition() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Servo_get_MaxConfigPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxConfigPositionStream - the maximum position of the servo, specified by the
// part configuration.
//
// Allowed game scenes: any.
func (s *Servo) MaxConfigPositionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_MaxConfigPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MinPosition - the minimum position of the servo, specified by the in-game
// tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) MinPosition() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Servo_get_MinPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MinPositionStream - the minimum position of the servo, specified by the
// in-game tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) MinPositionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_MinPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMinPosition - the minimum position of the servo, specified by the in-game
// tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) SetMinPosition(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_set_MinPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MaxPosition - the maximum position of the servo, specified by the in-game
// tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) MaxPosition() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Servo_get_MaxPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxPositionStream - the maximum position of the servo, specified by the
// in-game tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) MaxPositionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_MaxPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMaxPosition - the maximum position of the servo, specified by the in-game
// tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) SetMaxPosition(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_set_MaxPosition",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ConfigSpeed - the speed multiplier of the servo, specified by the part
// configuration.
//
// Allowed game scenes: any.
func (s *Servo) ConfigSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Servo_get_ConfigSpeed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ConfigSpeedStream - the speed multiplier of the servo, specified by the part
// configuration.
//
// Allowed game scenes: any.
func (s *Servo) ConfigSpeedStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_ConfigSpeed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Speed - the speed multiplier of the servo, specified by the in-game tweak
// menu.
//
// Allowed game scenes: any.
func (s *Servo) Speed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Servo_get_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpeedStream - the speed multiplier of the servo, specified by the in-game
// tweak menu.
//
// Allowed game scenes: any.
func (s *Servo) SpeedStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSpeed - the speed multiplier of the servo, specified by the in-game tweak
// menu.
//
// Allowed game scenes: any.
func (s *Servo) SetSpeed(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_set_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CurrentSpeed - the current speed at which the servo is moving.
//
// Allowed game scenes: any.
func (s *Servo) CurrentSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Servo_get_CurrentSpeed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CurrentSpeedStream - the current speed at which the servo is moving.
//
// Allowed game scenes: any.
func (s *Servo) CurrentSpeedStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_CurrentSpeed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Acceleration - the current speed multiplier set in the UI.
//
// Allowed game scenes: any.
func (s *Servo) Acceleration() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Servo_get_Acceleration",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AccelerationStream - the current speed multiplier set in the UI.
//
// Allowed game scenes: any.
func (s *Servo) AccelerationStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_Acceleration",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAcceleration - the current speed multiplier set in the UI.
//
// Allowed game scenes: any.
func (s *Servo) SetAcceleration(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_set_Acceleration",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// IsMoving - whether the servo is moving.
//
// Allowed game scenes: any.
func (s *Servo) IsMoving() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Servo_get_IsMoving",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsMovingStream - whether the servo is moving.
//
// Allowed game scenes: any.
func (s *Servo) IsMovingStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_IsMoving",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IsFreeMoving - whether the servo is freely moving.
//
// Allowed game scenes: any.
func (s *Servo) IsFreeMoving() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Servo_get_IsFreeMoving",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsFreeMovingStream - whether the servo is freely moving.
//
// Allowed game scenes: any.
func (s *Servo) IsFreeMovingStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_IsFreeMoving",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IsLocked - whether the servo is locked.
//
// Allowed game scenes: any.
func (s *Servo) IsLocked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Servo_get_IsLocked",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsLockedStream - whether the servo is locked.
//
// Allowed game scenes: any.
func (s *Servo) IsLockedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_IsLocked",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetIsLocked - whether the servo is locked.
//
// Allowed game scenes: any.
func (s *Servo) SetIsLocked(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_set_IsLocked",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// IsAxisInverted - whether the servos axis is inverted.
//
// Allowed game scenes: any.
func (s *Servo) IsAxisInverted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Servo_get_IsAxisInverted",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsAxisInvertedStream - whether the servos axis is inverted.
//
// Allowed game scenes: any.
func (s *Servo) IsAxisInvertedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_get_IsAxisInverted",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetIsAxisInverted - whether the servos axis is inverted.
//
// Allowed game scenes: any.
func (s *Servo) SetIsAxisInverted(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Servo_set_IsAxisInverted",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ServoWithName - returns the servo with the given <paramref name="name" />
// from this group, or nil if none exists.
//
// Allowed game scenes: any.
func (s *ServoGroup) ServoWithName(name string) (*Servo, error) {
	var err error
	var argBytes []byte
	var vv Servo
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_ServoWithName",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// MoveRight - moves all of the servos in the group to the right.
//
// Allowed game scenes: any.
func (s *ServoGroup) MoveRight() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_MoveRight",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveLeft - moves all of the servos in the group to the left.
//
// Allowed game scenes: any.
func (s *ServoGroup) MoveLeft() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_MoveLeft",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveCenter - moves all of the servos in the group to the center.
//
// Allowed game scenes: any.
func (s *ServoGroup) MoveCenter() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_MoveCenter",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveNextPreset - moves all of the servos in the group to the next preset.
//
// Allowed game scenes: any.
func (s *ServoGroup) MoveNextPreset() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_MoveNextPreset",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MovePrevPreset - moves all of the servos in the group to the previous preset.
//
// Allowed game scenes: any.
func (s *ServoGroup) MovePrevPreset() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_MovePrevPreset",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Stop - stops the servos in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Stop() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_Stop",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name - the name of the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the name of the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetName - the name of the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_set_Name",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ForwardKey - the key assigned to be the "forward" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) ForwardKey() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_ForwardKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ForwardKeyStream - the key assigned to be the "forward" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) ForwardKeyStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_ForwardKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetForwardKey - the key assigned to be the "forward" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetForwardKey(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_set_ForwardKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReverseKey - the key assigned to be the "reverse" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) ReverseKey() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_ReverseKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReverseKeyStream - the key assigned to be the "reverse" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) ReverseKeyStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_ReverseKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetReverseKey - the key assigned to be the "reverse" key for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetReverseKey(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_set_ReverseKey",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Speed - the speed multiplier for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Speed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpeedStream - the speed multiplier for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) SpeedStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSpeed - the speed multiplier for the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetSpeed(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_set_Speed",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Expanded - whether the group is expanded in the InfernalRobotics UI.
//
// Allowed game scenes: any.
func (s *ServoGroup) Expanded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Expanded",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ExpandedStream - whether the group is expanded in the InfernalRobotics UI.
//
// Allowed game scenes: any.
func (s *ServoGroup) ExpandedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Expanded",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetExpanded - whether the group is expanded in the InfernalRobotics UI.
//
// Allowed game scenes: any.
func (s *ServoGroup) SetExpanded(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_set_Expanded",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Servos - the servos that are in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Servos() ([]*Servo, error) {
	var err error
	var argBytes []byte
	var vv []*Servo
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Servos",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ServosStream - the servos that are in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) ServosStream() (*krpcgo.Stream[[]*Servo], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Servos",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Servo {
		var value []*Servo
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Parts - the parts containing the servos in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) Parts() ([]*spacecenter.Part, error) {
	var err error
	var argBytes []byte
	var vv []*spacecenter.Part
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Parts",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// PartsStream - the parts containing the servos in the group.
//
// Allowed game scenes: any.
func (s *ServoGroup) PartsStream() (*krpcgo.Stream[[]*spacecenter.Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ServoGroup_get_Parts",
		Service:   "InfernalRobotics",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*spacecenter.Part {
		var value []*spacecenter.Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}
