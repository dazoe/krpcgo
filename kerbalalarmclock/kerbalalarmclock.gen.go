// Package kerbalalarmclock provides methods to invoke procedures in the
// KerbalAlarmClock service.
//
// From service docs: this service provides functionality to interact with <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/22809-13x-kerbal-alarm-clock-v3850-may-30/">Kerbal
// Alarm Clock</a>.
package kerbalalarmclock

import (
	krpcgo "github.com/atburke/krpc-go"
	krpc "github.com/atburke/krpc-go/krpc"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	spacecenter "github.com/atburke/krpc-go/spacecenter"
	types "github.com/atburke/krpc-go/types"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// AlarmAction - the action performed by an alarm when it fires.
type AlarmAction int32

const (
	// Don't do anything at all...
	AlarmAction_DoNothing AlarmAction = 0
	// Don't do anything, and delete the alarm.
	AlarmAction_DoNothingDeleteWhenPassed AlarmAction = 1
	// Drop out of time warp.
	AlarmAction_KillWarp AlarmAction = 2
	// Drop out of time warp.
	AlarmAction_KillWarpOnly AlarmAction = 3
	// Display a message.
	AlarmAction_MessageOnly AlarmAction = 4
	// Pause the game.
	AlarmAction_PauseGame AlarmAction = 5
)

func (v AlarmAction) Value() int32 {
	return int32(v)
}
func (v *AlarmAction) SetValue(val int32) {
	*v = AlarmAction(val)
}

// AlarmType - the type of an alarm.
type AlarmType int32

const (
	// An alarm for a specific date/time or a specific period in the future.
	AlarmType_Raw AlarmType = 0
	// An alarm based on the next maneuver node on the current ships flight path.
	// This node will be stored and can be restored when you come back to the ship.
	AlarmType_Maneuver AlarmType = 1
	// See <see cref="M:KerbalAlarmClock.AlarmType.Maneuver" />.
	AlarmType_ManeuverAuto AlarmType = 2
	// An alarm for furthest part of the orbit from the planet.
	AlarmType_Apoapsis AlarmType = 3
	// An alarm for nearest part of the orbit from the planet.
	AlarmType_Periapsis AlarmType = 4
	// Ascending node for the targeted object, or equatorial ascending node.
	AlarmType_AscendingNode AlarmType = 5
	// Descending node for the targeted object, or equatorial descending node.
	AlarmType_DescendingNode AlarmType = 6
	// An alarm based on the closest approach of this vessel to the targeted vessel,
	// some number of orbits into the future.
	AlarmType_Closest AlarmType = 7
	// An alarm based on the expiry or deadline of contracts in career modes.
	AlarmType_Contract AlarmType = 8
	// See <see cref="M:KerbalAlarmClock.AlarmType.Contract" />.
	AlarmType_ContractAuto AlarmType = 9
	// An alarm that is attached to a crew member.
	AlarmType_Crew AlarmType = 10
	// An alarm that is triggered when a selected target comes within a chosen
	// distance.
	AlarmType_Distance AlarmType = 11
	// An alarm based on the time in the "Earth" alternative Universe (aka the Real
	// World).
	AlarmType_EarthTime AlarmType = 12
	// An alarm that fires as your landed craft passes under the orbit of your
	// target.
	AlarmType_LaunchRendevous AlarmType = 13
	// An alarm manually based on when the next SOI point is on the flight path or
	// set to continually monitor the active flight path and add alarms as it
	// detects SOI changes.
	AlarmType_SOIChange AlarmType = 14
	// See <see cref="M:KerbalAlarmClock.AlarmType.SOIChange" />.
	AlarmType_SOIChangeAuto AlarmType = 15
	// An alarm based on Interplanetary Transfer Phase Angles, i.e. when should I
	// launch to planet X? Based on Kosmo Not's post and used in Olex's Calculator.
	AlarmType_Transfer AlarmType = 16
	// See <see cref="M:KerbalAlarmClock.AlarmType.Transfer" />.
	AlarmType_TransferModelled AlarmType = 17
)

func (v AlarmType) Value() int32 {
	return int32(v)
}
func (v *AlarmType) SetValue(val int32) {
	*v = AlarmType(val)
}

// Alarm - represents an alarm. Obtained by calling <see
// cref="M:KerbalAlarmClock.Alarms" />, <see
// cref="M:KerbalAlarmClock.AlarmWithName" /> or <see
// cref="M:KerbalAlarmClock.AlarmsWithType" />.
type Alarm struct {
	service.BaseClass
}

// NewAlarm creates a new Alarm.
func NewAlarm(id uint64, client *krpcgo.KRPCClient) *Alarm {
	c := &Alarm{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// KerbalAlarmClock - this service provides functionality to interact with <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/22809-13x-kerbal-alarm-clock-v3850-may-30/">Kerbal
// Alarm Clock</a>.
type KerbalAlarmClock struct {
	Client *krpcgo.KRPCClient
}

// New creates a new KerbalAlarmClock.
func New(client *krpcgo.KRPCClient) *KerbalAlarmClock {
	return &KerbalAlarmClock{Client: client}
}

// AlarmWithName - get the alarm with the given <paramref name="name" />, or nil
// if no alarms have that name. If more than one alarm has the name, only
// returns one of them.
//
// Allowed game scenes: any.
func (s *KerbalAlarmClock) AlarmWithName(name string) (*Alarm, error) {
	var err error
	var argBytes []byte
	var vv Alarm
	request := &types.ProcedureCall{
		Procedure: "AlarmWithName",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// AlarmsWithType - get a list of alarms of the specified <paramref name="type"
// />.
//
// Allowed game scenes: any.
func (s *KerbalAlarmClock) AlarmsWithType(t AlarmType) ([]*Alarm, error) {
	var err error
	var argBytes []byte
	var vv []*Alarm
	request := &types.ProcedureCall{
		Procedure: "AlarmsWithType",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(t)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// AlarmsWithTypeStream - get a list of alarms of the specified <paramref
// name="type" />.
//
// Allowed game scenes: any.
func (s *KerbalAlarmClock) AlarmsWithTypeStream(t AlarmType) (*krpcgo.Stream[[]*Alarm], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AlarmsWithType",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(t)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Alarm {
		var value []*Alarm
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CreateAlarm - create a new alarm and return it.
//
// Allowed game scenes: any.
func (s *KerbalAlarmClock) CreateAlarm(t AlarmType, name string, ut float64) (*Alarm, error) {
	var err error
	var argBytes []byte
	var vv Alarm
	request := &types.ProcedureCall{
		Procedure: "CreateAlarm",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(t)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// Available - whether Kerbal Alarm Clock is available.
//
// Allowed game scenes: any.
func (s *KerbalAlarmClock) Available() (bool, error) {
	var err error
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "get_Available",
		Service:   "KerbalAlarmClock",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableStream - whether Kerbal Alarm Clock is available.
//
// Allowed game scenes: any.
func (s *KerbalAlarmClock) AvailableStream() (*krpcgo.Stream[bool], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Available",
		Service:   "KerbalAlarmClock",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Alarms - a list of all the alarms.
//
// Allowed game scenes: any.
func (s *KerbalAlarmClock) Alarms() ([]*Alarm, error) {
	var err error
	var vv []*Alarm
	request := &types.ProcedureCall{
		Procedure: "get_Alarms",
		Service:   "KerbalAlarmClock",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// AlarmsStream - a list of all the alarms.
//
// Allowed game scenes: any.
func (s *KerbalAlarmClock) AlarmsStream() (*krpcgo.Stream[[]*Alarm], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Alarms",
		Service:   "KerbalAlarmClock",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Alarm {
		var value []*Alarm
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Remove - removes the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_Remove",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Action - the action that the alarm triggers.
//
// Allowed game scenes: any.
func (s *Alarm) Action() (AlarmAction, error) {
	var err error
	var argBytes []byte
	var vv AlarmAction
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Action",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActionStream - the action that the alarm triggers.
//
// Allowed game scenes: any.
func (s *Alarm) ActionStream() (*krpcgo.Stream[AlarmAction], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Action",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) AlarmAction {
		var value AlarmAction
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAction - the action that the alarm triggers.
//
// Allowed game scenes: any.
func (s *Alarm) SetAction(value AlarmAction) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_Action",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Margin - the number of seconds before the event that the alarm will fire.
//
// Allowed game scenes: any.
func (s *Alarm) Margin() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Margin",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MarginStream - the number of seconds before the event that the alarm will
// fire.
//
// Allowed game scenes: any.
func (s *Alarm) MarginStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Margin",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMargin - the number of seconds before the event that the alarm will fire.
//
// Allowed game scenes: any.
func (s *Alarm) SetMargin(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_Margin",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Time - the time at which the alarm will fire.
//
// Allowed game scenes: any.
func (s *Alarm) Time() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Time",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TimeStream - the time at which the alarm will fire.
//
// Allowed game scenes: any.
func (s *Alarm) TimeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Time",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTime - the time at which the alarm will fire.
//
// Allowed game scenes: any.
func (s *Alarm) SetTime(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_Time",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Type - the type of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) Type() (AlarmType, error) {
	var err error
	var argBytes []byte
	var vv AlarmType
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Type",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TypeStream - the type of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) TypeStream() (*krpcgo.Stream[AlarmType], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Type",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) AlarmType {
		var value AlarmType
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ID - the unique identifier for the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) ID() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_ID",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IDStream - the unique identifier for the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) IDStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_ID",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Name - the short name of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Name",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the short name of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Name",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetName - the short name of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_Name",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Notes - the long description of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) Notes() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Notes",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NotesStream - the long description of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) NotesStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Notes",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetNotes - the long description of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) SetNotes(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_Notes",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Remaining - the number of seconds until the alarm will fire.
//
// Allowed game scenes: any.
func (s *Alarm) Remaining() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Remaining",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RemainingStream - the number of seconds until the alarm will fire.
//
// Allowed game scenes: any.
func (s *Alarm) RemainingStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Remaining",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Repeat - whether the alarm will be repeated after it has fired.
//
// Allowed game scenes: any.
func (s *Alarm) Repeat() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Repeat",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RepeatStream - whether the alarm will be repeated after it has fired.
//
// Allowed game scenes: any.
func (s *Alarm) RepeatStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Repeat",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRepeat - whether the alarm will be repeated after it has fired.
//
// Allowed game scenes: any.
func (s *Alarm) SetRepeat(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_Repeat",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RepeatPeriod - the time delay to automatically create an alarm after it has
// fired.
//
// Allowed game scenes: any.
func (s *Alarm) RepeatPeriod() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_RepeatPeriod",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RepeatPeriodStream - the time delay to automatically create an alarm after it
// has fired.
//
// Allowed game scenes: any.
func (s *Alarm) RepeatPeriodStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_RepeatPeriod",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRepeatPeriod - the time delay to automatically create an alarm after it
// has fired.
//
// Allowed game scenes: any.
func (s *Alarm) SetRepeatPeriod(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_RepeatPeriod",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Vessel - the vessel that the alarm is attached to.
//
// Allowed game scenes: any.
func (s *Alarm) Vessel() (*spacecenter.Vessel, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.Vessel
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Vessel",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetVessel - the vessel that the alarm is attached to.
//
// Allowed game scenes: any.
func (s *Alarm) SetVessel(value *spacecenter.Vessel) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_Vessel",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// XferOriginBody - the celestial body the vessel is departing from.
//
// Allowed game scenes: any.
func (s *Alarm) XferOriginBody() (*spacecenter.CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.CelestialBody
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_XferOriginBody",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetXferOriginBody - the celestial body the vessel is departing from.
//
// Allowed game scenes: any.
func (s *Alarm) SetXferOriginBody(value *spacecenter.CelestialBody) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_XferOriginBody",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// XferTargetBody - the celestial body the vessel is arriving at.
//
// Allowed game scenes: any.
func (s *Alarm) XferTargetBody() (*spacecenter.CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.CelestialBody
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_XferTargetBody",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetXferTargetBody - the celestial body the vessel is arriving at.
//
// Allowed game scenes: any.
func (s *Alarm) SetXferTargetBody(value *spacecenter.CelestialBody) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_set_XferTargetBody",
		Service:   "KerbalAlarmClock",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}
