// Package drawing provides methods to invoke procedures in the Drawing service.
//
// From service docs: provides functionality for drawing objects in the flight
// scene.
package drawing

import (
	krpcgo "github.com/atburke/krpc-go"
	krpc "github.com/atburke/krpc-go/krpc"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	spacecenter "github.com/atburke/krpc-go/spacecenter"
	types "github.com/atburke/krpc-go/types"
	ui "github.com/atburke/krpc-go/ui"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// Line - a line. Created using <see cref="M:Drawing.AddLine" />.
type Line struct {
	service.BaseClass
}

// NewLine creates a new Line.
func NewLine(id uint64, client *krpcgo.KRPCClient) *Line {
	c := &Line{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Polygon - a polygon. Created using <see cref="M:Drawing.AddPolygon" />.
type Polygon struct {
	service.BaseClass
}

// NewPolygon creates a new Polygon.
func NewPolygon(id uint64, client *krpcgo.KRPCClient) *Polygon {
	c := &Polygon{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Text - text. Created using <see cref="M:Drawing.AddText" />.
type Text struct {
	service.BaseClass
}

// NewText creates a new Text.
func NewText(id uint64, client *krpcgo.KRPCClient) *Text {
	c := &Text{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Drawing - provides functionality for drawing objects in the flight scene.
type Drawing struct {
	Client *krpcgo.KRPCClient
}

// New creates a new Drawing.
func New(client *krpcgo.KRPCClient) *Drawing {
	return &Drawing{Client: client}
}

// AddLine - draw a line in the scene.
//
// Allowed game scenes: any.
func (s *Drawing) AddLine(start types.Tuple3[float64, float64, float64], end types.Tuple3[float64, float64, float64], referenceFrame *spacecenter.ReferenceFrame, visible bool) (*Line, error) {
	var err error
	var argBytes []byte
	var vv Line
	request := &types.ProcedureCall{
		Procedure: "AddLine",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(start)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(end)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddDirection - draw a direction vector in the scene, starting from the origin
// of the given reference frame.
//
// Allowed game scenes: any.
func (s *Drawing) AddDirection(direction types.Tuple3[float64, float64, float64], referenceFrame *spacecenter.ReferenceFrame, length float32, visible bool) (*Line, error) {
	var err error
	var argBytes []byte
	var vv Line
	request := &types.ProcedureCall{
		Procedure: "AddDirection",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(length)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddDirectionFromCom - draw a direction vector in the scene, from the center
// of mass of the active vessel.
//
// Allowed game scenes: any.
func (s *Drawing) AddDirectionFromCom(direction types.Tuple3[float64, float64, float64], referenceFrame *spacecenter.ReferenceFrame, length float32, visible bool) (*Line, error) {
	var err error
	var argBytes []byte
	var vv Line
	request := &types.ProcedureCall{
		Procedure: "AddDirectionFromCom",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(length)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddPolygon - draw a polygon in the scene, defined by a list of vertices.
//
// Allowed game scenes: any.
func (s *Drawing) AddPolygon(vertices []types.Tuple3[float64, float64, float64], referenceFrame *spacecenter.ReferenceFrame, visible bool) (*Polygon, error) {
	var err error
	var argBytes []byte
	var vv Polygon
	request := &types.ProcedureCall{
		Procedure: "AddPolygon",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(vertices)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddText - draw text in the scene.
//
// Allowed game scenes: any.
func (s *Drawing) AddText(text string, referenceFrame *spacecenter.ReferenceFrame, position types.Tuple3[float64, float64, float64], rotation types.Tuple4[float64, float64, float64, float64], visible bool) (*Text, error) {
	var err error
	var argBytes []byte
	var vv Text
	request := &types.ProcedureCall{
		Procedure: "AddText",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(text)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(visible)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Clear - remove all objects being drawn.
//
// Allowed game scenes: any.
func (s *Drawing) Clear(clientOnly bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Clear",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(clientOnly)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Remove - remove the object.
//
// Allowed game scenes: any.
func (s *Line) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_Remove",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Start - start position of the line.
//
// Allowed game scenes: any.
func (s *Line) Start() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Line_get_Start",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StartStream - start position of the line.
//
// Allowed game scenes: any.
func (s *Line) StartStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_get_Start",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetStart - start position of the line.
//
// Allowed game scenes: any.
func (s *Line) SetStart(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_set_Start",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// End - end position of the line.
//
// Allowed game scenes: any.
func (s *Line) End() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Line_get_End",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EndStream - end position of the line.
//
// Allowed game scenes: any.
func (s *Line) EndStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_get_End",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetEnd - end position of the line.
//
// Allowed game scenes: any.
func (s *Line) SetEnd(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_set_End",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color - set the color
//
// Allowed game scenes: any.
func (s *Line) Color() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Line_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ColorStream - set the color
//
// Allowed game scenes: any.
func (s *Line) ColorStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetColor - set the color
//
// Allowed game scenes: any.
func (s *Line) SetColor(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_set_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thickness - set the thickness
//
// Allowed game scenes: any.
func (s *Line) Thickness() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Line_get_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThicknessStream - set the thickness
//
// Allowed game scenes: any.
func (s *Line) ThicknessStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_get_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetThickness - set the thickness
//
// Allowed game scenes: any.
func (s *Line) SetThickness(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_set_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame - reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Line) ReferenceFrame() (*spacecenter.ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Line_get_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetReferenceFrame - reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Line) SetReferenceFrame(value *spacecenter.ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_set_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Visible - whether the object is visible.
//
// Allowed game scenes: any.
func (s *Line) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Line_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VisibleStream - whether the object is visible.
//
// Allowed game scenes: any.
func (s *Line) VisibleStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVisible - whether the object is visible.
//
// Allowed game scenes: any.
func (s *Line) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_set_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Material - material used to render the object. Creates the material from a
// shader with the given name.
//
// Allowed game scenes: any.
func (s *Line) Material() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Line_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaterialStream - material used to render the object. Creates the material
// from a shader with the given name.
//
// Allowed game scenes: any.
func (s *Line) MaterialStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMaterial - material used to render the object. Creates the material from a
// shader with the given name.
//
// Allowed game scenes: any.
func (s *Line) SetMaterial(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Line_set_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Remove - remove the object.
//
// Allowed game scenes: any.
func (s *Polygon) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_Remove",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Vertices - vertices for the polygon.
//
// Allowed game scenes: any.
func (s *Polygon) Vertices() ([]types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv []types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Vertices",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VerticesStream - vertices for the polygon.
//
// Allowed game scenes: any.
func (s *Polygon) VerticesStream() (*krpcgo.Stream[[]types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Vertices",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []types.Tuple3[float64, float64, float64] {
		var value []types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVertices - vertices for the polygon.
//
// Allowed game scenes: any.
func (s *Polygon) SetVertices(value []types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_set_Vertices",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color - set the color
//
// Allowed game scenes: any.
func (s *Polygon) Color() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ColorStream - set the color
//
// Allowed game scenes: any.
func (s *Polygon) ColorStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetColor - set the color
//
// Allowed game scenes: any.
func (s *Polygon) SetColor(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_set_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thickness - set the thickness
//
// Allowed game scenes: any.
func (s *Polygon) Thickness() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThicknessStream - set the thickness
//
// Allowed game scenes: any.
func (s *Polygon) ThicknessStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetThickness - set the thickness
//
// Allowed game scenes: any.
func (s *Polygon) SetThickness(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_set_Thickness",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame - reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Polygon) ReferenceFrame() (*spacecenter.ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetReferenceFrame - reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Polygon) SetReferenceFrame(value *spacecenter.ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_set_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Visible - whether the object is visible.
//
// Allowed game scenes: any.
func (s *Polygon) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VisibleStream - whether the object is visible.
//
// Allowed game scenes: any.
func (s *Polygon) VisibleStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVisible - whether the object is visible.
//
// Allowed game scenes: any.
func (s *Polygon) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_set_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Material - material used to render the object. Creates the material from a
// shader with the given name.
//
// Allowed game scenes: any.
func (s *Polygon) Material() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaterialStream - material used to render the object. Creates the material
// from a shader with the given name.
//
// Allowed game scenes: any.
func (s *Polygon) MaterialStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMaterial - material used to render the object. Creates the material from a
// shader with the given name.
//
// Allowed game scenes: any.
func (s *Polygon) SetMaterial(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Polygon_set_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AvailableFonts - a list of all available fonts.
//
// Allowed game scenes: any.
func (s *Text) AvailableFonts() ([]string, error) {
	var err error
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "Text_static_AvailableFonts",
		Service:   "Drawing",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableFontsStream - a list of all available fonts.
//
// Allowed game scenes: any.
func (s *Text) AvailableFontsStream() (*krpcgo.Stream[[]string], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "Text_static_AvailableFonts",
		Service:   "Drawing",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Remove - remove the object.
//
// Allowed game scenes: any.
func (s *Text) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_Remove",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position - position of the text.
//
// Allowed game scenes: any.
func (s *Text) Position() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Text_get_Position",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionStream - position of the text.
//
// Allowed game scenes: any.
func (s *Text) PositionStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Position",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPosition - position of the text.
//
// Allowed game scenes: any.
func (s *Text) SetPosition(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Position",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Rotation - rotation of the text as a quaternion.
//
// Allowed game scenes: any.
func (s *Text) Rotation() (types.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple4[float64, float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Text_get_Rotation",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationStream - rotation of the text as a quaternion.
//
// Allowed game scenes: any.
func (s *Text) RotationStream() (*krpcgo.Stream[types.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Rotation",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple4[float64, float64, float64, float64] {
		var value types.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRotation - rotation of the text as a quaternion.
//
// Allowed game scenes: any.
func (s *Text) SetRotation(value types.Tuple4[float64, float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Rotation",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Content - the text string
//
// Allowed game scenes: any.
func (s *Text) Content() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Text_get_Content",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ContentStream - the text string
//
// Allowed game scenes: any.
func (s *Text) ContentStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Content",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetContent - the text string
//
// Allowed game scenes: any.
func (s *Text) SetContent(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Content",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Font - name of the font
//
// Allowed game scenes: any.
func (s *Text) Font() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Text_get_Font",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FontStream - name of the font
//
// Allowed game scenes: any.
func (s *Text) FontStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Font",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetFont - name of the font
//
// Allowed game scenes: any.
func (s *Text) SetFont(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Font",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Size - font size.
//
// Allowed game scenes: any.
func (s *Text) Size() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "Text_get_Size",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SizeStream - font size.
//
// Allowed game scenes: any.
func (s *Text) SizeStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Size",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSize - font size.
//
// Allowed game scenes: any.
func (s *Text) SetSize(value int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Size",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CharacterSize - character size.
//
// Allowed game scenes: any.
func (s *Text) CharacterSize() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Text_get_CharacterSize",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CharacterSizeStream - character size.
//
// Allowed game scenes: any.
func (s *Text) CharacterSizeStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_CharacterSize",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetCharacterSize - character size.
//
// Allowed game scenes: any.
func (s *Text) SetCharacterSize(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_CharacterSize",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Style - font style.
//
// Allowed game scenes: any.
func (s *Text) Style() (ui.FontStyle, error) {
	var err error
	var argBytes []byte
	var vv ui.FontStyle
	request := &types.ProcedureCall{
		Procedure: "Text_get_Style",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StyleStream - font style.
//
// Allowed game scenes: any.
func (s *Text) StyleStream() (*krpcgo.Stream[ui.FontStyle], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Style",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ui.FontStyle {
		var value ui.FontStyle
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetStyle - font style.
//
// Allowed game scenes: any.
func (s *Text) SetStyle(value ui.FontStyle) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Style",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Alignment - alignment.
//
// Allowed game scenes: any.
func (s *Text) Alignment() (ui.TextAlignment, error) {
	var err error
	var argBytes []byte
	var vv ui.TextAlignment
	request := &types.ProcedureCall{
		Procedure: "Text_get_Alignment",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AlignmentStream - alignment.
//
// Allowed game scenes: any.
func (s *Text) AlignmentStream() (*krpcgo.Stream[ui.TextAlignment], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Alignment",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ui.TextAlignment {
		var value ui.TextAlignment
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAlignment - alignment.
//
// Allowed game scenes: any.
func (s *Text) SetAlignment(value ui.TextAlignment) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Alignment",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LineSpacing - line spacing.
//
// Allowed game scenes: any.
func (s *Text) LineSpacing() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Text_get_LineSpacing",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LineSpacingStream - line spacing.
//
// Allowed game scenes: any.
func (s *Text) LineSpacingStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_LineSpacing",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLineSpacing - line spacing.
//
// Allowed game scenes: any.
func (s *Text) SetLineSpacing(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_LineSpacing",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Anchor - anchor.
//
// Allowed game scenes: any.
func (s *Text) Anchor() (ui.TextAnchor, error) {
	var err error
	var argBytes []byte
	var vv ui.TextAnchor
	request := &types.ProcedureCall{
		Procedure: "Text_get_Anchor",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AnchorStream - anchor.
//
// Allowed game scenes: any.
func (s *Text) AnchorStream() (*krpcgo.Stream[ui.TextAnchor], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Anchor",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ui.TextAnchor {
		var value ui.TextAnchor
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAnchor - anchor.
//
// Allowed game scenes: any.
func (s *Text) SetAnchor(value ui.TextAnchor) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Anchor",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color - set the color
//
// Allowed game scenes: any.
func (s *Text) Color() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Text_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ColorStream - set the color
//
// Allowed game scenes: any.
func (s *Text) ColorStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetColor - set the color
//
// Allowed game scenes: any.
func (s *Text) SetColor(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Color",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame - reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Text) ReferenceFrame() (*spacecenter.ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Text_get_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetReferenceFrame - reference frame for the positions of the object.
//
// Allowed game scenes: any.
func (s *Text) SetReferenceFrame(value *spacecenter.ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_ReferenceFrame",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Visible - whether the object is visible.
//
// Allowed game scenes: any.
func (s *Text) Visible() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Text_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VisibleStream - whether the object is visible.
//
// Allowed game scenes: any.
func (s *Text) VisibleStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVisible - whether the object is visible.
//
// Allowed game scenes: any.
func (s *Text) SetVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Visible",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Material - material used to render the object. Creates the material from a
// shader with the given name.
//
// Allowed game scenes: any.
func (s *Text) Material() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Text_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaterialStream - material used to render the object. Creates the material
// from a shader with the given name.
//
// Allowed game scenes: any.
func (s *Text) MaterialStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_get_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMaterial - material used to render the object. Creates the material from a
// shader with the given name.
//
// Allowed game scenes: any.
func (s *Text) SetMaterial(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Text_set_Material",
		Service:   "Drawing",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}
