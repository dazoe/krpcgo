// Package lidar provides methods to invoke procedures in the LiDAR service.
//
// From service docs: laserDist service.
package lidar

import (
	krpcgo "github.com/atburke/krpc-go"
	krpc "github.com/atburke/krpc-go/krpc"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	spacecenter "github.com/atburke/krpc-go/spacecenter"
	types "github.com/atburke/krpc-go/types"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// Laser - a LaserDist laser.
type Laser struct {
	service.BaseClass
}

// NewLaser creates a new Laser.
func NewLaser(id uint64, client *krpcgo.KRPCClient) *Laser {
	c := &Laser{BaseClass: service.BaseClass{Client: client}}
	c.SetID(id)
	return c
}

// LiDAR - laserDist service.
type LiDAR struct {
	Client *krpcgo.KRPCClient
}

// New creates a new LiDAR.
func New(client *krpcgo.KRPCClient) *LiDAR {
	return &LiDAR{Client: client}
}

// Laser - get a LaserDist part.
//
// Allowed game scenes: any.
func (s *LiDAR) Laser(part *spacecenter.Part) (*Laser, error) {
	var err error
	var argBytes []byte
	var vv Laser
	request := &types.ProcedureCall{
		Procedure: "Laser",
		Service:   "LiDAR",
	}
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// Available - check if the LaserDist API is available.
//
// Allowed game scenes: any.
func (s *LiDAR) Available() (bool, error) {
	var err error
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "get_Available",
		Service:   "LiDAR",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableStream - check if the LaserDist API is available.
//
// Allowed game scenes: any.
func (s *LiDAR) AvailableStream() (*krpcgo.Stream[bool], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Available",
		Service:   "LiDAR",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - get the part containing this LiDAR.
//
// Allowed game scenes: any.
func (s *Laser) Part() (*spacecenter.Part, error) {
	var err error
	var argBytes []byte
	var vv spacecenter.Part
	request := &types.ProcedureCall{
		Procedure: "Laser_get_Part",
		Service:   "LiDAR",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	vv.Client = s.Client
	return &vv, nil
}

// Cloud - get the point cloud from the LiDAR. Returns an empty list on failure.
//
// Allowed game scenes: any.
func (s *Laser) Cloud() ([]float64, error) {
	var err error
	var argBytes []byte
	var vv []float64
	request := &types.ProcedureCall{
		Procedure: "Laser_get_Cloud",
		Service:   "LiDAR",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CloudStream - get the point cloud from the LiDAR. Returns an empty list on
// failure.
//
// Allowed game scenes: any.
func (s *Laser) CloudStream() (*krpcgo.Stream[[]float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Laser_get_Cloud",
		Service:   "LiDAR",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []float64 {
		var value []float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}
