// Package spacecenter provides methods to invoke procedures in the SpaceCenter
// service.
//
// From service docs: provides functionality to interact with Kerbal Space
// Program. This includes controlling the active vessel, managing its resources,
// planning maneuver nodes and auto-piloting.
package spacecenter

import (
	krpcgo "github.com/atburke/krpc-go"
	krpc "github.com/atburke/krpc-go/krpc"
	encode "github.com/atburke/krpc-go/lib/encode"
	service "github.com/atburke/krpc-go/lib/service"
	types "github.com/atburke/krpc-go/types"
	tracerr "github.com/ztrue/tracerr"
)

// Code generated by gen_services.go. DO NOT EDIT.

// CameraMode - see <see cref="M:SpaceCenter.Camera.Mode" />.
type CameraMode int32

const (
	// The camera is showing the active vessel, in "auto" mode.
	CameraMode_Automatic CameraMode = 0
	// The camera is showing the active vessel, in "free" mode.
	CameraMode_Free CameraMode = 1
	// The camera is showing the active vessel, in "chase" mode.
	CameraMode_Chase CameraMode = 2
	// The camera is showing the active vessel, in "locked" mode.
	CameraMode_Locked CameraMode = 3
	// The camera is showing the active vessel, in "orbital" mode.
	CameraMode_Orbital CameraMode = 4
	// The Intra-Vehicular Activity view is being shown.
	CameraMode_IVA CameraMode = 5
	// The map view is being shown.
	CameraMode_Map CameraMode = 6
)

func (v CameraMode) Value() int32 {
	return int32(v)
}
func (v *CameraMode) SetValue(val int32) {
	*v = CameraMode(val)
}

/*
CommLinkType - the type of a communication link. See <see
cref="M:SpaceCenter.CommLink.Type" />.
*/
type CommLinkType int32

const (
	// Link is to a base station on Kerbin.
	CommLinkType_Home CommLinkType = 0
	// Link is to a control source, for example a manned spacecraft.
	CommLinkType_Control CommLinkType = 1
	// Link is to a relay satellite.
	CommLinkType_Relay CommLinkType = 2
)

func (v CommLinkType) Value() int32 {
	return int32(v)
}
func (v *CommLinkType) SetValue(val int32) {
	*v = CommLinkType(val)
}

/*
ContractState - the state of a contract. See <see
cref="M:SpaceCenter.Contract.State" />.
*/
type ContractState int32

const (
	// The contract is active.
	ContractState_Active ContractState = 0
	// The contract has been canceled.
	ContractState_Canceled ContractState = 1
	// The contract has been completed.
	ContractState_Completed ContractState = 2
	// The deadline for the contract has expired.
	ContractState_DeadlineExpired ContractState = 3
	// The contract has been declined.
	ContractState_Declined ContractState = 4
	// The contract has been failed.
	ContractState_Failed ContractState = 5
	// The contract has been generated.
	ContractState_Generated ContractState = 6
	// The contract has been offered to the player.
	ContractState_Offered ContractState = 7
	// The contract was offered to the player, but the offer expired.
	ContractState_OfferExpired ContractState = 8
	// The contract has been withdrawn.
	ContractState_Withdrawn ContractState = 9
)

func (v ContractState) Value() int32 {
	return int32(v)
}
func (v *ContractState) SetValue(val int32) {
	*v = ContractState(val)
}

// ControlInputMode - see <see cref="M:SpaceCenter.Control.InputMode" />.
type ControlInputMode int32

const (
	// Control inputs are added to the vessels current control inputs.
	ControlInputMode_Additive ControlInputMode = 0
	// Control inputs (when they are non-zero) override the vessels current control
	// inputs.
	ControlInputMode_Override ControlInputMode = 1
)

func (v ControlInputMode) Value() int32 {
	return int32(v)
}
func (v *ControlInputMode) SetValue(val int32) {
	*v = ControlInputMode(val)
}

/*
ControlSource - the control source of a vessel. See <see
cref="M:SpaceCenter.Control.Source" />.
*/
type ControlSource int32

const (
	// Vessel is controlled by a Kerbal.
	ControlSource_Kerbal ControlSource = 0
	// Vessel is controlled by a probe core.
	ControlSource_Probe ControlSource = 1
	// Vessel is not controlled.
	ControlSource_None ControlSource = 2
)

func (v ControlSource) Value() int32 {
	return int32(v)
}
func (v *ControlSource) SetValue(val int32) {
	*v = ControlSource(val)
}

/*
ControlState - the control state of a vessel. See <see
cref="M:SpaceCenter.Control.State" />.
*/
type ControlState int32

const (
	// Full controllable.
	ControlState_Full ControlState = 0
	// Partially controllable.
	ControlState_Partial ControlState = 1
	// Not controllable.
	ControlState_None ControlState = 2
)

func (v ControlState) Value() int32 {
	return int32(v)
}
func (v *ControlState) SetValue(val int32) {
	*v = ControlState(val)
}

/*
CrewMemberGender - a crew member's gender. See <see
cref="M:SpaceCenter.CrewMember.Gender" />.
*/
type CrewMemberGender int32

const (
	// Male.
	CrewMemberGender_Male CrewMemberGender = 0
	// Female.
	CrewMemberGender_Female CrewMemberGender = 1
)

func (v CrewMemberGender) Value() int32 {
	return int32(v)
}
func (v *CrewMemberGender) SetValue(val int32) {
	*v = CrewMemberGender(val)
}

/*
CrewMemberType - the type of a crew member. See <see
cref="M:SpaceCenter.CrewMember.Type" />.
*/
type CrewMemberType int32

const (
	// An applicant for crew.
	CrewMemberType_Applicant CrewMemberType = 0
	// Rocket crew.
	CrewMemberType_Crew CrewMemberType = 1
	// A tourist.
	CrewMemberType_Tourist CrewMemberType = 2
	// An unowned crew member.
	CrewMemberType_Unowned CrewMemberType = 3
)

func (v CrewMemberType) Value() int32 {
	return int32(v)
}
func (v *CrewMemberType) SetValue(val int32) {
	*v = CrewMemberType(val)
}

/*
EditorFacility - editor facility. See <see
cref="M:SpaceCenter.LaunchSite.EditorFacility" />.
*/
type EditorFacility int32

const (
	// Vehicle Assembly Building.
	EditorFacility_VAB EditorFacility = 1
	// Space Plane Hanger.
	EditorFacility_SPH EditorFacility = 2
	// None.
	EditorFacility_None EditorFacility = 0
)

func (v EditorFacility) Value() int32 {
	return int32(v)
}
func (v *EditorFacility) SetValue(val int32) {
	*v = EditorFacility(val)
}

// GameMode - the game mode. Returned by <see cref="T:SpaceCenter.GameMode" />
type GameMode int32

const (
	// Sandbox mode.
	GameMode_Sandbox GameMode = 0
	// Career mode.
	GameMode_Career GameMode = 1
	// Science career mode.
	GameMode_Science GameMode = 2
	// Science sandbox mode.
	GameMode_ScienceSandbox GameMode = 3
	// Mission mode.
	GameMode_Mission GameMode = 4
	// Mission builder mode.
	GameMode_MissionBuilder GameMode = 5
	// Scenario mode.
	GameMode_Scenario GameMode = 6
	// Scenario mode that cannot be resumed.
	GameMode_ScenarioNonResumable GameMode = 7
)

func (v GameMode) Value() int32 {
	return int32(v)
}
func (v *GameMode) SetValue(val int32) {
	*v = GameMode(val)
}

/*
MapFilterType - the set of things that are visible in map mode. These may be
combined with bitwise logic.
*/
type MapFilterType int32

const (
	// Everything.
	MapFilterType_All MapFilterType = -1
	// Nothing.
	MapFilterType_None MapFilterType = 0
	// Debris.
	MapFilterType_Debris MapFilterType = 1
	// Unknown.
	MapFilterType_Unknown MapFilterType = 2
	// SpaceObjects.
	MapFilterType_SpaceObjects MapFilterType = 4
	// Probes.
	MapFilterType_Probes MapFilterType = 8
	// Rovers.
	MapFilterType_Rovers MapFilterType = 16
	// Landers.
	MapFilterType_Landers MapFilterType = 32
	// Ships.
	MapFilterType_Ships MapFilterType = 64
	// Stations.
	MapFilterType_Stations MapFilterType = 128
	// Bases.
	MapFilterType_Bases MapFilterType = 256
	// EVAs.
	MapFilterType_EVAs MapFilterType = 512
	// Flags.
	MapFilterType_Flags MapFilterType = 1024
	// Planes.
	MapFilterType_Plane MapFilterType = 2048
	// Relays.
	MapFilterType_Relay MapFilterType = 4096
	// Launch Sites.
	MapFilterType_Site MapFilterType = 8192
	// Deployed Science Controllers.
	MapFilterType_DeployedScienceController MapFilterType = 16384
)

func (v MapFilterType) Value() int32 {
	return int32(v)
}
func (v *MapFilterType) SetValue(val int32) {
	*v = MapFilterType(val)
}

/*
AntennaState - the state of an antenna. See <see
cref="M:SpaceCenter.Antenna.State" />.
*/
type AntennaState int32

const (
	// Antenna is fully deployed.
	AntennaState_Deployed AntennaState = 0
	// Antenna is fully retracted.
	AntennaState_Retracted AntennaState = 1
	// Antenna is being deployed.
	AntennaState_Deploying AntennaState = 2
	// Antenna is being retracted.
	AntennaState_Retracting AntennaState = 3
	// Antenna is broken.
	AntennaState_Broken AntennaState = 4
)

func (v AntennaState) Value() int32 {
	return int32(v)
}
func (v *AntennaState) SetValue(val int32) {
	*v = AntennaState(val)
}

/*
AutoStrutMode - the state of an auto-strut. <see
cref="M:SpaceCenter.Part.AutoStrutMode" />
*/
type AutoStrutMode int32

const (
	// Off
	AutoStrutMode_Off AutoStrutMode = 0
	// Root
	AutoStrutMode_Root AutoStrutMode = 1
	// Heaviest
	AutoStrutMode_Heaviest AutoStrutMode = 2
	// Grandparent
	AutoStrutMode_Grandparent AutoStrutMode = 3
	// ForceRoot
	AutoStrutMode_ForceRoot AutoStrutMode = 4
	// ForceHeaviest
	AutoStrutMode_ForceHeaviest AutoStrutMode = 5
	// ForceGrandparent
	AutoStrutMode_ForceGrandparent AutoStrutMode = 6
)

func (v AutoStrutMode) Value() int32 {
	return int32(v)
}
func (v *AutoStrutMode) SetValue(val int32) {
	*v = AutoStrutMode(val)
}

/*
CargoBayState - the state of a cargo bay. See <see
cref="M:SpaceCenter.CargoBay.State" />.
*/
type CargoBayState int32

const (
	// Cargo bay is fully open.
	CargoBayState_Open CargoBayState = 0
	// Cargo bay closed and locked.
	CargoBayState_Closed CargoBayState = 1
	// Cargo bay is opening.
	CargoBayState_Opening CargoBayState = 2
	// Cargo bay is closing.
	CargoBayState_Closing CargoBayState = 3
)

func (v CargoBayState) Value() int32 {
	return int32(v)
}
func (v *CargoBayState) SetValue(val int32) {
	*v = CargoBayState(val)
}

/*
DockingPortState - the state of a docking port. See <see
cref="M:SpaceCenter.DockingPort.State" />.
*/
type DockingPortState int32

const (
	// The docking port is ready to dock to another docking port.
	DockingPortState_Ready DockingPortState = 0
	// The docking port is docked to another docking port, or docked to another part
	// (from the VAB/SPH).
	DockingPortState_Docked DockingPortState = 1
	// The docking port is very close to another docking port, but has not docked.
	// It is using magnetic force to acquire a solid dock.
	DockingPortState_Docking DockingPortState = 2
	// The docking port has just been undocked from another docking port, and is
	// disabled until it moves away by a sufficient distance (<see
	// cref="M:SpaceCenter.DockingPort.ReengageDistance" />).
	DockingPortState_Undocking DockingPortState = 3
	// The docking port has a shield, and the shield is closed.
	DockingPortState_Shielded DockingPortState = 4
	// The docking ports shield is currently opening/closing.
	DockingPortState_Moving DockingPortState = 5
)

func (v DockingPortState) Value() int32 {
	return int32(v)
}
func (v *DockingPortState) SetValue(val int32) {
	*v = DockingPortState(val)
}

/*
DrainMode - resource drain mode. See <see
cref="M:SpaceCenter.ResourceDrain.DrainMode" />.
*/
type DrainMode int32

const (
	// Drains from the parent part.
	DrainMode_Part DrainMode = 0
	// Drains from all available parts.
	DrainMode_Vessel DrainMode = 1
)

func (v DrainMode) Value() int32 {
	return int32(v)
}
func (v *DrainMode) SetValue(val int32) {
	*v = DrainMode(val)
}

/*
LegState - the state of a landing leg. See <see
cref="M:SpaceCenter.Leg.State" />.
*/
type LegState int32

const (
	// Landing leg is fully deployed.
	LegState_Deployed LegState = 0
	// Landing leg is fully retracted.
	LegState_Retracted LegState = 1
	// Landing leg is being deployed.
	LegState_Deploying LegState = 2
	// Landing leg is being retracted.
	LegState_Retracting LegState = 3
	// Landing leg is broken.
	LegState_Broken LegState = 4
)

func (v LegState) Value() int32 {
	return int32(v)
}
func (v *LegState) SetValue(val int32) {
	*v = LegState(val)
}

/*
MotorState - the state of the motor on a powered wheel. See <see
cref="M:SpaceCenter.Wheel.MotorState" />.
*/
type MotorState int32

const (
	// The motor is idle.
	MotorState_Idle MotorState = 0
	// The motor is running.
	MotorState_Running MotorState = 1
	// The motor is disabled.
	MotorState_Disabled MotorState = 2
	// The motor is inoperable.
	MotorState_Inoperable MotorState = 3
	// The motor does not have enough resources to run.
	MotorState_NotEnoughResources MotorState = 4
)

func (v MotorState) Value() int32 {
	return int32(v)
}
func (v *MotorState) SetValue(val int32) {
	*v = MotorState(val)
}

/*
ParachuteState - the state of a parachute. See <see
cref="M:SpaceCenter.Parachute.State" />.
*/
type ParachuteState int32

const (
	// The parachute is safely tucked away inside its housing.
	ParachuteState_Stowed ParachuteState = 0
	// The parachute is armed for deployment.
	ParachuteState_Armed ParachuteState = 1
	// The parachute has been deployed and is providing some drag, but is not fully
	// deployed yet. (Stock parachutes only)
	ParachuteState_SemiDeployed ParachuteState = 2
	// The parachute is fully deployed.
	ParachuteState_Deployed ParachuteState = 3
	// The parachute has been cut.
	ParachuteState_Cut ParachuteState = 4
)

func (v ParachuteState) Value() int32 {
	return int32(v)
}
func (v *ParachuteState) SetValue(val int32) {
	*v = ParachuteState(val)
}

/*
RadiatorState - the state of a radiator. <see
cref="M:SpaceCenter.Radiator.State" />
*/
type RadiatorState int32

const (
	// Radiator is fully extended.
	RadiatorState_Extended RadiatorState = 0
	// Radiator is fully retracted.
	RadiatorState_Retracted RadiatorState = 1
	// Radiator is being extended.
	RadiatorState_Extending RadiatorState = 2
	// Radiator is being retracted.
	RadiatorState_Retracting RadiatorState = 3
	// Radiator is broken.
	RadiatorState_Broken RadiatorState = 4
)

func (v RadiatorState) Value() int32 {
	return int32(v)
}
func (v *RadiatorState) SetValue(val int32) {
	*v = RadiatorState(val)
}

/*
ResourceConverterState - the state of a resource converter. See <see
cref="M:SpaceCenter.ResourceConverter.State" />.
*/
type ResourceConverterState int32

const (
	// Converter is running.
	ResourceConverterState_Running ResourceConverterState = 0
	// Converter is idle.
	ResourceConverterState_Idle ResourceConverterState = 1
	// Converter is missing a required resource.
	ResourceConverterState_MissingResource ResourceConverterState = 2
	// No available storage for output resource.
	ResourceConverterState_StorageFull ResourceConverterState = 3
	// At preset resource capacity.
	ResourceConverterState_Capacity ResourceConverterState = 4
	// Unknown state. Possible with modified resource converters. In this case,
	// check <see cref="M:SpaceCenter.ResourceConverter.StatusInfo" /> for more
	// information.
	ResourceConverterState_Unknown ResourceConverterState = 5
)

func (v ResourceConverterState) Value() int32 {
	return int32(v)
}
func (v *ResourceConverterState) SetValue(val int32) {
	*v = ResourceConverterState(val)
}

/*
ResourceHarvesterState - the state of a resource harvester. See <see
cref="M:SpaceCenter.ResourceHarvester.State" />.
*/
type ResourceHarvesterState int32

const (
	// The drill is deploying.
	ResourceHarvesterState_Deploying ResourceHarvesterState = 0
	// The drill is deployed and ready.
	ResourceHarvesterState_Deployed ResourceHarvesterState = 1
	// The drill is retracting.
	ResourceHarvesterState_Retracting ResourceHarvesterState = 2
	// The drill is retracted.
	ResourceHarvesterState_Retracted ResourceHarvesterState = 3
	// The drill is running.
	ResourceHarvesterState_Active ResourceHarvesterState = 4
)

func (v ResourceHarvesterState) Value() int32 {
	return int32(v)
}
func (v *ResourceHarvesterState) SetValue(val int32) {
	*v = ResourceHarvesterState(val)
}

/*
SolarPanelState - the state of a solar panel. See <see
cref="M:SpaceCenter.SolarPanel.State" />.
*/
type SolarPanelState int32

const (
	// Solar panel is fully extended.
	SolarPanelState_Extended SolarPanelState = 0
	// Solar panel is fully retracted.
	SolarPanelState_Retracted SolarPanelState = 1
	// Solar panel is being extended.
	SolarPanelState_Extending SolarPanelState = 2
	// Solar panel is being retracted.
	SolarPanelState_Retracting SolarPanelState = 3
	// Solar panel is broken.
	SolarPanelState_Broken SolarPanelState = 4
)

func (v SolarPanelState) Value() int32 {
	return int32(v)
}
func (v *SolarPanelState) SetValue(val int32) {
	*v = SolarPanelState(val)
}

/*
WheelState - the state of a wheel. See <see cref="M:SpaceCenter.Wheel.State"
/>.
*/
type WheelState int32

const (
	// Wheel is fully deployed.
	WheelState_Deployed WheelState = 0
	// Wheel is fully retracted.
	WheelState_Retracted WheelState = 1
	// Wheel is being deployed.
	WheelState_Deploying WheelState = 2
	// Wheel is being retracted.
	WheelState_Retracting WheelState = 3
	// Wheel is broken.
	WheelState_Broken WheelState = 4
)

func (v WheelState) Value() int32 {
	return int32(v)
}
func (v *WheelState) SetValue(val int32) {
	*v = WheelState(val)
}

/*
ResourceFlowMode - the way in which a resource flows between parts. See <see
cref="M:SpaceCenter.Resources.FlowMode" />.
*/
type ResourceFlowMode int32

const (
	// The resource flows to any part in the vessel. For example, electric charge.
	ResourceFlowMode_Vessel ResourceFlowMode = 0
	// The resource flows from parts in the first stage, followed by the second, and
	// so on. For example, mono-propellant.
	ResourceFlowMode_Stage ResourceFlowMode = 1
	// The resource flows between adjacent parts within the vessel. For example,
	// liquid fuel or oxidizer.
	ResourceFlowMode_Adjacent ResourceFlowMode = 2
	// The resource does not flow. For example, solid fuel.
	ResourceFlowMode_None ResourceFlowMode = 3
)

func (v ResourceFlowMode) Value() int32 {
	return int32(v)
}
func (v *ResourceFlowMode) SetValue(val int32) {
	*v = ResourceFlowMode(val)
}

/*
RosterStatus - a crew member's roster status. See <see
cref="M:SpaceCenter.CrewMember.RosterStatus" />.
*/
type RosterStatus int32

const (
	// Available.
	RosterStatus_Available RosterStatus = 0
	// Assigned.
	RosterStatus_Assigned RosterStatus = 1
	// Dead.
	RosterStatus_Dead RosterStatus = 2
	// Missing.
	RosterStatus_Missing RosterStatus = 3
)

func (v RosterStatus) Value() int32 {
	return int32(v)
}
func (v *RosterStatus) SetValue(val int32) {
	*v = RosterStatus(val)
}

/*
SASMode - the behavior of the SAS auto-pilot. See <see
cref="M:SpaceCenter.AutoPilot.SASMode" />.
*/
type SASMode int32

const (
	// Stability assist mode. Dampen out any rotation.
	SASMode_StabilityAssist SASMode = 0
	// Point in the burn direction of the next maneuver node.
	SASMode_Maneuver SASMode = 1
	// Point in the prograde direction.
	SASMode_Prograde SASMode = 2
	// Point in the retrograde direction.
	SASMode_Retrograde SASMode = 3
	// Point in the orbit normal direction.
	SASMode_Normal SASMode = 4
	// Point in the orbit anti-normal direction.
	SASMode_AntiNormal SASMode = 5
	// Point in the orbit radial direction.
	SASMode_Radial SASMode = 6
	// Point in the orbit anti-radial direction.
	SASMode_AntiRadial SASMode = 7
	// Point in the direction of the current target.
	SASMode_Target SASMode = 8
	// Point away from the current target.
	SASMode_AntiTarget SASMode = 9
)

func (v SASMode) Value() int32 {
	return int32(v)
}
func (v *SASMode) SetValue(val int32) {
	*v = SASMode(val)
}

/*
SpeedMode - the mode of the speed reported in the navball. See <see
cref="M:SpaceCenter.Control.SpeedMode" />.
*/
type SpeedMode int32

const (
	// Speed is relative to the vessel's orbit.
	SpeedMode_Orbit SpeedMode = 0
	// Speed is relative to the surface of the body being orbited.
	SpeedMode_Surface SpeedMode = 1
	// Speed is relative to the current target.
	SpeedMode_Target SpeedMode = 2
)

func (v SpeedMode) Value() int32 {
	return int32(v)
}
func (v *SpeedMode) SetValue(val int32) {
	*v = SpeedMode(val)
}

/*
SuitType - a crew member's suit type. See <see
cref="M:SpaceCenter.CrewMember.SuitType" />.
*/
type SuitType int32

const (
	// Default.
	SuitType_Default SuitType = 0
	// Vintage.
	SuitType_Vintage SuitType = 1
	// Future.
	SuitType_Future SuitType = 2
	// Slim.
	SuitType_Slim SuitType = 3
)

func (v SuitType) Value() int32 {
	return int32(v)
}
func (v *SuitType) SetValue(val int32) {
	*v = SuitType(val)
}

/*
VesselSituation - the situation a vessel is in. See <see
cref="M:SpaceCenter.Vessel.Situation" />.
*/
type VesselSituation int32

const (
	// Vessel is awaiting launch.
	VesselSituation_PreLaunch VesselSituation = 0
	// Vessel is orbiting a body.
	VesselSituation_Orbiting VesselSituation = 1
	// Vessel is on a sub-orbital trajectory.
	VesselSituation_SubOrbital VesselSituation = 2
	// Escaping.
	VesselSituation_Escaping VesselSituation = 3
	// Vessel is flying through an atmosphere.
	VesselSituation_Flying VesselSituation = 4
	// Vessel is landed on the surface of a body.
	VesselSituation_Landed VesselSituation = 5
	// Vessel has splashed down in an ocean.
	VesselSituation_Splashed VesselSituation = 6
	// Vessel is docked to another.
	VesselSituation_Docked VesselSituation = 7
)

func (v VesselSituation) Value() int32 {
	return int32(v)
}
func (v *VesselSituation) SetValue(val int32) {
	*v = VesselSituation(val)
}

/*
VesselType - the type of a vessel. See <see cref="M:SpaceCenter.Vessel.Type"
/>.
*/
type VesselType int32

const (
	// Base.
	VesselType_Base VesselType = 0
	// Debris.
	VesselType_Debris VesselType = 1
	// Lander.
	VesselType_Lander VesselType = 2
	// Plane.
	VesselType_Plane VesselType = 3
	// Probe.
	VesselType_Probe VesselType = 4
	// Relay.
	VesselType_Relay VesselType = 5
	// Rover.
	VesselType_Rover VesselType = 6
	// Ship.
	VesselType_Ship VesselType = 7
	// Station.
	VesselType_Station VesselType = 8
	// SpaceObject.
	VesselType_SpaceObject VesselType = 9
	// Unknown.
	VesselType_Unknown VesselType = 10
	// EVA.
	VesselType_EVA VesselType = 11
	// Flag.
	VesselType_Flag VesselType = 12
	// DeployedScienceController.
	VesselType_DeployedScienceController VesselType = 13
	// DeploedSciencePart.
	VesselType_DeployedSciencePart VesselType = 14
	// DroppedPart.
	VesselType_DroppedPart VesselType = 15
	// DeployedGroundPart.
	VesselType_DeployedGroundPart VesselType = 16
)

func (v VesselType) Value() int32 {
	return int32(v)
}
func (v *VesselType) SetValue(val int32) {
	*v = VesselType(val)
}

/*
WarpMode - the time warp mode. Returned by <see cref="T:SpaceCenter.WarpMode"
/>
*/
type WarpMode int32

const (
	// Time warp is active, and in regular "on-rails" mode.
	WarpMode_Rails WarpMode = 0
	// Time warp is active, and in physical time warp mode.
	WarpMode_Physics WarpMode = 1
	// Time warp is not active.
	WarpMode_None WarpMode = 2
)

func (v WarpMode) Value() int32 {
	return int32(v)
}
func (v *WarpMode) SetValue(val int32) {
	*v = WarpMode(val)
}

// Alarm - an alarm. Can be accessed using <see
// cref="M:SpaceCenter.AlarmManager" />.
type Alarm struct {
	service.BaseClass
}

// NewAlarm creates a new Alarm.
func NewAlarm(id uint64, client *krpcgo.KRPCClient) *Alarm {
	c := &Alarm{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// AlarmManager - alarm manager. Obtained by calling <see
// cref="M:SpaceCenter.AlarmManager" />.
type AlarmManager struct {
	service.BaseClass
}

// NewAlarmManager creates a new AlarmManager.
func NewAlarmManager(id uint64, client *krpcgo.KRPCClient) *AlarmManager {
	c := &AlarmManager{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// AutoPilot - provides basic auto-piloting utilities for a vessel. Created by
// calling <see cref="M:SpaceCenter.Vessel.AutoPilot" />.
type AutoPilot struct {
	service.BaseClass
}

// NewAutoPilot creates a new AutoPilot.
func NewAutoPilot(id uint64, client *krpcgo.KRPCClient) *AutoPilot {
	c := &AutoPilot{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Camera - controls the game's camera. Obtained by calling <see
// cref="M:SpaceCenter.Camera" />.
type Camera struct {
	service.BaseClass
}

// NewCamera creates a new Camera.
func NewCamera(id uint64, client *krpcgo.KRPCClient) *Camera {
	c := &Camera{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// CelestialBody - represents a celestial body (such as a planet or moon). See
// <see cref="M:SpaceCenter.Bodies" />.
type CelestialBody struct {
	service.BaseClass
}

// NewCelestialBody creates a new CelestialBody.
func NewCelestialBody(id uint64, client *krpcgo.KRPCClient) *CelestialBody {
	c := &CelestialBody{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// CommLink - represents a communication node in the network. For example, a
// vessel or the KSC.
type CommLink struct {
	service.BaseClass
}

// NewCommLink creates a new CommLink.
func NewCommLink(id uint64, client *krpcgo.KRPCClient) *CommLink {
	c := &CommLink{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// CommNode - represents a communication node in the network. For example, a
// vessel or the KSC.
type CommNode struct {
	service.BaseClass
}

// NewCommNode creates a new CommNode.
func NewCommNode(id uint64, client *krpcgo.KRPCClient) *CommNode {
	c := &CommNode{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Comms - used to interact with CommNet for a given vessel. Obtained by calling
// <see cref="M:SpaceCenter.Vessel.Comms" />.
type Comms struct {
	service.BaseClass
}

// NewComms creates a new Comms.
func NewComms(id uint64, client *krpcgo.KRPCClient) *Comms {
	c := &Comms{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Contract - a contract. Can be accessed using <see
// cref="M:SpaceCenter.ContractManager" />.
type Contract struct {
	service.BaseClass
}

// NewContract creates a new Contract.
func NewContract(id uint64, client *krpcgo.KRPCClient) *Contract {
	c := &Contract{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ContractManager - contracts manager. Obtained by calling <see
// cref="M:SpaceCenter.ContractManager" />.
type ContractManager struct {
	service.BaseClass
}

// NewContractManager creates a new ContractManager.
func NewContractManager(id uint64, client *krpcgo.KRPCClient) *ContractManager {
	c := &ContractManager{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ContractParameter - a contract parameter. See <see
// cref="M:SpaceCenter.Contract.Parameters" />.
type ContractParameter struct {
	service.BaseClass
}

// NewContractParameter creates a new ContractParameter.
func NewContractParameter(id uint64, client *krpcgo.KRPCClient) *ContractParameter {
	c := &ContractParameter{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Control - used to manipulate the controls of a vessel. This includes
// adjusting the throttle, enabling/disabling systems such as SAS and RCS, or
// altering the direction in which the vessel is pointing. Obtained by calling
// <see cref="M:SpaceCenter.Vessel.Control" />.
type Control struct {
	service.BaseClass
}

// NewControl creates a new Control.
func NewControl(id uint64, client *krpcgo.KRPCClient) *Control {
	c := &Control{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// CrewMember - represents crew in a vessel. Can be obtained using <see
// cref="M:SpaceCenter.Vessel.Crew" />.
type CrewMember struct {
	service.BaseClass
}

// NewCrewMember creates a new CrewMember.
func NewCrewMember(id uint64, client *krpcgo.KRPCClient) *CrewMember {
	c := &CrewMember{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Flight - used to get flight telemetry for a vessel, by calling <see
// cref="M:SpaceCenter.Vessel.Flight" />. All of the information returned by
// this class is given in the reference frame passed to that method. Obtained by
// calling <see cref="M:SpaceCenter.Vessel.Flight" />.
type Flight struct {
	service.BaseClass
}

// NewFlight creates a new Flight.
func NewFlight(id uint64, client *krpcgo.KRPCClient) *Flight {
	c := &Flight{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// LaunchSite - a place where craft can be launched from. More of these can be
// added with mods like Kerbal Konstructs.
type LaunchSite struct {
	service.BaseClass
}

// NewLaunchSite creates a new LaunchSite.
func NewLaunchSite(id uint64, client *krpcgo.KRPCClient) *LaunchSite {
	c := &LaunchSite{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Node - represents a maneuver node. Can be created using <see
// cref="M:SpaceCenter.Control.AddNode" />.
type Node struct {
	service.BaseClass
}

// NewNode creates a new Node.
func NewNode(id uint64, client *krpcgo.KRPCClient) *Node {
	c := &Node{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Orbit - describes an orbit. For example, the orbit of a vessel, obtained by
// calling <see cref="M:SpaceCenter.Vessel.Orbit" />, or a celestial body,
// obtained by calling <see cref="M:SpaceCenter.CelestialBody.Orbit" />.
type Orbit struct {
	service.BaseClass
}

// NewOrbit creates a new Orbit.
func NewOrbit(id uint64, client *krpcgo.KRPCClient) *Orbit {
	c := &Orbit{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Antenna - an antenna. Obtained by calling <see
// cref="M:SpaceCenter.Part.Antenna" />.
type Antenna struct {
	service.BaseClass
}

// NewAntenna creates a new Antenna.
func NewAntenna(id uint64, client *krpcgo.KRPCClient) *Antenna {
	c := &Antenna{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// CargoBay - a cargo bay. Obtained by calling <see
// cref="M:SpaceCenter.Part.CargoBay" />.
type CargoBay struct {
	service.BaseClass
}

// NewCargoBay creates a new CargoBay.
func NewCargoBay(id uint64, client *krpcgo.KRPCClient) *CargoBay {
	c := &CargoBay{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ControlSurface - an aerodynamic control surface. Obtained by calling <see
// cref="M:SpaceCenter.Part.ControlSurface" />.
type ControlSurface struct {
	service.BaseClass
}

// NewControlSurface creates a new ControlSurface.
func NewControlSurface(id uint64, client *krpcgo.KRPCClient) *ControlSurface {
	c := &ControlSurface{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Decoupler - a decoupler. Obtained by calling <see
// cref="M:SpaceCenter.Part.Decoupler" />
type Decoupler struct {
	service.BaseClass
}

// NewDecoupler creates a new Decoupler.
func NewDecoupler(id uint64, client *krpcgo.KRPCClient) *Decoupler {
	c := &Decoupler{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// DockingPort - a docking port. Obtained by calling <see
// cref="M:SpaceCenter.Part.DockingPort" />
type DockingPort struct {
	service.BaseClass
}

// NewDockingPort creates a new DockingPort.
func NewDockingPort(id uint64, client *krpcgo.KRPCClient) *DockingPort {
	c := &DockingPort{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Engine - an engine, including ones of various types. For example liquid
// fuelled gimballed engines, solid rocket boosters and jet engines. Obtained by
// calling <see cref="M:SpaceCenter.Part.Engine" />.
type Engine struct {
	service.BaseClass
}

// NewEngine creates a new Engine.
func NewEngine(id uint64, client *krpcgo.KRPCClient) *Engine {
	c := &Engine{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Experiment - obtained by calling <see cref="M:SpaceCenter.Part.Experiment"
// />.
type Experiment struct {
	service.BaseClass
}

// NewExperiment creates a new Experiment.
func NewExperiment(id uint64, client *krpcgo.KRPCClient) *Experiment {
	c := &Experiment{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Fairing - a fairing. Obtained by calling <see
// cref="M:SpaceCenter.Part.Fairing" />. Supports both stock fairings, and those
// from the ProceduralFairings mod.
type Fairing struct {
	service.BaseClass
}

// NewFairing creates a new Fairing.
func NewFairing(id uint64, client *krpcgo.KRPCClient) *Fairing {
	c := &Fairing{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Force - obtained by calling <see cref="M:SpaceCenter.Part.AddForce" />.
type Force struct {
	service.BaseClass
}

// NewForce creates a new Force.
func NewForce(id uint64, client *krpcgo.KRPCClient) *Force {
	c := &Force{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Intake - an air intake. Obtained by calling <see
// cref="M:SpaceCenter.Part.Intake" />.
type Intake struct {
	service.BaseClass
}

// NewIntake creates a new Intake.
func NewIntake(id uint64, client *krpcgo.KRPCClient) *Intake {
	c := &Intake{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// LaunchClamp - a launch clamp. Obtained by calling <see
// cref="M:SpaceCenter.Part.LaunchClamp" />.
type LaunchClamp struct {
	service.BaseClass
}

// NewLaunchClamp creates a new LaunchClamp.
func NewLaunchClamp(id uint64, client *krpcgo.KRPCClient) *LaunchClamp {
	c := &LaunchClamp{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Leg - a landing leg. Obtained by calling <see cref="M:SpaceCenter.Part.Leg"
// />.
type Leg struct {
	service.BaseClass
}

// NewLeg creates a new Leg.
func NewLeg(id uint64, client *krpcgo.KRPCClient) *Leg {
	c := &Leg{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Light - a light. Obtained by calling <see cref="M:SpaceCenter.Part.Light" />.
type Light struct {
	service.BaseClass
}

// NewLight creates a new Light.
func NewLight(id uint64, client *krpcgo.KRPCClient) *Light {
	c := &Light{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Module - this can be used to interact with a specific part module. This
// includes part modules in stock KSP, and those added by mods.  In KSP, each
// part has zero or more <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation#MODULES">PartModules</a>
// associated with it. Each one contains some of the functionality of the part.
// For example, an engine has a "ModuleEngines" part module that contains all
// the functionality of an engine.
type Module struct {
	service.BaseClass
}

// NewModule creates a new Module.
func NewModule(id uint64, client *krpcgo.KRPCClient) *Module {
	c := &Module{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Parachute - a parachute. Obtained by calling <see
// cref="M:SpaceCenter.Part.Parachute" />.
type Parachute struct {
	service.BaseClass
}

// NewParachute creates a new Parachute.
func NewParachute(id uint64, client *krpcgo.KRPCClient) *Parachute {
	c := &Parachute{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Part - represents an individual part. Vessels are made up of multiple parts.
// Instances of this class can be obtained by several methods in <see
// cref="T:SpaceCenter.Parts" />.
type Part struct {
	service.BaseClass
}

// NewPart creates a new Part.
func NewPart(id uint64, client *krpcgo.KRPCClient) *Part {
	c := &Part{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Parts - instances of this class are used to interact with the parts of a
// vessel. An instance can be obtained by calling <see
// cref="M:SpaceCenter.Vessel.Parts" />.
type Parts struct {
	service.BaseClass
}

// NewParts creates a new Parts.
func NewParts(id uint64, client *krpcgo.KRPCClient) *Parts {
	c := &Parts{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Propellant - a propellant for an engine. Obtains by calling <see
// cref="M:SpaceCenter.Engine.Propellants" />.
type Propellant struct {
	service.BaseClass
}

// NewPropellant creates a new Propellant.
func NewPropellant(id uint64, client *krpcgo.KRPCClient) *Propellant {
	c := &Propellant{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// RCS - an RCS block or thruster. Obtained by calling <see
// cref="M:SpaceCenter.Part.RCS" />.
type RCS struct {
	service.BaseClass
}

// NewRCS creates a new RCS.
func NewRCS(id uint64, client *krpcgo.KRPCClient) *RCS {
	c := &RCS{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Radiator - a radiator. Obtained by calling <see
// cref="M:SpaceCenter.Part.Radiator" />.
type Radiator struct {
	service.BaseClass
}

// NewRadiator creates a new Radiator.
func NewRadiator(id uint64, client *krpcgo.KRPCClient) *Radiator {
	c := &Radiator{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ReactionWheel - a reaction wheel. Obtained by calling <see
// cref="M:SpaceCenter.Part.ReactionWheel" />.
type ReactionWheel struct {
	service.BaseClass
}

// NewReactionWheel creates a new ReactionWheel.
func NewReactionWheel(id uint64, client *krpcgo.KRPCClient) *ReactionWheel {
	c := &ReactionWheel{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ResourceConverter - a resource converter. Obtained by calling <see
// cref="M:SpaceCenter.Part.ResourceConverter" />.
type ResourceConverter struct {
	service.BaseClass
}

// NewResourceConverter creates a new ResourceConverter.
func NewResourceConverter(id uint64, client *krpcgo.KRPCClient) *ResourceConverter {
	c := &ResourceConverter{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ResourceDrain - a resource drain. Obtained by calling <see
// cref="M:SpaceCenter.Part.ResourceDrain" />.
type ResourceDrain struct {
	service.BaseClass
}

// NewResourceDrain creates a new ResourceDrain.
func NewResourceDrain(id uint64, client *krpcgo.KRPCClient) *ResourceDrain {
	c := &ResourceDrain{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ResourceHarvester - a resource harvester (drill). Obtained by calling <see
// cref="M:SpaceCenter.Part.ResourceHarvester" />.
type ResourceHarvester struct {
	service.BaseClass
}

// NewResourceHarvester creates a new ResourceHarvester.
func NewResourceHarvester(id uint64, client *krpcgo.KRPCClient) *ResourceHarvester {
	c := &ResourceHarvester{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// RoboticController - a robotic controller. Obtained by calling <see
// cref="M:SpaceCenter.Part.RoboticController" />.
type RoboticController struct {
	service.BaseClass
}

// NewRoboticController creates a new RoboticController.
func NewRoboticController(id uint64, client *krpcgo.KRPCClient) *RoboticController {
	c := &RoboticController{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// RoboticHinge - a robotic hinge. Obtained by calling <see
// cref="M:SpaceCenter.Part.RoboticHinge" />.
type RoboticHinge struct {
	service.BaseClass
}

// NewRoboticHinge creates a new RoboticHinge.
func NewRoboticHinge(id uint64, client *krpcgo.KRPCClient) *RoboticHinge {
	c := &RoboticHinge{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// RoboticPiston - a robotic piston part. Obtained by calling <see
// cref="M:SpaceCenter.Part.RoboticPiston" />.
type RoboticPiston struct {
	service.BaseClass
}

// NewRoboticPiston creates a new RoboticPiston.
func NewRoboticPiston(id uint64, client *krpcgo.KRPCClient) *RoboticPiston {
	c := &RoboticPiston{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// RoboticRotation - a robotic rotation servo. Obtained by calling <see
// cref="M:SpaceCenter.Part.RoboticRotation" />.
type RoboticRotation struct {
	service.BaseClass
}

// NewRoboticRotation creates a new RoboticRotation.
func NewRoboticRotation(id uint64, client *krpcgo.KRPCClient) *RoboticRotation {
	c := &RoboticRotation{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// RoboticRotor - a robotic rotor. Obtained by calling <see
// cref="M:SpaceCenter.Part.RoboticRotor" />.
type RoboticRotor struct {
	service.BaseClass
}

// NewRoboticRotor creates a new RoboticRotor.
func NewRoboticRotor(id uint64, client *krpcgo.KRPCClient) *RoboticRotor {
	c := &RoboticRotor{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ScienceData - obtained by calling <see cref="M:SpaceCenter.Experiment.Data"
// />.
type ScienceData struct {
	service.BaseClass
}

// NewScienceData creates a new ScienceData.
func NewScienceData(id uint64, client *krpcgo.KRPCClient) *ScienceData {
	c := &ScienceData{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ScienceSubject - obtained by calling <see
// cref="M:SpaceCenter.Experiment.ScienceSubject" />.
type ScienceSubject struct {
	service.BaseClass
}

// NewScienceSubject creates a new ScienceSubject.
func NewScienceSubject(id uint64, client *krpcgo.KRPCClient) *ScienceSubject {
	c := &ScienceSubject{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Sensor - a sensor, such as a thermometer. Obtained by calling <see
// cref="M:SpaceCenter.Part.Sensor" />.
type Sensor struct {
	service.BaseClass
}

// NewSensor creates a new Sensor.
func NewSensor(id uint64, client *krpcgo.KRPCClient) *Sensor {
	c := &Sensor{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// SolarPanel - a solar panel. Obtained by calling <see
// cref="M:SpaceCenter.Part.SolarPanel" />.
type SolarPanel struct {
	service.BaseClass
}

// NewSolarPanel creates a new SolarPanel.
func NewSolarPanel(id uint64, client *krpcgo.KRPCClient) *SolarPanel {
	c := &SolarPanel{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Thruster - the component of an <see cref="T:SpaceCenter.Engine" /> or <see
// cref="T:SpaceCenter.RCS" /> part that generates thrust. Can obtained by
// calling <see cref="M:SpaceCenter.Engine.Thrusters" /> or <see
// cref="M:SpaceCenter.RCS.Thrusters" />.
type Thruster struct {
	service.BaseClass
}

// NewThruster creates a new Thruster.
func NewThruster(id uint64, client *krpcgo.KRPCClient) *Thruster {
	c := &Thruster{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Wheel - a wheel. Includes landing gear and rover wheels. Obtained by calling
// <see cref="M:SpaceCenter.Part.Wheel" />. Can be used to control the motors,
// steering and deployment of wheels, among other things.
type Wheel struct {
	service.BaseClass
}

// NewWheel creates a new Wheel.
func NewWheel(id uint64, client *krpcgo.KRPCClient) *Wheel {
	c := &Wheel{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ReferenceFrame - represents a reference frame for positions, rotations and
// velocities. Contains: <list type="bullet"><item><description>The position of
// the origin.</description></item><item><description>The directions of the x, y
// and z axes.</description></item><item><description>The linear velocity of the
// frame.</description></item><item><description>The angular velocity of the
// frame.</description></item></list>
type ReferenceFrame struct {
	service.BaseClass
}

// NewReferenceFrame creates a new ReferenceFrame.
func NewReferenceFrame(id uint64, client *krpcgo.KRPCClient) *ReferenceFrame {
	c := &ReferenceFrame{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Resource - an individual resource stored within a part. Created using methods
// in the <see cref="T:SpaceCenter.Resources" /> class.
type Resource struct {
	service.BaseClass
}

// NewResource creates a new Resource.
func NewResource(id uint64, client *krpcgo.KRPCClient) *Resource {
	c := &Resource{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// ResourceTransfer - transfer resources between parts.
type ResourceTransfer struct {
	service.BaseClass
}

// NewResourceTransfer creates a new ResourceTransfer.
func NewResourceTransfer(id uint64, client *krpcgo.KRPCClient) *ResourceTransfer {
	c := &ResourceTransfer{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Resources - represents the collection of resources stored in a vessel, stage
// or part. Created by calling <see cref="M:SpaceCenter.Vessel.Resources" />,
// <see cref="M:SpaceCenter.Vessel.ResourcesInDecoupleStage" /> or <see
// cref="M:SpaceCenter.Part.Resources" />.
type Resources struct {
	service.BaseClass
}

// NewResources creates a new Resources.
func NewResources(id uint64, client *krpcgo.KRPCClient) *Resources {
	c := &Resources{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Vessel - these objects are used to interact with vessels in KSP. This
// includes getting orbital and flight data, manipulating control inputs and
// managing resources. Created using <see cref="M:SpaceCenter.ActiveVessel" />
// or <see cref="M:SpaceCenter.Vessels" />.
type Vessel struct {
	service.BaseClass
}

// NewVessel creates a new Vessel.
func NewVessel(id uint64, client *krpcgo.KRPCClient) *Vessel {
	c := &Vessel{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// Waypoint - represents a waypoint. Can be created using <see
// cref="M:SpaceCenter.WaypointManager.AddWaypoint" />.
type Waypoint struct {
	service.BaseClass
}

// NewWaypoint creates a new Waypoint.
func NewWaypoint(id uint64, client *krpcgo.KRPCClient) *Waypoint {
	c := &Waypoint{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// WaypointManager - waypoints are the location markers you can see on the map
// view showing you where contracts are targeted for. With this structure, you
// can obtain coordinate data for the locations of these waypoints. Obtained by
// calling <see cref="M:SpaceCenter.WaypointManager" />.
type WaypointManager struct {
	service.BaseClass
}

// NewWaypointManager creates a new WaypointManager.
func NewWaypointManager(id uint64, client *krpcgo.KRPCClient) *WaypointManager {
	c := &WaypointManager{BaseClass: service.BaseClass{Client: client}}
	c.SetID_internal(id)
	return c
}

// SpaceCenter - provides functionality to interact with Kerbal Space Program.
// This includes controlling the active vessel, managing its resources, planning
// maneuver nodes and auto-piloting.
type SpaceCenter struct {
	Client *krpcgo.KRPCClient
}

// New creates a new SpaceCenter.
func New(client *krpcgo.KRPCClient) *SpaceCenter {
	return &SpaceCenter{Client: client}
}

// ClearTarget - clears the current target.
//
// Allowed game scenes: any.
func (s *SpaceCenter) ClearTarget() error {
	var err error
	request := &types.ProcedureCall{
		Procedure: "ClearTarget",
		Service:   "SpaceCenter",
	}
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LaunchableVessels - returns a list of vessels from the given <paramref
// name="craftDirectory" /> that can be launched.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchableVessels(craftDirectory string) ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "LaunchableVessels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(craftDirectory)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LaunchableVesselsStream - returns a list of vessels from the given <paramref
// name="craftDirectory" /> that can be launched.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchableVesselsStream(craftDirectory string) (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "LaunchableVessels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(craftDirectory)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// LaunchVessel - launch a vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchVessel(craftDirectory string, name string, launchSite string, recover bool, crew []string, flagUrl string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "LaunchVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(craftDirectory)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(launchSite)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(recover)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(crew)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(flagUrl)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x5),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LaunchVesselFromVAB - launch a new vessel from the VAB onto the launchpad.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchVesselFromVAB(name string, recover bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "LaunchVesselFromVAB",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(recover)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// LaunchVesselFromSPH - launch a new vessel from the SPH onto the runway.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchVesselFromSPH(name string, recover bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "LaunchVesselFromSPH",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(recover)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Save - save the game with a given name. This will create a save file called
// name.sfs in the folder of the current save game.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Save(name string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Save",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Load - load the game with the given name. This will create a load a save file
// called name.sfs from the folder of the current save game.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Load(name string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Load",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Quicksave - save a quicksave.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Quicksave() error {
	var err error
	request := &types.ProcedureCall{
		Procedure: "Quicksave",
		Service:   "SpaceCenter",
	}
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Quickload - load a quicksave.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Quickload() error {
	var err error
	request := &types.ProcedureCall{
		Procedure: "Quickload",
		Service:   "SpaceCenter",
	}
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CanRevertToLaunch - whether the current flight can be reverted to launch.
//
// Allowed game scenes: any.
func (s *SpaceCenter) CanRevertToLaunch() (bool, error) {
	var err error
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CanRevertToLaunch",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanRevertToLaunchStream - whether the current flight can be reverted to
// launch.
//
// Allowed game scenes: any.
func (s *SpaceCenter) CanRevertToLaunchStream() (*krpcgo.Stream[bool], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "CanRevertToLaunch",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RevertToLaunch - revert the current flight to launch.
//
// Allowed game scenes: any.
func (s *SpaceCenter) RevertToLaunch() error {
	var err error
	request := &types.ProcedureCall{
		Procedure: "RevertToLaunch",
		Service:   "SpaceCenter",
	}
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TransferCrew - transfers a crew member to a different part.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransferCrew(crewMember *CrewMember, targetPart *Part) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "TransferCrew",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(crewMember)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(targetPart)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CanRailsWarpAt - returns true if regular "on-rails" time warp can be used, at
// the specified warp <paramref name="factor" />. The maximum time warp rate is
// limited by various things, including how close the active vessel is to a
// planet. See <a href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the
// KSP wiki</a> for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) CanRailsWarpAt(factor int32) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CanRailsWarpAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(factor)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanRailsWarpAtStream - returns true if regular "on-rails" time warp can be
// used, at the specified warp <paramref name="factor" />. The maximum time warp
// rate is limited by various things, including how close the active vessel is
// to a planet. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) CanRailsWarpAtStream(factor int32) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CanRailsWarpAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(factor)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// WarpTo - uses time acceleration to warp forward to a time in the future,
// specified by universal time <paramref name="ut" />. This call blocks until
// the desired time is reached. Uses regular "on-rails" or physical time warp as
// appropriate. For example, physical time warp is used when the active vessel
// is traveling through an atmosphere. When using regular "on-rails" time warp,
// the warp rate is limited by <paramref name="maxRailsRate" />, and when using
// physical time warp, the warp rate is limited by <paramref
// name="maxPhysicsRate" />.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpTo(ut float64, maxRailsRate float32, maxPhysicsRate float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "WarpTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(maxRailsRate)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(maxPhysicsRate)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TransformPosition - converts a position from one reference frame to another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformPosition(position types.Tuple3[float64, float64, float64], from *ReferenceFrame, to *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "TransformPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TransformPositionStream - converts a position from one reference frame to
// another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformPositionStream(position types.Tuple3[float64, float64, float64], from *ReferenceFrame, to *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "TransformPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TransformDirection - converts a direction from one reference frame to
// another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformDirection(direction types.Tuple3[float64, float64, float64], from *ReferenceFrame, to *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "TransformDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TransformDirectionStream - converts a direction from one reference frame to
// another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformDirectionStream(direction types.Tuple3[float64, float64, float64], from *ReferenceFrame, to *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "TransformDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TransformRotation - converts a rotation from one reference frame to another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformRotation(rotation types.Tuple4[float64, float64, float64, float64], from *ReferenceFrame, to *ReferenceFrame) (types.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple4[float64, float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "TransformRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TransformRotationStream - converts a rotation from one reference frame to
// another.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformRotationStream(rotation types.Tuple4[float64, float64, float64, float64], from *ReferenceFrame, to *ReferenceFrame) (*krpcgo.Stream[types.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "TransformRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple4[float64, float64, float64, float64] {
		var value types.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TransformVelocity - converts a velocity (acting at the specified position)
// from one reference frame to another. The position is required to take the
// relative angular velocity of the reference frames into account.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformVelocity(position types.Tuple3[float64, float64, float64], velocity types.Tuple3[float64, float64, float64], from *ReferenceFrame, to *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "TransformVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TransformVelocityStream - converts a velocity (acting at the specified
// position) from one reference frame to another. The position is required to
// take the relative angular velocity of the reference frames into account.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TransformVelocityStream(position types.Tuple3[float64, float64, float64], velocity types.Tuple3[float64, float64, float64], from *ReferenceFrame, to *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "TransformVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(from)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(to)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RaycastDistance - cast a ray from a given position in a given direction, and
// return the distance to the hit point. If no hit occurs, returns infinity.
//
// Allowed game scenes: any.
func (s *SpaceCenter) RaycastDistance(position types.Tuple3[float64, float64, float64], direction types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "RaycastDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RaycastDistanceStream - cast a ray from a given position in a given
// direction, and return the distance to the hit point. If no hit occurs,
// returns infinity.
//
// Allowed game scenes: any.
func (s *SpaceCenter) RaycastDistanceStream(position types.Tuple3[float64, float64, float64], direction types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RaycastDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RaycastPart - cast a ray from a given position in a given direction, and
// return the part that it hits. If no hit occurs, returns nil.
//
// Allowed game scenes: any.
func (s *SpaceCenter) RaycastPart(position types.Tuple3[float64, float64, float64], direction types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "RaycastPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(direction)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// CreateKerbal - creates a Kerbal.
//
// Allowed game scenes: any.
func (s *SpaceCenter) CreateKerbal(name string, job string, male bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CreateKerbal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(job)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(male)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// GetKerbal - find a Kerbal by name.
//
// Allowed game scenes: any.
func (s *SpaceCenter) GetKerbal(name string) (*CrewMember, error) {
	var err error
	var argBytes []byte
	var vv CrewMember
	request := &types.ProcedureCall{
		Procedure: "GetKerbal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// LoadSpaceCenter - switch to the space center view.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LoadSpaceCenter() error {
	var err error
	request := &types.ProcedureCall{
		Procedure: "LoadSpaceCenter",
		Service:   "SpaceCenter",
	}
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Screenshot - saves a screenshot.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Screenshot(filePath string, scale int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Screenshot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(filePath)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(scale)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// GameMode - the current mode the game is in.
//
// Allowed game scenes: any.
func (s *SpaceCenter) GameMode() (GameMode, error) {
	var err error
	var vv GameMode
	request := &types.ProcedureCall{
		Procedure: "get_GameMode",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GameModeStream - the current mode the game is in.
//
// Allowed game scenes: any.
func (s *SpaceCenter) GameModeStream() (*krpcgo.Stream[GameMode], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_GameMode",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) GameMode {
		var value GameMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Science - the current amount of science.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Science() (float32, error) {
	var err error
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "get_Science",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ScienceStream - the current amount of science.
//
// Allowed game scenes: any.
func (s *SpaceCenter) ScienceStream() (*krpcgo.Stream[float32], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Science",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Funds - the current amount of funds.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Funds() (float64, error) {
	var err error
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "get_Funds",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FundsStream - the current amount of funds.
//
// Allowed game scenes: any.
func (s *SpaceCenter) FundsStream() (*krpcgo.Stream[float64], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Funds",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Reputation - the current amount of reputation.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Reputation() (float32, error) {
	var err error
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "get_Reputation",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReputationStream - the current amount of reputation.
//
// Allowed game scenes: any.
func (s *SpaceCenter) ReputationStream() (*krpcgo.Stream[float32], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Reputation",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ActiveVessel - the currently active vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) ActiveVessel() (*Vessel, error) {
	var err error
	var vv Vessel
	request := &types.ProcedureCall{
		Procedure: "get_ActiveVessel",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetActiveVessel - the currently active vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetActiveVessel(value *Vessel) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "set_ActiveVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Vessels - a list of all the vessels in the game.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Vessels() ([]*Vessel, error) {
	var err error
	var vv []*Vessel
	request := &types.ProcedureCall{
		Procedure: "get_Vessels",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// VesselsStream - a list of all the vessels in the game.
//
// Allowed game scenes: any.
func (s *SpaceCenter) VesselsStream() (*krpcgo.Stream[[]*Vessel], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Vessels",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Vessel {
		var value []*Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// LaunchSites - a list of available launch sites.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchSites() ([]*LaunchSite, error) {
	var err error
	var vv []*LaunchSite
	request := &types.ProcedureCall{
		Procedure: "get_LaunchSites",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// LaunchSitesStream - a list of available launch sites.
//
// Allowed game scenes: any.
func (s *SpaceCenter) LaunchSitesStream() (*krpcgo.Stream[[]*LaunchSite], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_LaunchSites",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*LaunchSite {
		var value []*LaunchSite
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Bodies - a dictionary of all celestial bodies (planets, moons, etc.) in the
// game, keyed by the name of the body.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Bodies() (map[string]*CelestialBody, error) {
	var err error
	var vv map[string]*CelestialBody
	request := &types.ProcedureCall{
		Procedure: "get_Bodies",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BodiesStream - a dictionary of all celestial bodies (planets, moons, etc.) in
// the game, keyed by the name of the body.
//
// Allowed game scenes: any.
func (s *SpaceCenter) BodiesStream() (*krpcgo.Stream[map[string]*CelestialBody], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Bodies",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) map[string]*CelestialBody {
		var value map[string]*CelestialBody
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TargetBody - the currently targeted celestial body.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TargetBody() (*CelestialBody, error) {
	var err error
	var vv CelestialBody
	request := &types.ProcedureCall{
		Procedure: "get_TargetBody",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetTargetBody - the currently targeted celestial body.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetTargetBody(value *CelestialBody) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "set_TargetBody",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetVessel - the currently targeted vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TargetVessel() (*Vessel, error) {
	var err error
	var vv Vessel
	request := &types.ProcedureCall{
		Procedure: "get_TargetVessel",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetTargetVessel - the currently targeted vessel.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetTargetVessel(value *Vessel) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "set_TargetVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetDockingPort - the currently targeted docking port.
//
// Allowed game scenes: any.
func (s *SpaceCenter) TargetDockingPort() (*DockingPort, error) {
	var err error
	var vv DockingPort
	request := &types.ProcedureCall{
		Procedure: "get_TargetDockingPort",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetTargetDockingPort - the currently targeted docking port.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetTargetDockingPort(value *DockingPort) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "set_TargetDockingPort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// WaypointManager - the waypoint manager.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WaypointManager() (*WaypointManager, error) {
	var err error
	var vv WaypointManager
	request := &types.ProcedureCall{
		Procedure: "get_WaypointManager",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ContractManager - the contract manager.
//
// Allowed game scenes: any.
func (s *SpaceCenter) ContractManager() (*ContractManager, error) {
	var err error
	var vv ContractManager
	request := &types.ProcedureCall{
		Procedure: "get_ContractManager",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AlarmManager - the alarm manager.
//
// Allowed game scenes: any.
func (s *SpaceCenter) AlarmManager() (*AlarmManager, error) {
	var err error
	var vv AlarmManager
	request := &types.ProcedureCall{
		Procedure: "get_AlarmManager",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Camera - an object that can be used to control the camera.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Camera() (*Camera, error) {
	var err error
	var vv Camera
	request := &types.ProcedureCall{
		Procedure: "get_Camera",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// UIVisible - whether the UI is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) UIVisible() (bool, error) {
	var err error
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "get_UIVisible",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// UIVisibleStream - whether the UI is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) UIVisibleStream() (*krpcgo.Stream[bool], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_UIVisible",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetUIVisible - whether the UI is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetUIVisible(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "set_UIVisible",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Navball - whether the navball is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) Navball() (bool, error) {
	var err error
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "get_Navball",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NavballStream - whether the navball is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) NavballStream() (*krpcgo.Stream[bool], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_Navball",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetNavball - whether the navball is visible.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetNavball(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "set_Navball",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// UT - the current universal time in seconds.
//
// Allowed game scenes: any.
func (s *SpaceCenter) UT() (float64, error) {
	var err error
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "get_UT",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// UTStream - the current universal time in seconds.
//
// Allowed game scenes: any.
func (s *SpaceCenter) UTStream() (*krpcgo.Stream[float64], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_UT",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// G - the value of the <a
// href="https://en.wikipedia.org/wiki/Gravitational_constant"> gravitational
// constant</a> G in <math>N(m/kg)^2</math>.
//
// Allowed game scenes: any.
func (s *SpaceCenter) G() (float64, error) {
	var err error
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "get_G",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GStream - the value of the <a
// href="https://en.wikipedia.org/wiki/GStreamravitational_constant">
// gravitational constant</a> GStream in <math>N(m/kg)^2</math>.
//
// Allowed game scenes: any.
func (s *SpaceCenter) GStream() (*krpcgo.Stream[float64], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_G",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// WarpMode - the current time warp mode. Returns <see
// cref="M:SpaceCenter.WarpMode.None" /> if time warp is not active, <see
// cref="M:SpaceCenter.WarpMode.Rails" /> if regular "on-rails" time warp is
// active, or <see cref="M:SpaceCenter.WarpMode.Physics" /> if physical time
// warp is active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpMode() (WarpMode, error) {
	var err error
	var vv WarpMode
	request := &types.ProcedureCall{
		Procedure: "get_WarpMode",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// WarpModeStream - the current time warp mode. Returns <see
// cref="M:SpaceCenter.WarpModeStream.None" /> if time warp is not active, <see
// cref="M:SpaceCenter.WarpModeStream.Rails" /> if regular "on-rails" time warp
// is active, or <see cref="M:SpaceCenter.WarpModeStream.Physics" /> if physical
// time warp is active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpModeStream() (*krpcgo.Stream[WarpMode], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_WarpMode",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) WarpMode {
		var value WarpMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// WarpRate - the current warp rate. This is the rate at which time is passing
// for either on-rails or physical time warp. For example, a value of 10 means
// time is passing 10x faster than normal. Returns 1 if time warp is not active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpRate() (float32, error) {
	var err error
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "get_WarpRate",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// WarpRateStream - the current warp rate. This is the rate at which time is
// passing for either on-rails or physical time warp. For example, a value of 10
// means time is passing 10x faster than normal. Returns 1 if time warp is not
// active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpRateStream() (*krpcgo.Stream[float32], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_WarpRate",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// WarpFactor - the current warp factor. This is the index of the rate at which
// time is passing for either regular "on-rails" or physical time warp. Returns
// 0 if time warp is not active. When in on-rails time warp, this is equal to
// <see cref="M:SpaceCenter.RailsWarpFactor" />, and in physics time warp, this
// is equal to <see cref="M:SpaceCenter.PhysicsWarpFactor" />.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpFactor() (float32, error) {
	var err error
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "get_WarpFactor",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// WarpFactorStream - the current warp factor. This is the index of the rate at
// which time is passing for either regular "on-rails" or physical time warp.
// Returns 0 if time warp is not active. When in on-rails time warp, this is
// equal to <see cref="M:SpaceCenter.RailsWarpFactorStream" />, and in physics
// time warp, this is equal to <see cref="M:SpaceCenter.PhysicsWarpFactorStream"
// />.
//
// Allowed game scenes: any.
func (s *SpaceCenter) WarpFactorStream() (*krpcgo.Stream[float32], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_WarpFactor",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RailsWarpFactor - the time warp rate, using regular "on-rails" time warp. A
// value between 0 and 7 inclusive. 0 means no time warp. Returns 0 if physical
// time warp is active.  If requested time warp factor cannot be set, it will be
// set to the next lowest possible value. For example, if the vessel is too
// close to a planet. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp"> the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) RailsWarpFactor() (int32, error) {
	var err error
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "get_RailsWarpFactor",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RailsWarpFactorStream - the time warp rate, using regular "on-rails" time
// warp. A value between 0 and 7 inclusive. 0 means no time warp. Returns 0 if
// physical time warp is active.  If requested time warp factor cannot be set,
// it will be set to the next lowest possible value. For example, if the vessel
// is too close to a planet. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp"> the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) RailsWarpFactorStream() (*krpcgo.Stream[int32], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_RailsWarpFactor",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRailsWarpFactor - the time warp rate, using regular "on-rails" time warp.
// A value between 0 and 7 inclusive. 0 means no time warp. Returns 0 if
// physical time warp is active.  If requested time warp factor cannot be set,
// it will be set to the next lowest possible value. For example, if the vessel
// is too close to a planet. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp"> the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetRailsWarpFactor(value int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "set_RailsWarpFactor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// PhysicsWarpFactor - the physical time warp rate. A value between 0 and 3
// inclusive. 0 means no time warp. Returns 0 if regular "on-rails" time warp is
// active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) PhysicsWarpFactor() (int32, error) {
	var err error
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "get_PhysicsWarpFactor",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PhysicsWarpFactorStream - the physical time warp rate. A value between 0 and
// 3 inclusive. 0 means no time warp. Returns 0 if regular "on-rails" time warp
// is active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) PhysicsWarpFactorStream() (*krpcgo.Stream[int32], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_PhysicsWarpFactor",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPhysicsWarpFactor - the physical time warp rate. A value between 0 and 3
// inclusive. 0 means no time warp. Returns 0 if regular "on-rails" time warp is
// active.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetPhysicsWarpFactor(value int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "set_PhysicsWarpFactor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MaximumRailsWarpFactor - the current maximum regular "on-rails" warp factor
// that can be set. A value between 0 and 7 inclusive. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) MaximumRailsWarpFactor() (int32, error) {
	var err error
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "get_MaximumRailsWarpFactor",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaximumRailsWarpFactorStream - the current maximum regular "on-rails" warp
// factor that can be set. A value between 0 and 7 inclusive. See <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the KSP wiki</a>
// for details.
//
// Allowed game scenes: any.
func (s *SpaceCenter) MaximumRailsWarpFactorStream() (*krpcgo.Stream[int32], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_MaximumRailsWarpFactor",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FARAvailable - whether <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram
// Aerospace Research</a> is installed.
//
// Allowed game scenes: any.
func (s *SpaceCenter) FARAvailable() (bool, error) {
	var err error
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "get_FARAvailable",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FARAvailableStream - whether <a
// href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram
// Aerospace Research</a> is installed.
//
// Allowed game scenes: any.
func (s *SpaceCenter) FARAvailableStream() (*krpcgo.Stream[bool], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_FARAvailable",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MapFilter - the visible objects in map mode.
//
// Allowed game scenes: any.
func (s *SpaceCenter) MapFilter() (MapFilterType, error) {
	var err error
	var vv MapFilterType
	request := &types.ProcedureCall{
		Procedure: "get_MapFilter",
		Service:   "SpaceCenter",
	}
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MapFilterStream - the visible objects in map mode.
//
// Allowed game scenes: any.
func (s *SpaceCenter) MapFilterStream() (*krpcgo.Stream[MapFilterType], error) {
	var err error
	request := &types.ProcedureCall{
		Procedure: "get_MapFilter",
		Service:   "SpaceCenter",
	}
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) MapFilterType {
		var value MapFilterType
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMapFilter - the visible objects in map mode.
//
// Allowed game scenes: any.
func (s *SpaceCenter) SetMapFilter(value MapFilterType) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "set_MapFilter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ID - unique identifier of the alarm. KSP destroys and recreates an alarm when
// it is edited. This id will remain constant between the old and new alarms.
//
// Allowed game scenes: any.
func (s *Alarm) ID() (uint32, error) {
	var err error
	var argBytes []byte
	var vv uint32
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_ID",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IDStream - unique identifier of the alarm. KSP destroys and recreates an
// alarm when it is edited. This id will remain constant between the old and new
// alarms.
//
// Allowed game scenes: any.
func (s *Alarm) IDStream() (*krpcgo.Stream[uint32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_ID",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) uint32 {
		var value uint32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Type - type of alarm
//
// Allowed game scenes: any.
func (s *Alarm) Type() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TypeStream - type of alarm
//
// Allowed game scenes: any.
func (s *Alarm) TypeStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Title - title of the alarm
//
// Allowed game scenes: any.
func (s *Alarm) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TitleStream - title of the alarm
//
// Allowed game scenes: any.
func (s *Alarm) TitleStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Description - description of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) Description() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Description",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DescriptionStream - description of the alarm.
//
// Allowed game scenes: any.
func (s *Alarm) DescriptionStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Description",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Time - time the alarm will trigger.
//
// Allowed game scenes: any.
func (s *Alarm) Time() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Time",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TimeStream - time the alarm will trigger.
//
// Allowed game scenes: any.
func (s *Alarm) TimeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Time",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TimeUntil - time until the alarm triggers.
//
// Allowed game scenes: any.
func (s *Alarm) TimeUntil() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_TimeUntil",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TimeUntilStream - time until the alarm triggers.
//
// Allowed game scenes: any.
func (s *Alarm) TimeUntilStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_TimeUntil",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// EventOffset - seconds between the alarm going off and the event it
// references.
//
// Allowed game scenes: any.
func (s *Alarm) EventOffset() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_EventOffset",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EventOffsetStream - seconds between the alarm going off and the event it
// references.
//
// Allowed game scenes: any.
func (s *Alarm) EventOffsetStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_EventOffset",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Vessel - vessel the alarm references. nil if it does not reference a vessel.
//
// Allowed game scenes: any.
func (s *Alarm) Vessel() (*Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &types.ProcedureCall{
		Procedure: "Alarm_get_Vessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddAlarm - create an alarm.
//
// Allowed game scenes: any.
func (s *AlarmManager) AddAlarm(title string, description string) (*Alarm, error) {
	var err error
	var argBytes []byte
	var vv Alarm
	request := &types.ProcedureCall{
		Procedure: "AlarmManager_static_AddAlarm",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(description)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddVesselAlarm - create an alarm linked to a vessel.
//
// Allowed game scenes: any.
func (s *AlarmManager) AddVesselAlarm(vessel *Vessel, title string, description string) (*Alarm, error) {
	var err error
	var argBytes []byte
	var vv Alarm
	request := &types.ProcedureCall{
		Procedure: "AlarmManager_static_AddVesselAlarm",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(vessel)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(description)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddApoapsisAlarm - create an alarm for the given vessel's next apoapsis.
//
// Allowed game scenes: any.
func (s *AlarmManager) AddApoapsisAlarm(offset float64, title string, description string) (*Alarm, error) {
	var err error
	var argBytes []byte
	var vv Alarm
	request := &types.ProcedureCall{
		Procedure: "AlarmManager_static_AddApoapsisAlarm",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(offset)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(description)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddPeriapsisAlarm - create an alarm for the given vessel's next periapsis.
//
// Allowed game scenes: any.
func (s *AlarmManager) AddPeriapsisAlarm(offset float64, title string, description string) (*Alarm, error) {
	var err error
	var argBytes []byte
	var vv Alarm
	request := &types.ProcedureCall{
		Procedure: "AlarmManager_static_AddPeriapsisAlarm",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(offset)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(description)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddManeuverNodeAlarm - create an alarm for the given vessel and maneuver
// node.
//
// Allowed game scenes: any.
func (s *AlarmManager) AddManeuverNodeAlarm(node *Node, offset float64, addBurnTime bool, title string, description string) (*Alarm, error) {
	var err error
	var argBytes []byte
	var vv Alarm
	request := &types.ProcedureCall{
		Procedure: "AlarmManager_static_AddManeuverNodeAlarm",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(node)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(offset)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(addBurnTime)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(description)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x5),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddSOIAlarm - create an alarm for the given vessel's next sphere of influence
// change.
//
// Allowed game scenes: any.
func (s *AlarmManager) AddSOIAlarm(offset float64, title string, description string) (*Alarm, error) {
	var err error
	var argBytes []byte
	var vv Alarm
	request := &types.ProcedureCall{
		Procedure: "AlarmManager_static_AddSOIAlarm",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(offset)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(description)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Alarms - a list of all alarms.
//
// Allowed game scenes: any.
func (s *AlarmManager) Alarms() ([]*Alarm, error) {
	var err error
	var argBytes []byte
	var vv []*Alarm
	request := &types.ProcedureCall{
		Procedure: "AlarmManager_get_Alarms",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// AlarmsStream - a list of all alarms.
//
// Allowed game scenes: any.
func (s *AlarmManager) AlarmsStream() (*krpcgo.Stream[[]*Alarm], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AlarmManager_get_Alarms",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Alarm {
		var value []*Alarm
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Engage - engage the auto-pilot.
//
// Allowed game scenes: any.
func (s *AutoPilot) Engage() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_Engage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Disengage - disengage the auto-pilot.
//
// Allowed game scenes: any.
func (s *AutoPilot) Disengage() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_Disengage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Wait - blocks until the vessel is pointing in the target direction and has
// the target roll (if set). Throws an exception if the auto-pilot has not been
// engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) Wait() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_Wait",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetPitchAndHeading - set target pitch and heading angles.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetPitchAndHeading(pitch float32, heading float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_TargetPitchAndHeading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pitch)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(heading)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Error - the error, in degrees, between the direction the ship has been asked
// to point in and the direction it is pointing in. Throws an exception if the
// auto-pilot has not been engaged and SAS is not enabled or is in stability
// assist mode.
//
// Allowed game scenes: any.
func (s *AutoPilot) Error() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_Error",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ErrorStream - the error, in degrees, between the direction the ship has been
// asked to point in and the direction it is pointing in. Throws an exception if
// the auto-pilot has not been engaged and SAS is not enabled or is in stability
// assist mode.
//
// Allowed game scenes: any.
func (s *AutoPilot) ErrorStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_Error",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PitchError - the error, in degrees, between the vessels current and target
// pitch. Throws an exception if the auto-pilot has not been engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) PitchError() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_PitchError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PitchErrorStream - the error, in degrees, between the vessels current and
// target pitch. Throws an exception if the auto-pilot has not been engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) PitchErrorStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_PitchError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HeadingError - the error, in degrees, between the vessels current and target
// heading. Throws an exception if the auto-pilot has not been engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) HeadingError() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_HeadingError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HeadingErrorStream - the error, in degrees, between the vessels current and
// target heading. Throws an exception if the auto-pilot has not been engaged.
//
// Allowed game scenes: any.
func (s *AutoPilot) HeadingErrorStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_HeadingError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RollError - the error, in degrees, between the vessels current and target
// roll. Throws an exception if the auto-pilot has not been engaged or no target
// roll is set.
//
// Allowed game scenes: any.
func (s *AutoPilot) RollError() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_RollError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RollErrorStream - the error, in degrees, between the vessels current and
// target roll. Throws an exception if the auto-pilot has not been engaged or no
// target roll is set.
//
// Allowed game scenes: any.
func (s *AutoPilot) RollErrorStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_RollError",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReferenceFrame - the reference frame for the target direction (<see
// cref="M:SpaceCenter.AutoPilot.TargetDirection" />).
//
// Allowed game scenes: any.
func (s *AutoPilot) ReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetReferenceFrame - the reference frame for the target direction (<see
// cref="M:SpaceCenter.AutoPilot.TargetDirection" />).
//
// Allowed game scenes: any.
func (s *AutoPilot) SetReferenceFrame(value *ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetPitch - the target pitch, in degrees, between -90° and +90°.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetPitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TargetPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TargetPitchStream - the target pitch, in degrees, between -90° and +90°.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetPitchStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TargetPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTargetPitch - the target pitch, in degrees, between -90° and +90°.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTargetPitch(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_TargetPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetHeading - the target heading, in degrees, between 0° and 360°.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetHeading() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TargetHeading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TargetHeadingStream - the target heading, in degrees, between 0° and 360°.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetHeadingStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TargetHeading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTargetHeading - the target heading, in degrees, between 0° and 360°.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTargetHeading(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_TargetHeading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetRoll - the target roll, in degrees. NaN if no target roll is set.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetRoll() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TargetRoll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TargetRollStream - the target roll, in degrees. NaN if no target roll is set.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetRollStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TargetRoll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTargetRoll - the target roll, in degrees. NaN if no target roll is set.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTargetRoll(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_TargetRoll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TargetDirection - direction vector corresponding to the target pitch and
// heading. This is in the reference frame specified by <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetDirection() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TargetDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TargetDirectionStream - direction vector corresponding to the target pitch
// and heading. This is in the reference frame specified by <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) TargetDirectionStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TargetDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTargetDirection - direction vector corresponding to the target pitch and
// heading. This is in the reference frame specified by <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTargetDirection(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_TargetDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SAS - the state of SAS.
//
// Allowed game scenes: any.
func (s *AutoPilot) SAS() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SASStream - the state of SASStream.
//
// Allowed game scenes: any.
func (s *AutoPilot) SASStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSAS - the state of SAS.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetSAS(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SASMode - the current <see cref="T:SpaceCenter.SASMode" />. These modes are
// equivalent to the mode buttons to the left of the navball that appear when
// SAS is enabled.
//
// Allowed game scenes: any.
func (s *AutoPilot) SASMode() (SASMode, error) {
	var err error
	var argBytes []byte
	var vv SASMode
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SASModeStream - the current <see cref="T:SpaceCenter.SASModeStream" />. These
// modes are equivalent to the mode buttons to the left of the navball that
// appear when SAS is enabled.
//
// Allowed game scenes: any.
func (s *AutoPilot) SASModeStream() (*krpcgo.Stream[SASMode], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) SASMode {
		var value SASMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSASMode - the current <see cref="T:SpaceCenter.SASMode" />. These modes
// are equivalent to the mode buttons to the left of the navball that appear
// when SAS is enabled.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetSASMode(value SASMode) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RollThreshold - the threshold at which the autopilot will try to match the
// target roll angle, if any. Defaults to 5 degrees.
//
// Allowed game scenes: any.
func (s *AutoPilot) RollThreshold() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_RollThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RollThresholdStream - the threshold at which the autopilot will try to match
// the target roll angle, if any. Defaults to 5 degrees.
//
// Allowed game scenes: any.
func (s *AutoPilot) RollThresholdStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_RollThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRollThreshold - the threshold at which the autopilot will try to match the
// target roll angle, if any. Defaults to 5 degrees.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetRollThreshold(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_RollThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// StoppingTime - the maximum amount of time that the vessel should need to come
// to a complete stop. This determines the maximum angular velocity of the
// vessel. A vector of three stopping times, in seconds, one for each of the
// pitch, roll and yaw axes. Defaults to 0.5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) StoppingTime() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_StoppingTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StoppingTimeStream - the maximum amount of time that the vessel should need
// to come to a complete stop. This determines the maximum angular velocity of
// the vessel. A vector of three stopping times, in seconds, one for each of the
// pitch, roll and yaw axes. Defaults to 0.5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) StoppingTimeStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_StoppingTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetStoppingTime - the maximum amount of time that the vessel should need to
// come to a complete stop. This determines the maximum angular velocity of the
// vessel. A vector of three stopping times, in seconds, one for each of the
// pitch, roll and yaw axes. Defaults to 0.5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetStoppingTime(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_StoppingTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// DecelerationTime - the time the vessel should take to come to a stop pointing
// in the target direction. This determines the angular acceleration used to
// decelerate the vessel. A vector of three times, in seconds, one for each of
// the pitch, roll and yaw axes. Defaults to 5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) DecelerationTime() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_DecelerationTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DecelerationTimeStream - the time the vessel should take to come to a stop
// pointing in the target direction. This determines the angular acceleration
// used to decelerate the vessel. A vector of three times, in seconds, one for
// each of the pitch, roll and yaw axes. Defaults to 5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) DecelerationTimeStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_DecelerationTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDecelerationTime - the time the vessel should take to come to a stop
// pointing in the target direction. This determines the angular acceleration
// used to decelerate the vessel. A vector of three times, in seconds, one for
// each of the pitch, roll and yaw axes. Defaults to 5 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetDecelerationTime(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_DecelerationTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AttenuationAngle - the angle at which the autopilot considers the vessel to
// be pointing close to the target. This determines the midpoint of the target
// velocity attenuation function. A vector of three angles, in degrees, one for
// each of the pitch, roll and yaw axes. Defaults to 1° for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) AttenuationAngle() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_AttenuationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AttenuationAngleStream - the angle at which the autopilot considers the
// vessel to be pointing close to the target. This determines the midpoint of
// the target velocity attenuation function. A vector of three angles, in
// degrees, one for each of the pitch, roll and yaw axes. Defaults to 1° for
// each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) AttenuationAngleStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_AttenuationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAttenuationAngle - the angle at which the autopilot considers the vessel
// to be pointing close to the target. This determines the midpoint of the
// target velocity attenuation function. A vector of three angles, in degrees,
// one for each of the pitch, roll and yaw axes. Defaults to 1° for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetAttenuationAngle(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_AttenuationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AutoTune - whether the rotation rate controllers PID parameters should be
// automatically tuned using the vessels moment of inertia and available torque.
// Defaults to true. See <see cref="M:SpaceCenter.AutoPilot.TimeToPeak" /> and
// <see cref="M:SpaceCenter.AutoPilot.Overshoot" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) AutoTune() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_AutoTune",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AutoTuneStream - whether the rotation rate controllers PID parameters should
// be automatically tuned using the vessels moment of inertia and available
// torque. Defaults to true. See <see cref="M:SpaceCenter.AutoPilot.TimeToPeak"
// /> and <see cref="M:SpaceCenter.AutoPilot.Overshoot" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) AutoTuneStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_AutoTune",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAutoTune - whether the rotation rate controllers PID parameters should be
// automatically tuned using the vessels moment of inertia and available torque.
// Defaults to true. See <see cref="M:SpaceCenter.AutoPilot.TimeToPeak" /> and
// <see cref="M:SpaceCenter.AutoPilot.Overshoot" />.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetAutoTune(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_AutoTune",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TimeToPeak - the target time to peak used to autotune the PID controllers. A
// vector of three times, in seconds, for each of the pitch, roll and yaw axes.
// Defaults to 3 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) TimeToPeak() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TimeToPeak",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TimeToPeakStream - the target time to peak used to autotune the PID
// controllers. A vector of three times, in seconds, for each of the pitch, roll
// and yaw axes. Defaults to 3 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) TimeToPeakStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_TimeToPeak",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTimeToPeak - the target time to peak used to autotune the PID controllers.
// A vector of three times, in seconds, for each of the pitch, roll and yaw
// axes. Defaults to 3 seconds for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetTimeToPeak(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_TimeToPeak",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Overshoot - the target overshoot percentage used to autotune the PID
// controllers. A vector of three values, between 0 and 1, for each of the
// pitch, roll and yaw axes. Defaults to 0.01 for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) Overshoot() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_Overshoot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OvershootStream - the target overshoot percentage used to autotune the PID
// controllers. A vector of three values, between 0 and 1, for each of the
// pitch, roll and yaw axes. Defaults to 0.01 for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) OvershootStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_Overshoot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetOvershoot - the target overshoot percentage used to autotune the PID
// controllers. A vector of three values, between 0 and 1, for each of the
// pitch, roll and yaw axes. Defaults to 0.01 for each axis.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetOvershoot(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_Overshoot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// PitchPIDGains - gains for the pitch PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) PitchPIDGains() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_PitchPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PitchPIDGainsStream - gains for the pitch PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) PitchPIDGainsStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_PitchPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPitchPIDGains - gains for the pitch PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetPitchPIDGains(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_PitchPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RollPIDGains - gains for the roll PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) RollPIDGains() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_RollPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RollPIDGainsStream - gains for the roll PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) RollPIDGainsStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_RollPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRollPIDGains - gains for the roll PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetRollPIDGains(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_RollPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// YawPIDGains - gains for the yaw PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) YawPIDGains() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_YawPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// YawPIDGainsStream - gains for the yaw PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) YawPIDGainsStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_get_YawPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetYawPIDGains - gains for the yaw PID controller.
//
// Allowed game scenes: any.
func (s *AutoPilot) SetYawPIDGains(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "AutoPilot_set_YawPIDGains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Mode - the current mode of the camera.
//
// Allowed game scenes: any.
func (s *Camera) Mode() (CameraMode, error) {
	var err error
	var argBytes []byte
	var vv CameraMode
	request := &types.ProcedureCall{
		Procedure: "Camera_get_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ModeStream - the current mode of the camera.
//
// Allowed game scenes: any.
func (s *Camera) ModeStream() (*krpcgo.Stream[CameraMode], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_get_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) CameraMode {
		var value CameraMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMode - the current mode of the camera.
//
// Allowed game scenes: any.
func (s *Camera) SetMode(value CameraMode) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_set_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Pitch - the pitch of the camera, in degrees. A value between <see
// cref="M:SpaceCenter.Camera.MinPitch" /> and <see
// cref="M:SpaceCenter.Camera.MaxPitch" />
//
// Allowed game scenes: any.
func (s *Camera) Pitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Camera_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PitchStream - the pitch of the camera, in degrees. A value between <see
// cref="M:SpaceCenter.Camera.MinPitchStream" /> and <see
// cref="M:SpaceCenter.Camera.MaxPitchStream" />
//
// Allowed game scenes: any.
func (s *Camera) PitchStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPitch - the pitch of the camera, in degrees. A value between <see
// cref="M:SpaceCenter.Camera.MinPitch" /> and <see
// cref="M:SpaceCenter.Camera.MaxPitch" />
//
// Allowed game scenes: any.
func (s *Camera) SetPitch(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_set_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Heading - the heading of the camera, in degrees.
//
// Allowed game scenes: any.
func (s *Camera) Heading() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Camera_get_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HeadingStream - the heading of the camera, in degrees.
//
// Allowed game scenes: any.
func (s *Camera) HeadingStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_get_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetHeading - the heading of the camera, in degrees.
//
// Allowed game scenes: any.
func (s *Camera) SetHeading(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_set_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Distance - the distance from the camera to the subject, in meters. A value
// between <see cref="M:SpaceCenter.Camera.MinDistance" /> and <see
// cref="M:SpaceCenter.Camera.MaxDistance" />.
//
// Allowed game scenes: any.
func (s *Camera) Distance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Camera_get_Distance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DistanceStream - the distance from the camera to the subject, in meters. A
// value between <see cref="M:SpaceCenter.Camera.MinDistanceStream" /> and <see
// cref="M:SpaceCenter.Camera.MaxDistanceStream" />.
//
// Allowed game scenes: any.
func (s *Camera) DistanceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_get_Distance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDistance - the distance from the camera to the subject, in meters. A value
// between <see cref="M:SpaceCenter.Camera.MinDistance" /> and <see
// cref="M:SpaceCenter.Camera.MaxDistance" />.
//
// Allowed game scenes: any.
func (s *Camera) SetDistance(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_set_Distance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MinPitch - the minimum pitch of the camera.
//
// Allowed game scenes: any.
func (s *Camera) MinPitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Camera_get_MinPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MinPitchStream - the minimum pitch of the camera.
//
// Allowed game scenes: any.
func (s *Camera) MinPitchStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_get_MinPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxPitch - the maximum pitch of the camera.
//
// Allowed game scenes: any.
func (s *Camera) MaxPitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Camera_get_MaxPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxPitchStream - the maximum pitch of the camera.
//
// Allowed game scenes: any.
func (s *Camera) MaxPitchStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_get_MaxPitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MinDistance - minimum distance from the camera to the subject, in meters.
//
// Allowed game scenes: any.
func (s *Camera) MinDistance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Camera_get_MinDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MinDistanceStream - minimum distance from the camera to the subject, in
// meters.
//
// Allowed game scenes: any.
func (s *Camera) MinDistanceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_get_MinDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxDistance - maximum distance from the camera to the subject, in meters.
//
// Allowed game scenes: any.
func (s *Camera) MaxDistance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Camera_get_MaxDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxDistanceStream - maximum distance from the camera to the subject, in
// meters.
//
// Allowed game scenes: any.
func (s *Camera) MaxDistanceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_get_MaxDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DefaultDistance - default distance from the camera to the subject, in meters.
//
// Allowed game scenes: any.
func (s *Camera) DefaultDistance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Camera_get_DefaultDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DefaultDistanceStream - default distance from the camera to the subject, in
// meters.
//
// Allowed game scenes: any.
func (s *Camera) DefaultDistanceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_get_DefaultDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FocussedBody - in map mode, the celestial body that the camera is focussed
// on. Returns nil if the camera is not focussed on a celestial body. Returns an
// error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) FocussedBody() (*CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv CelestialBody
	request := &types.ProcedureCall{
		Procedure: "Camera_get_FocussedBody",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetFocussedBody - in map mode, the celestial body that the camera is focussed
// on. Returns nil if the camera is not focussed on a celestial body. Returns an
// error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) SetFocussedBody(value *CelestialBody) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_set_FocussedBody",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// FocussedVessel - in map mode, the vessel that the camera is focussed on.
// Returns nil if the camera is not focussed on a vessel. Returns an error is
// the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) FocussedVessel() (*Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &types.ProcedureCall{
		Procedure: "Camera_get_FocussedVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetFocussedVessel - in map mode, the vessel that the camera is focussed on.
// Returns nil if the camera is not focussed on a vessel. Returns an error is
// the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) SetFocussedVessel(value *Vessel) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_set_FocussedVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// FocussedNode - in map mode, the maneuver node that the camera is focussed on.
// Returns nil if the camera is not focussed on a maneuver node. Returns an
// error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) FocussedNode() (*Node, error) {
	var err error
	var argBytes []byte
	var vv Node
	request := &types.ProcedureCall{
		Procedure: "Camera_get_FocussedNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetFocussedNode - in map mode, the maneuver node that the camera is focussed
// on. Returns nil if the camera is not focussed on a maneuver node. Returns an
// error is the camera is not in map mode.
//
// Allowed game scenes: any.
func (s *Camera) SetFocussedNode(value *Node) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Camera_set_FocussedNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SurfaceHeight - the height of the surface relative to mean sea level, in
// meters, at the given position. When over water this is equal to 0.
//
// Allowed game scenes: any.
func (s *CelestialBody) SurfaceHeight(latitude float64, longitude float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_SurfaceHeight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SurfaceHeightStream - the height of the surface relative to mean sea level,
// in meters, at the given position. When over water this is equal to 0.
//
// Allowed game scenes: any.
func (s *CelestialBody) SurfaceHeightStream(latitude float64, longitude float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_SurfaceHeight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// BedrockHeight - the height of the surface relative to mean sea level, in
// meters, at the given position. When over water, this is the height of the
// sea-bed and is therefore  negative value.
//
// Allowed game scenes: any.
func (s *CelestialBody) BedrockHeight(latitude float64, longitude float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_BedrockHeight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BedrockHeightStream - the height of the surface relative to mean sea level,
// in meters, at the given position. When over water, this is the height of the
// sea-bed and is therefore  negative value.
//
// Allowed game scenes: any.
func (s *CelestialBody) BedrockHeightStream(latitude float64, longitude float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_BedrockHeight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MSLPosition - the position at mean sea level at the given latitude and
// longitude, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) MSLPosition(latitude float64, longitude float64, referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_MSLPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MSLPositionStream - the position at mean sea level at the given latitude and
// longitude, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) MSLPositionStream(latitude float64, longitude float64, referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_MSLPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SurfacePosition - the position of the surface at the given latitude and
// longitude, in the given reference frame. When over water, this is the
// position of the surface of the water.
//
// Allowed game scenes: any.
func (s *CelestialBody) SurfacePosition(latitude float64, longitude float64, referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_SurfacePosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SurfacePositionStream - the position of the surface at the given latitude and
// longitude, in the given reference frame. When over water, this is the
// position of the surface of the water.
//
// Allowed game scenes: any.
func (s *CelestialBody) SurfacePositionStream(latitude float64, longitude float64, referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_SurfacePosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// BedrockPosition - the position of the surface at the given latitude and
// longitude, in the given reference frame. When over water, this is the
// position at the bottom of the sea-bed.
//
// Allowed game scenes: any.
func (s *CelestialBody) BedrockPosition(latitude float64, longitude float64, referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_BedrockPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BedrockPositionStream - the position of the surface at the given latitude and
// longitude, in the given reference frame. When over water, this is the
// position at the bottom of the sea-bed.
//
// Allowed game scenes: any.
func (s *CelestialBody) BedrockPositionStream(latitude float64, longitude float64, referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_BedrockPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PositionAtAltitude - the position at the given latitude, longitude and
// altitude, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) PositionAtAltitude(latitude float64, longitude float64, altitude float64, referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_PositionAtAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionAtAltitudeStream - the position at the given latitude, longitude and
// altitude, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) PositionAtAltitudeStream(latitude float64, longitude float64, altitude float64, referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_PositionAtAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// LatitudeAtPosition - the latitude of the given position, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) LatitudeAtPosition(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_LatitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LatitudeAtPositionStream - the latitude of the given position, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) LatitudeAtPositionStream(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_LatitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// LongitudeAtPosition - the longitude of the given position, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) LongitudeAtPosition(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_LongitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LongitudeAtPositionStream - the longitude of the given position, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) LongitudeAtPositionStream(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_LongitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AltitudeAtPosition - the altitude, in meters, of the given position in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) AltitudeAtPosition(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_AltitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AltitudeAtPositionStream - the altitude, in meters, of the given position in
// the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) AltitudeAtPositionStream(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_AltitudeAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AtmosphericDensityAtPosition - the atmospheric density at the given position,
// in <math>kg/m^3</math>, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) AtmosphericDensityAtPosition(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_AtmosphericDensityAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AtmosphericDensityAtPositionStream - the atmospheric density at the given
// position, in <math>kg/m^3</math>, in the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) AtmosphericDensityAtPositionStream(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_AtmosphericDensityAtPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TemperatureAt - the temperature on the body at the given position, in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) TemperatureAt(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_TemperatureAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TemperatureAtStream - the temperature on the body at the given position, in
// the given reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) TemperatureAtStream(position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_TemperatureAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DensityAt - gets the air density, in <math>kg/m^3</math>, for the specified
// altitude above sea level, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) DensityAt(altitude float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_DensityAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DensityAtStream - gets the air density, in <math>kg/m^3</math>, for the
// specified altitude above sea level, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) DensityAtStream(altitude float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_DensityAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PressureAt - gets the air pressure, in Pascals, for the specified altitude
// above sea level, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) PressureAt(altitude float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_PressureAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PressureAtStream - gets the air pressure, in Pascals, for the specified
// altitude above sea level, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) PressureAtStream(altitude float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_PressureAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// BiomeAt - the biome at the given latitude and longitude, in degrees.
//
// Allowed game scenes: any.
func (s *CelestialBody) BiomeAt(latitude float64, longitude float64) (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_BiomeAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BiomeAtStream - the biome at the given latitude and longitude, in degrees.
//
// Allowed game scenes: any.
func (s *CelestialBody) BiomeAtStream(latitude float64, longitude float64) (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_BiomeAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Position - the position of the center of the body, in the specified reference
// frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) Position(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionStream - the position of the center of the body, in the specified
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) PositionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Velocity - the linear velocity of the body, in the specified reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) Velocity(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VelocityStream - the linear velocity of the body, in the specified reference
// frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) VelocityStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rotation - the rotation of the body, in the specified reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) Rotation(referenceFrame *ReferenceFrame) (types.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple4[float64, float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationStream - the rotation of the body, in the specified reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple4[float64, float64, float64, float64] {
		var value types.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Direction - the direction in which the north pole of the celestial body is
// pointing, in the specified reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) Direction(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DirectionStream - the direction in which the north pole of the celestial body
// is pointing, in the specified reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) DirectionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AngularVelocity - the angular velocity of the body in the specified reference
// frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) AngularVelocity(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_AngularVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AngularVelocityStream - the angular velocity of the body in the specified
// reference frame.
//
// Allowed game scenes: any.
func (s *CelestialBody) AngularVelocityStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_AngularVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Name - the name of the body.
//
// Allowed game scenes: any.
func (s *CelestialBody) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the name of the body.
//
// Allowed game scenes: any.
func (s *CelestialBody) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Satellites - a list of celestial bodies that are in orbit around this
// celestial body.
//
// Allowed game scenes: any.
func (s *CelestialBody) Satellites() ([]*CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv []*CelestialBody
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_Satellites",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// SatellitesStream - a list of celestial bodies that are in orbit around this
// celestial body.
//
// Allowed game scenes: any.
func (s *CelestialBody) SatellitesStream() (*krpcgo.Stream[[]*CelestialBody], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_Satellites",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*CelestialBody {
		var value []*CelestialBody
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Mass - the mass of the body, in kilograms.
//
// Allowed game scenes: any.
func (s *CelestialBody) Mass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MassStream - the mass of the body, in kilograms.
//
// Allowed game scenes: any.
func (s *CelestialBody) MassStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// GravitationalParameter - the <a
// href="https://en.wikipedia.org/wiki/Standard_gravitational_parameter">standard
// gravitational parameter</a> of the body in <math>m^3s^{-2}</math>.
//
// Allowed game scenes: any.
func (s *CelestialBody) GravitationalParameter() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_GravitationalParameter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GravitationalParameterStream - the <a
// href="https://en.wikipedia.org/wiki/Standard_gravitational_parameter">standard
// gravitational parameter</a> of the body in <math>m^3s^{-2}</math>.
//
// Allowed game scenes: any.
func (s *CelestialBody) GravitationalParameterStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_GravitationalParameter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SurfaceGravity - the acceleration due to gravity at sea level (mean altitude)
// on the body, in <math>m/s^2</math>.
//
// Allowed game scenes: any.
func (s *CelestialBody) SurfaceGravity() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_SurfaceGravity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SurfaceGravityStream - the acceleration due to gravity at sea level (mean
// altitude) on the body, in <math>m/s^2</math>.
//
// Allowed game scenes: any.
func (s *CelestialBody) SurfaceGravityStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_SurfaceGravity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RotationalPeriod - the sidereal rotational period of the body, in seconds.
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationalPeriod() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_RotationalPeriod",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationalPeriodStream - the sidereal rotational period of the body, in
// seconds.
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationalPeriodStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_RotationalPeriod",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RotationalSpeed - the rotational speed of the body, in radians per second.
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationalSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_RotationalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationalSpeedStream - the rotational speed of the body, in radians per
// second.
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationalSpeedStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_RotationalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RotationAngle - the current rotation angle of the body, in radians. A value
// between 0 and <math>2\pi</math>
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationAngle() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_RotationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationAngleStream - the current rotation angle of the body, in radians. A
// value between 0 and <math>2\pi</math>
//
// Allowed game scenes: any.
func (s *CelestialBody) RotationAngleStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_RotationAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// InitialRotation - the initial rotation angle of the body (at UT 0), in
// radians. A value between 0 and <math>2\pi</math>
//
// Allowed game scenes: any.
func (s *CelestialBody) InitialRotation() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_InitialRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InitialRotationStream - the initial rotation angle of the body (at UT 0), in
// radians. A value between 0 and <math>2\pi</math>
//
// Allowed game scenes: any.
func (s *CelestialBody) InitialRotationStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_InitialRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// EquatorialRadius - the equatorial radius of the body, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) EquatorialRadius() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_EquatorialRadius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EquatorialRadiusStream - the equatorial radius of the body, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) EquatorialRadiusStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_EquatorialRadius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SphereOfInfluence - the radius of the sphere of influence of the body, in
// meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) SphereOfInfluence() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_SphereOfInfluence",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SphereOfInfluenceStream - the radius of the sphere of influence of the body,
// in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) SphereOfInfluenceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_SphereOfInfluence",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Orbit - the orbit of the body.
//
// Allowed game scenes: any.
func (s *CelestialBody) Orbit() (*Orbit, error) {
	var err error
	var argBytes []byte
	var vv Orbit
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_Orbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// IsStar - whether or not the body is a star.
//
// Allowed game scenes: any.
func (s *CelestialBody) IsStar() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_IsStar",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsStarStream - whether or not the body is a star.
//
// Allowed game scenes: any.
func (s *CelestialBody) IsStarStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_IsStar",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasSolidSurface - whether or not the body has a solid surface.
//
// Allowed game scenes: any.
func (s *CelestialBody) HasSolidSurface() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_HasSolidSurface",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasSolidSurfaceStream - whether or not the body has a solid surface.
//
// Allowed game scenes: any.
func (s *CelestialBody) HasSolidSurfaceStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_HasSolidSurface",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasAtmosphere - true if the body has an atmosphere.
//
// Allowed game scenes: any.
func (s *CelestialBody) HasAtmosphere() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_HasAtmosphere",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasAtmosphereStream - true if the body has an atmosphere.
//
// Allowed game scenes: any.
func (s *CelestialBody) HasAtmosphereStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_HasAtmosphere",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AtmosphereDepth - the depth of the atmosphere, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) AtmosphereDepth() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_AtmosphereDepth",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AtmosphereDepthStream - the depth of the atmosphere, in meters.
//
// Allowed game scenes: any.
func (s *CelestialBody) AtmosphereDepthStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_AtmosphereDepth",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasAtmosphericOxygen - true if there is oxygen in the atmosphere, required
// for air-breathing engines.
//
// Allowed game scenes: any.
func (s *CelestialBody) HasAtmosphericOxygen() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_HasAtmosphericOxygen",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasAtmosphericOxygenStream - true if there is oxygen in the atmosphere,
// required for air-breathing engines.
//
// Allowed game scenes: any.
func (s *CelestialBody) HasAtmosphericOxygenStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_HasAtmosphericOxygen",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Biomes - the biomes present on this body.
//
// Allowed game scenes: any.
func (s *CelestialBody) Biomes() (map[string]struct{}, error) {
	var err error
	var argBytes []byte
	var vv map[string]struct{}
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_Biomes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BiomesStream - the biomes present on this body.
//
// Allowed game scenes: any.
func (s *CelestialBody) BiomesStream() (*krpcgo.Stream[map[string]struct{}], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_Biomes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) map[string]struct{} {
		var value map[string]struct{}
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FlyingHighAltitudeThreshold - the altitude, in meters, above which a vessel
// is considered to be flying "high" when doing science.
//
// Allowed game scenes: any.
func (s *CelestialBody) FlyingHighAltitudeThreshold() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_FlyingHighAltitudeThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FlyingHighAltitudeThresholdStream - the altitude, in meters, above which a
// vessel is considered to be flying "high" when doing science.
//
// Allowed game scenes: any.
func (s *CelestialBody) FlyingHighAltitudeThresholdStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_FlyingHighAltitudeThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SpaceHighAltitudeThreshold - the altitude, in meters, above which a vessel is
// considered to be in "high" space when doing science.
//
// Allowed game scenes: any.
func (s *CelestialBody) SpaceHighAltitudeThreshold() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_SpaceHighAltitudeThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpaceHighAltitudeThresholdStream - the altitude, in meters, above which a
// vessel is considered to be in "high" space when doing science.
//
// Allowed game scenes: any.
func (s *CelestialBody) SpaceHighAltitudeThresholdStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_SpaceHighAltitudeThreshold",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReferenceFrame - the reference frame that is fixed relative to the celestial
// body. <list type="bullet"><item><description>The origin is at the center of
// the body. </description></item><item><description>The axes rotate with the
// body.</description></item><item><description>The x-axis points from the
// center of the body towards the intersection of the prime meridian and equator
// (the position at 0° longitude, 0°
// latitude).</description></item><item><description>The y-axis points from the
// center of the body towards the north
// pole.</description></item><item><description>The z-axis points from the
// center of the body towards the equator at 90°E
// longitude.</description></item></list>
//
// Allowed game scenes: any.
func (s *CelestialBody) ReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// NonRotatingReferenceFrame - the reference frame that is fixed relative to
// this celestial body, and orientated in a fixed direction (it does not rotate
// with the body). <list type="bullet"><item><description>The origin is at the
// center of the body.</description></item><item><description>The axes do not
// rotate.</description></item><item><description>The x-axis points in an
// arbitrary direction through the
// equator.</description></item><item><description>The y-axis points from the
// center of the body towards the north
// pole.</description></item><item><description>The z-axis points in an
// arbitrary direction through the equator.</description></item></list>
//
// Allowed game scenes: any.
func (s *CelestialBody) NonRotatingReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_NonRotatingReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// OrbitalReferenceFrame - the reference frame that is fixed relative to this
// celestial body, but orientated with the body's orbital prograde/normal/radial
// directions. <list type="bullet"><item><description>The origin is at the
// center of the body. </description></item><item><description>The axes rotate
// with the orbital prograde/normal/radial
// directions.</description></item><item><description>The x-axis points in the
// orbital anti-radial direction. </description></item><item><description>The
// y-axis points in the orbital prograde direction.
// </description></item><item><description>The z-axis points in the orbital
// normal direction. </description></item></list>
//
// Allowed game scenes: any.
func (s *CelestialBody) OrbitalReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "CelestialBody_get_OrbitalReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Type - the type of link.
//
// Allowed game scenes: any.
func (s *CommLink) Type() (CommLinkType, error) {
	var err error
	var argBytes []byte
	var vv CommLinkType
	request := &types.ProcedureCall{
		Procedure: "CommLink_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TypeStream - the type of link.
//
// Allowed game scenes: any.
func (s *CommLink) TypeStream() (*krpcgo.Stream[CommLinkType], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CommLink_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) CommLinkType {
		var value CommLinkType
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SignalStrength - signal strength of the link.
//
// Allowed game scenes: any.
func (s *CommLink) SignalStrength() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "CommLink_get_SignalStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SignalStrengthStream - signal strength of the link.
//
// Allowed game scenes: any.
func (s *CommLink) SignalStrengthStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CommLink_get_SignalStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Start - start point of the link.
//
// Allowed game scenes: any.
func (s *CommLink) Start() (*CommNode, error) {
	var err error
	var argBytes []byte
	var vv CommNode
	request := &types.ProcedureCall{
		Procedure: "CommLink_get_Start",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// End - start point of the link.
//
// Allowed game scenes: any.
func (s *CommLink) End() (*CommNode, error) {
	var err error
	var argBytes []byte
	var vv CommNode
	request := &types.ProcedureCall{
		Procedure: "CommLink_get_End",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Name - name of the communication node.
//
// Allowed game scenes: any.
func (s *CommNode) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "CommNode_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - name of the communication node.
//
// Allowed game scenes: any.
func (s *CommNode) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CommNode_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IsHome - whether the communication node is on Kerbin.
//
// Allowed game scenes: any.
func (s *CommNode) IsHome() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CommNode_get_IsHome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsHomeStream - whether the communication node is on Kerbin.
//
// Allowed game scenes: any.
func (s *CommNode) IsHomeStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CommNode_get_IsHome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IsControlPoint - whether the communication node is a control point, for
// example a manned vessel.
//
// Allowed game scenes: any.
func (s *CommNode) IsControlPoint() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CommNode_get_IsControlPoint",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsControlPointStream - whether the communication node is a control point, for
// example a manned vessel.
//
// Allowed game scenes: any.
func (s *CommNode) IsControlPointStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CommNode_get_IsControlPoint",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IsVessel - whether the communication node is a vessel.
//
// Allowed game scenes: any.
func (s *CommNode) IsVessel() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CommNode_get_IsVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsVesselStream - whether the communication node is a vessel.
//
// Allowed game scenes: any.
func (s *CommNode) IsVesselStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CommNode_get_IsVessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Vessel - the vessel for this communication node.
//
// Allowed game scenes: any.
func (s *CommNode) Vessel() (*Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &types.ProcedureCall{
		Procedure: "CommNode_get_Vessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// CanCommunicate - whether the vessel can communicate with KSC.
//
// Allowed game scenes: any.
func (s *Comms) CanCommunicate() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Comms_get_CanCommunicate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanCommunicateStream - whether the vessel can communicate with KSC.
//
// Allowed game scenes: any.
func (s *Comms) CanCommunicateStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Comms_get_CanCommunicate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CanTransmitScience - whether the vessel can transmit science data to KSC.
//
// Allowed game scenes: any.
func (s *Comms) CanTransmitScience() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Comms_get_CanTransmitScience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanTransmitScienceStream - whether the vessel can transmit science data to
// KSC.
//
// Allowed game scenes: any.
func (s *Comms) CanTransmitScienceStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Comms_get_CanTransmitScience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SignalStrength - signal strength to KSC.
//
// Allowed game scenes: any.
func (s *Comms) SignalStrength() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Comms_get_SignalStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SignalStrengthStream - signal strength to KSC.
//
// Allowed game scenes: any.
func (s *Comms) SignalStrengthStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Comms_get_SignalStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SignalDelay - signal delay to KSC in seconds.
//
// Allowed game scenes: any.
func (s *Comms) SignalDelay() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Comms_get_SignalDelay",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SignalDelayStream - signal delay to KSC in seconds.
//
// Allowed game scenes: any.
func (s *Comms) SignalDelayStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Comms_get_SignalDelay",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Power - the combined power of all active antennae on the vessel.
//
// Allowed game scenes: any.
func (s *Comms) Power() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Comms_get_Power",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PowerStream - the combined power of all active antennae on the vessel.
//
// Allowed game scenes: any.
func (s *Comms) PowerStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Comms_get_Power",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ControlPath - the communication path used to control the vessel.
//
// Allowed game scenes: any.
func (s *Comms) ControlPath() ([]*CommLink, error) {
	var err error
	var argBytes []byte
	var vv []*CommLink
	request := &types.ProcedureCall{
		Procedure: "Comms_get_ControlPath",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ControlPathStream - the communication path used to control the vessel.
//
// Allowed game scenes: any.
func (s *Comms) ControlPathStream() (*krpcgo.Stream[[]*CommLink], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Comms_get_ControlPath",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*CommLink {
		var value []*CommLink
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Cancel - cancel an active contract.
//
// Allowed game scenes: any.
func (s *Contract) Cancel() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_Cancel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Accept - accept an offered contract.
//
// Allowed game scenes: any.
func (s *Contract) Accept() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_Accept",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Decline - decline an offered contract.
//
// Allowed game scenes: any.
func (s *Contract) Decline() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_Decline",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Type - type of the contract.
//
// Allowed game scenes: any.
func (s *Contract) Type() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TypeStream - type of the contract.
//
// Allowed game scenes: any.
func (s *Contract) TypeStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Title - title of the contract.
//
// Allowed game scenes: any.
func (s *Contract) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TitleStream - title of the contract.
//
// Allowed game scenes: any.
func (s *Contract) TitleStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Description - description of the contract.
//
// Allowed game scenes: any.
func (s *Contract) Description() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Description",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DescriptionStream - description of the contract.
//
// Allowed game scenes: any.
func (s *Contract) DescriptionStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Description",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Notes - notes for the contract.
//
// Allowed game scenes: any.
func (s *Contract) Notes() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Notes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NotesStream - notes for the contract.
//
// Allowed game scenes: any.
func (s *Contract) NotesStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Notes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Synopsis - synopsis for the contract.
//
// Allowed game scenes: any.
func (s *Contract) Synopsis() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Synopsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SynopsisStream - synopsis for the contract.
//
// Allowed game scenes: any.
func (s *Contract) SynopsisStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Synopsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Keywords - keywords for the contract.
//
// Allowed game scenes: any.
func (s *Contract) Keywords() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Keywords",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// KeywordsStream - keywords for the contract.
//
// Allowed game scenes: any.
func (s *Contract) KeywordsStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Keywords",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// State - state of the contract.
//
// Allowed game scenes: any.
func (s *Contract) State() (ContractState, error) {
	var err error
	var argBytes []byte
	var vv ContractState
	request := &types.ProcedureCall{
		Procedure: "Contract_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - state of the contract.
//
// Allowed game scenes: any.
func (s *Contract) StateStream() (*krpcgo.Stream[ContractState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ContractState {
		var value ContractState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Active - whether the contract is active.
//
// Allowed game scenes: any.
func (s *Contract) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActiveStream - whether the contract is active.
//
// Allowed game scenes: any.
func (s *Contract) ActiveStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Failed - whether the contract has been failed.
//
// Allowed game scenes: any.
func (s *Contract) Failed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Failed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FailedStream - whether the contract has been failed.
//
// Allowed game scenes: any.
func (s *Contract) FailedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Failed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Seen - whether the contract has been seen.
//
// Allowed game scenes: any.
func (s *Contract) Seen() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Seen",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SeenStream - whether the contract has been seen.
//
// Allowed game scenes: any.
func (s *Contract) SeenStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Seen",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Read - whether the contract has been read.
//
// Allowed game scenes: any.
func (s *Contract) Read() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Read",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReadStream - whether the contract has been read.
//
// Allowed game scenes: any.
func (s *Contract) ReadStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Read",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CanBeCanceled - whether the contract can be canceled.
//
// Allowed game scenes: any.
func (s *Contract) CanBeCanceled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Contract_get_CanBeCanceled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanBeCanceledStream - whether the contract can be canceled.
//
// Allowed game scenes: any.
func (s *Contract) CanBeCanceledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_CanBeCanceled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CanBeDeclined - whether the contract can be declined.
//
// Allowed game scenes: any.
func (s *Contract) CanBeDeclined() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Contract_get_CanBeDeclined",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanBeDeclinedStream - whether the contract can be declined.
//
// Allowed game scenes: any.
func (s *Contract) CanBeDeclinedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_CanBeDeclined",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CanBeFailed - whether the contract can be failed.
//
// Allowed game scenes: any.
func (s *Contract) CanBeFailed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Contract_get_CanBeFailed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanBeFailedStream - whether the contract can be failed.
//
// Allowed game scenes: any.
func (s *Contract) CanBeFailedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_CanBeFailed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FundsAdvance - funds received when accepting the contract.
//
// Allowed game scenes: any.
func (s *Contract) FundsAdvance() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Contract_get_FundsAdvance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FundsAdvanceStream - funds received when accepting the contract.
//
// Allowed game scenes: any.
func (s *Contract) FundsAdvanceStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_FundsAdvance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FundsCompletion - funds received on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) FundsCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Contract_get_FundsCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FundsCompletionStream - funds received on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) FundsCompletionStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_FundsCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FundsFailure - funds lost if the contract is failed.
//
// Allowed game scenes: any.
func (s *Contract) FundsFailure() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Contract_get_FundsFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FundsFailureStream - funds lost if the contract is failed.
//
// Allowed game scenes: any.
func (s *Contract) FundsFailureStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_FundsFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReputationCompletion - reputation gained on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) ReputationCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Contract_get_ReputationCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReputationCompletionStream - reputation gained on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) ReputationCompletionStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_ReputationCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReputationFailure - reputation lost if the contract is failed.
//
// Allowed game scenes: any.
func (s *Contract) ReputationFailure() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Contract_get_ReputationFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReputationFailureStream - reputation lost if the contract is failed.
//
// Allowed game scenes: any.
func (s *Contract) ReputationFailureStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_ReputationFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ScienceCompletion - science gained on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) ScienceCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Contract_get_ScienceCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ScienceCompletionStream - science gained on completion of the contract.
//
// Allowed game scenes: any.
func (s *Contract) ScienceCompletionStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_ScienceCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Parameters - parameters for the contract.
//
// Allowed game scenes: any.
func (s *Contract) Parameters() ([]*ContractParameter, error) {
	var err error
	var argBytes []byte
	var vv []*ContractParameter
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Parameters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ParametersStream - parameters for the contract.
//
// Allowed game scenes: any.
func (s *Contract) ParametersStream() (*krpcgo.Stream[[]*ContractParameter], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Contract_get_Parameters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*ContractParameter {
		var value []*ContractParameter
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Types - a list of all contract types.
//
// Allowed game scenes: any.
func (s *ContractManager) Types() (map[string]struct{}, error) {
	var err error
	var argBytes []byte
	var vv map[string]struct{}
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_Types",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TypesStream - a list of all contract types.
//
// Allowed game scenes: any.
func (s *ContractManager) TypesStream() (*krpcgo.Stream[map[string]struct{}], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_Types",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) map[string]struct{} {
		var value map[string]struct{}
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AllContracts - a list of all contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) AllContracts() ([]*Contract, error) {
	var err error
	var argBytes []byte
	var vv []*Contract
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_AllContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// AllContractsStream - a list of all contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) AllContractsStream() (*krpcgo.Stream[[]*Contract], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_AllContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Contract {
		var value []*Contract
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ActiveContracts - a list of all active contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) ActiveContracts() ([]*Contract, error) {
	var err error
	var argBytes []byte
	var vv []*Contract
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_ActiveContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ActiveContractsStream - a list of all active contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) ActiveContractsStream() (*krpcgo.Stream[[]*Contract], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_ActiveContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Contract {
		var value []*Contract
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// OfferedContracts - a list of all offered, but unaccepted, contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) OfferedContracts() ([]*Contract, error) {
	var err error
	var argBytes []byte
	var vv []*Contract
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_OfferedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// OfferedContractsStream - a list of all offered, but unaccepted, contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) OfferedContractsStream() (*krpcgo.Stream[[]*Contract], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_OfferedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Contract {
		var value []*Contract
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CompletedContracts - a list of all completed contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) CompletedContracts() ([]*Contract, error) {
	var err error
	var argBytes []byte
	var vv []*Contract
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_CompletedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// CompletedContractsStream - a list of all completed contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) CompletedContractsStream() (*krpcgo.Stream[[]*Contract], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_CompletedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Contract {
		var value []*Contract
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FailedContracts - a list of all failed contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) FailedContracts() ([]*Contract, error) {
	var err error
	var argBytes []byte
	var vv []*Contract
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_FailedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// FailedContractsStream - a list of all failed contracts.
//
// Allowed game scenes: any.
func (s *ContractManager) FailedContractsStream() (*krpcgo.Stream[[]*Contract], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractManager_get_FailedContracts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Contract {
		var value []*Contract
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Title - title of the parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TitleStream - title of the parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) TitleStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Notes - notes for the parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) Notes() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Notes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NotesStream - notes for the parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) NotesStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Notes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Children - child contract parameters.
//
// Allowed game scenes: any.
func (s *ContractParameter) Children() ([]*ContractParameter, error) {
	var err error
	var argBytes []byte
	var vv []*ContractParameter
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Children",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ChildrenStream - child contract parameters.
//
// Allowed game scenes: any.
func (s *ContractParameter) ChildrenStream() (*krpcgo.Stream[[]*ContractParameter], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Children",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*ContractParameter {
		var value []*ContractParameter
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Completed - whether the parameter has been completed.
//
// Allowed game scenes: any.
func (s *ContractParameter) Completed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Completed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CompletedStream - whether the parameter has been completed.
//
// Allowed game scenes: any.
func (s *ContractParameter) CompletedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Completed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Failed - whether the parameter has been failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) Failed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Failed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FailedStream - whether the parameter has been failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) FailedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Failed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Optional - whether the contract parameter is optional.
//
// Allowed game scenes: any.
func (s *ContractParameter) Optional() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Optional",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OptionalStream - whether the contract parameter is optional.
//
// Allowed game scenes: any.
func (s *ContractParameter) OptionalStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_Optional",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FundsCompletion - funds received on completion of the contract parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) FundsCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_FundsCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FundsCompletionStream - funds received on completion of the contract
// parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) FundsCompletionStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_FundsCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FundsFailure - funds lost if the contract parameter is failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) FundsFailure() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_FundsFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FundsFailureStream - funds lost if the contract parameter is failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) FundsFailureStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_FundsFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReputationCompletion - reputation gained on completion of the contract
// parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) ReputationCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_ReputationCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReputationCompletionStream - reputation gained on completion of the contract
// parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) ReputationCompletionStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_ReputationCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReputationFailure - reputation lost if the contract parameter is failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) ReputationFailure() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_ReputationFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReputationFailureStream - reputation lost if the contract parameter is
// failed.
//
// Allowed game scenes: any.
func (s *ContractParameter) ReputationFailureStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_ReputationFailure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ScienceCompletion - science gained on completion of the contract parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) ScienceCompletion() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_ScienceCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ScienceCompletionStream - science gained on completion of the contract
// parameter.
//
// Allowed game scenes: any.
func (s *ContractParameter) ScienceCompletionStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ContractParameter_get_ScienceCompletion",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ActivateNextStage - activates the next stage. Equivalent to pressing the
// space bar in-game.
//
// Allowed game scenes: any.
func (s *Control) ActivateNextStage() ([]*Vessel, error) {
	var err error
	var argBytes []byte
	var vv []*Vessel
	request := &types.ProcedureCall{
		Procedure: "Control_ActivateNextStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ActivateNextStageStream - activates the next stage. Equivalent to pressing
// the space bar in-game.
//
// Allowed game scenes: any.
func (s *Control) ActivateNextStageStream() (*krpcgo.Stream[[]*Vessel], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_ActivateNextStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Vessel {
		var value []*Vessel
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// GetActionGroup - returns true if the given action group is enabled.
//
// Allowed game scenes: any.
func (s *Control) GetActionGroup(group uint32) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_GetActionGroup",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(group)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GetActionGroupStream - returns true if the given action group is enabled.
//
// Allowed game scenes: any.
func (s *Control) GetActionGroupStream(group uint32) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_GetActionGroup",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(group)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetActionGroup - sets the state of the given action group.
//
// Allowed game scenes: any.
func (s *Control) SetActionGroup(group uint32, state bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_SetActionGroup",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(group)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(state)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ToggleActionGroup - toggles the state of the given action group.
//
// Allowed game scenes: any.
func (s *Control) ToggleActionGroup(group uint32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_ToggleActionGroup",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(group)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AddNode - creates a maneuver node at the given universal time, and returns a
// <see cref="T:SpaceCenter.Node" /> object that can be used to modify it.
// Optionally sets the magnitude of the delta-v for the maneuver node in the
// prograde, normal and radial directions.
//
// Allowed game scenes: any.
func (s *Control) AddNode(ut float64, prograde float32, normal float32, radial float32) (*Node, error) {
	var err error
	var argBytes []byte
	var vv Node
	request := &types.ProcedureCall{
		Procedure: "Control_AddNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(prograde)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(normal)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(radial)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// RemoveNodes - remove all maneuver nodes.
//
// Allowed game scenes: any.
func (s *Control) RemoveNodes() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_RemoveNodes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// State - the control state of the vessel.
//
// Allowed game scenes: any.
func (s *Control) State() (ControlState, error) {
	var err error
	var argBytes []byte
	var vv ControlState
	request := &types.ProcedureCall{
		Procedure: "Control_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the control state of the vessel.
//
// Allowed game scenes: any.
func (s *Control) StateStream() (*krpcgo.Stream[ControlState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ControlState {
		var value ControlState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Source - the source of the vessels control, for example by a kerbal or a
// probe core.
//
// Allowed game scenes: any.
func (s *Control) Source() (ControlSource, error) {
	var err error
	var argBytes []byte
	var vv ControlSource
	request := &types.ProcedureCall{
		Procedure: "Control_get_Source",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SourceStream - the source of the vessels control, for example by a kerbal or
// a probe core.
//
// Allowed game scenes: any.
func (s *Control) SourceStream() (*krpcgo.Stream[ControlSource], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Source",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ControlSource {
		var value ControlSource
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SAS - the state of SAS.
//
// Allowed game scenes: any.
func (s *Control) SAS() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SASStream - the state of SASStream.
//
// Allowed game scenes: any.
func (s *Control) SASStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSAS - the state of SAS.
//
// Allowed game scenes: any.
func (s *Control) SetSAS(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_SAS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SASMode - the current <see cref="T:SpaceCenter.SASMode" />. These modes are
// equivalent to the mode buttons to the left of the navball that appear when
// SAS is enabled.
//
// Allowed game scenes: any.
func (s *Control) SASMode() (SASMode, error) {
	var err error
	var argBytes []byte
	var vv SASMode
	request := &types.ProcedureCall{
		Procedure: "Control_get_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SASModeStream - the current <see cref="T:SpaceCenter.SASModeStream" />. These
// modes are equivalent to the mode buttons to the left of the navball that
// appear when SAS is enabled.
//
// Allowed game scenes: any.
func (s *Control) SASModeStream() (*krpcgo.Stream[SASMode], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) SASMode {
		var value SASMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSASMode - the current <see cref="T:SpaceCenter.SASMode" />. These modes
// are equivalent to the mode buttons to the left of the navball that appear
// when SAS is enabled.
//
// Allowed game scenes: any.
func (s *Control) SetSASMode(value SASMode) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_SASMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SpeedMode - the current <see cref="T:SpaceCenter.SpeedMode" /> of the
// navball. This is the mode displayed next to the speed at the top of the
// navball.
//
// Allowed game scenes: any.
func (s *Control) SpeedMode() (SpeedMode, error) {
	var err error
	var argBytes []byte
	var vv SpeedMode
	request := &types.ProcedureCall{
		Procedure: "Control_get_SpeedMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpeedModeStream - the current <see cref="T:SpaceCenter.SpeedModeStream" /> of
// the navball. This is the mode displayed next to the speed at the top of the
// navball.
//
// Allowed game scenes: any.
func (s *Control) SpeedModeStream() (*krpcgo.Stream[SpeedMode], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_SpeedMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) SpeedMode {
		var value SpeedMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSpeedMode - the current <see cref="T:SpaceCenter.SpeedMode" /> of the
// navball. This is the mode displayed next to the speed at the top of the
// navball.
//
// Allowed game scenes: any.
func (s *Control) SetSpeedMode(value SpeedMode) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_SpeedMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RCS - the state of RCS.
//
// Allowed game scenes: any.
func (s *Control) RCS() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RCSStream - the state of RCSStream.
//
// Allowed game scenes: any.
func (s *Control) RCSStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRCS - the state of RCS.
//
// Allowed game scenes: any.
func (s *Control) SetRCS(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReactionWheels - returns whether all reactive wheels on the vessel are
// active, and sets the active state of all reaction wheels. See <see
// cref="M:SpaceCenter.ReactionWheel.Active" />.
//
// Allowed game scenes: any.
func (s *Control) ReactionWheels() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReactionWheelsStream - returns whether all reactive wheels on the vessel are
// active, and sets the active state of all reaction wheels. See <see
// cref="M:SpaceCenter.ReactionWheel.Active" />.
//
// Allowed game scenes: any.
func (s *Control) ReactionWheelsStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetReactionWheels - returns whether all reactive wheels on the vessel are
// active, and sets the active state of all reaction wheels. See <see
// cref="M:SpaceCenter.ReactionWheel.Active" />.
//
// Allowed game scenes: any.
func (s *Control) SetReactionWheels(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Gear - the state of the landing gear/legs.
//
// Allowed game scenes: any.
func (s *Control) Gear() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Gear",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GearStream - the state of the landing gear/legs.
//
// Allowed game scenes: any.
func (s *Control) GearStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Gear",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetGear - the state of the landing gear/legs.
//
// Allowed game scenes: any.
func (s *Control) SetGear(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Gear",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Legs - returns whether all landing legs on the vessel are deployed, and sets
// the deployment state of all landing legs. Does not include wheels (for
// example landing gear). See <see cref="M:SpaceCenter.Leg.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Legs() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LegsStream - returns whether all landing legs on the vessel are deployed, and
// sets the deployment state of all landing legs. Does not include wheels (for
// example landing gear). See <see cref="M:SpaceCenter.Leg.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) LegsStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLegs - returns whether all landing legs on the vessel are deployed, and
// sets the deployment state of all landing legs. Does not include wheels (for
// example landing gear). See <see cref="M:SpaceCenter.Leg.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetLegs(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Wheels - returns whether all wheels on the vessel are deployed, and sets the
// deployment state of all wheels. Does not include landing legs. See <see
// cref="M:SpaceCenter.Wheel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Wheels() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// WheelsStream - returns whether all wheels on the vessel are deployed, and
// sets the deployment state of all wheels. Does not include landing legs. See
// <see cref="M:SpaceCenter.Wheel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) WheelsStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetWheels - returns whether all wheels on the vessel are deployed, and sets
// the deployment state of all wheels. Does not include landing legs. See <see
// cref="M:SpaceCenter.Wheel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetWheels(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Lights - the state of the lights.
//
// Allowed game scenes: any.
func (s *Control) Lights() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LightsStream - the state of the lights.
//
// Allowed game scenes: any.
func (s *Control) LightsStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLights - the state of the lights.
//
// Allowed game scenes: any.
func (s *Control) SetLights(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Brakes - the state of the wheel brakes.
//
// Allowed game scenes: any.
func (s *Control) Brakes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BrakesStream - the state of the wheel brakes.
//
// Allowed game scenes: any.
func (s *Control) BrakesStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetBrakes - the state of the wheel brakes.
//
// Allowed game scenes: any.
func (s *Control) SetBrakes(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Antennas - returns whether all antennas on the vessel are deployed, and sets
// the deployment state of all antennas. See <see
// cref="M:SpaceCenter.Antenna.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Antennas() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AntennasStream - returns whether all antennas on the vessel are deployed, and
// sets the deployment state of all antennas. See <see
// cref="M:SpaceCenter.Antenna.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) AntennasStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAntennas - returns whether all antennas on the vessel are deployed, and
// sets the deployment state of all antennas. See <see
// cref="M:SpaceCenter.Antenna.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetAntennas(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CargoBays - returns whether any of the cargo bays on the vessel are open, and
// sets the open state of all cargo bays. See <see
// cref="M:SpaceCenter.CargoBay.Open" />.
//
// Allowed game scenes: any.
func (s *Control) CargoBays() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CargoBaysStream - returns whether any of the cargo bays on the vessel are
// open, and sets the open state of all cargo bays. See <see
// cref="M:SpaceCenter.CargoBay.Open" />.
//
// Allowed game scenes: any.
func (s *Control) CargoBaysStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetCargoBays - returns whether any of the cargo bays on the vessel are open,
// and sets the open state of all cargo bays. See <see
// cref="M:SpaceCenter.CargoBay.Open" />.
//
// Allowed game scenes: any.
func (s *Control) SetCargoBays(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Intakes - returns whether all of the air intakes on the vessel are open, and
// sets the open state of all air intakes. See <see
// cref="M:SpaceCenter.Intake.Open" />.
//
// Allowed game scenes: any.
func (s *Control) Intakes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IntakesStream - returns whether all of the air intakes on the vessel are
// open, and sets the open state of all air intakes. See <see
// cref="M:SpaceCenter.Intake.Open" />.
//
// Allowed game scenes: any.
func (s *Control) IntakesStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetIntakes - returns whether all of the air intakes on the vessel are open,
// and sets the open state of all air intakes. See <see
// cref="M:SpaceCenter.Intake.Open" />.
//
// Allowed game scenes: any.
func (s *Control) SetIntakes(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Parachutes - returns whether all parachutes on the vessel are deployed, and
// sets the deployment state of all parachutes. Cannot be set to false. See <see
// cref="M:SpaceCenter.Parachute.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Parachutes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ParachutesStream - returns whether all parachutes on the vessel are deployed,
// and sets the deployment state of all parachutes. Cannot be set to false. See
// <see cref="M:SpaceCenter.Parachute.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) ParachutesStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetParachutes - returns whether all parachutes on the vessel are deployed,
// and sets the deployment state of all parachutes. Cannot be set to false. See
// <see cref="M:SpaceCenter.Parachute.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetParachutes(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Radiators - returns whether all radiators on the vessel are deployed, and
// sets the deployment state of all radiators. See <see
// cref="M:SpaceCenter.Radiator.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) Radiators() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RadiatorsStream - returns whether all radiators on the vessel are deployed,
// and sets the deployment state of all radiators. See <see
// cref="M:SpaceCenter.Radiator.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) RadiatorsStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRadiators - returns whether all radiators on the vessel are deployed, and
// sets the deployment state of all radiators. See <see
// cref="M:SpaceCenter.Radiator.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetRadiators(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ResourceHarvesters - returns whether all of the resource harvesters on the
// vessel are deployed, and sets the deployment state of all resource
// harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) ResourceHarvesters() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ResourceHarvestersStream - returns whether all of the resource harvesters on
// the vessel are deployed, and sets the deployment state of all resource
// harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) ResourceHarvestersStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetResourceHarvesters - returns whether all of the resource harvesters on the
// vessel are deployed, and sets the deployment state of all resource
// harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetResourceHarvesters(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ResourceHarvestersActive - returns whether any of the resource harvesters on
// the vessel are active, and sets the active state of all resource harvesters.
// See <see cref="M:SpaceCenter.ResourceHarvester.Active" />.
//
// Allowed game scenes: any.
func (s *Control) ResourceHarvestersActive() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_ResourceHarvestersActive",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ResourceHarvestersActiveStream - returns whether any of the resource
// harvesters on the vessel are active, and sets the active state of all
// resource harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Active"
// />.
//
// Allowed game scenes: any.
func (s *Control) ResourceHarvestersActiveStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_ResourceHarvestersActive",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetResourceHarvestersActive - returns whether any of the resource harvesters
// on the vessel are active, and sets the active state of all resource
// harvesters. See <see cref="M:SpaceCenter.ResourceHarvester.Active" />.
//
// Allowed game scenes: any.
func (s *Control) SetResourceHarvestersActive(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_ResourceHarvestersActive",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SolarPanels - returns whether all solar panels on the vessel are deployed,
// and sets the deployment state of all solar panels. See <see
// cref="M:SpaceCenter.SolarPanel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SolarPanels() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SolarPanelsStream - returns whether all solar panels on the vessel are
// deployed, and sets the deployment state of all solar panels. See <see
// cref="M:SpaceCenter.SolarPanel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SolarPanelsStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSolarPanels - returns whether all solar panels on the vessel are deployed,
// and sets the deployment state of all solar panels. See <see
// cref="M:SpaceCenter.SolarPanel.Deployed" />.
//
// Allowed game scenes: any.
func (s *Control) SetSolarPanels(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Abort - the state of the abort action group.
//
// Allowed game scenes: any.
func (s *Control) Abort() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_Abort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AbortStream - the state of the abort action group.
//
// Allowed game scenes: any.
func (s *Control) AbortStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Abort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAbort - the state of the abort action group.
//
// Allowed game scenes: any.
func (s *Control) SetAbort(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Abort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Throttle - the state of the throttle. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *Control) Throttle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrottleStream - the state of the throttle. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *Control) ThrottleStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetThrottle - the state of the throttle. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *Control) SetThrottle(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// InputMode - sets the behavior of the pitch, yaw, roll and translation control
// inputs. When set to additive, these inputs are added to the vessels current
// inputs. This mode is the default. When set to override, these inputs (if
// non-zero) override the vessels inputs. This mode prevents keyboard control,
// or SAS, from interfering with the controls when they are set.
//
// Allowed game scenes: any.
func (s *Control) InputMode() (ControlInputMode, error) {
	var err error
	var argBytes []byte
	var vv ControlInputMode
	request := &types.ProcedureCall{
		Procedure: "Control_get_InputMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InputModeStream - sets the behavior of the pitch, yaw, roll and translation
// control inputs. When set to additive, these inputs are added to the vessels
// current inputs. This mode is the default. When set to override, these inputs
// (if non-zero) override the vessels inputs. This mode prevents keyboard
// control, or SAS, from interfering with the controls when they are set.
//
// Allowed game scenes: any.
func (s *Control) InputModeStream() (*krpcgo.Stream[ControlInputMode], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_InputMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ControlInputMode {
		var value ControlInputMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetInputMode - sets the behavior of the pitch, yaw, roll and translation
// control inputs. When set to additive, these inputs are added to the vessels
// current inputs. This mode is the default. When set to override, these inputs
// (if non-zero) override the vessels inputs. This mode prevents keyboard
// control, or SAS, from interfering with the controls when they are set.
//
// Allowed game scenes: any.
func (s *Control) SetInputMode(value ControlInputMode) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_InputMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Pitch - the state of the pitch control. A value between -1 and 1. Equivalent
// to the w and s keys.
//
// Allowed game scenes: any.
func (s *Control) Pitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PitchStream - the state of the pitch control. A value between -1 and 1.
// Equivalent to the w and s keys.
//
// Allowed game scenes: any.
func (s *Control) PitchStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPitch - the state of the pitch control. A value between -1 and 1.
// Equivalent to the w and s keys.
//
// Allowed game scenes: any.
func (s *Control) SetPitch(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Yaw - the state of the yaw control. A value between -1 and 1. Equivalent to
// the a and d keys.
//
// Allowed game scenes: any.
func (s *Control) Yaw() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_Yaw",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// YawStream - the state of the yaw control. A value between -1 and 1.
// Equivalent to the a and d keys.
//
// Allowed game scenes: any.
func (s *Control) YawStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Yaw",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetYaw - the state of the yaw control. A value between -1 and 1. Equivalent
// to the a and d keys.
//
// Allowed game scenes: any.
func (s *Control) SetYaw(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Yaw",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Roll - the state of the roll control. A value between -1 and 1. Equivalent to
// the q and e keys.
//
// Allowed game scenes: any.
func (s *Control) Roll() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RollStream - the state of the roll control. A value between -1 and 1.
// Equivalent to the q and e keys.
//
// Allowed game scenes: any.
func (s *Control) RollStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRoll - the state of the roll control. A value between -1 and 1. Equivalent
// to the q and e keys.
//
// Allowed game scenes: any.
func (s *Control) SetRoll(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Forward - the state of the forward translational control. A value between -1
// and 1. Equivalent to the h and n keys.
//
// Allowed game scenes: any.
func (s *Control) Forward() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_Forward",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ForwardStream - the state of the forward translational control. A value
// between -1 and 1. Equivalent to the h and n keys.
//
// Allowed game scenes: any.
func (s *Control) ForwardStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Forward",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetForward - the state of the forward translational control. A value between
// -1 and 1. Equivalent to the h and n keys.
//
// Allowed game scenes: any.
func (s *Control) SetForward(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Forward",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Up - the state of the up translational control. A value between -1 and 1.
// Equivalent to the i and k keys.
//
// Allowed game scenes: any.
func (s *Control) Up() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_Up",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// UpStream - the state of the up translational control. A value between -1 and
// 1. Equivalent to the i and k keys.
//
// Allowed game scenes: any.
func (s *Control) UpStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Up",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetUp - the state of the up translational control. A value between -1 and 1.
// Equivalent to the i and k keys.
//
// Allowed game scenes: any.
func (s *Control) SetUp(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Up",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Right - the state of the right translational control. A value between -1 and
// 1. Equivalent to the j and l keys.
//
// Allowed game scenes: any.
func (s *Control) Right() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_Right",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RightStream - the state of the right translational control. A value between
// -1 and 1. Equivalent to the j and l keys.
//
// Allowed game scenes: any.
func (s *Control) RightStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Right",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRight - the state of the right translational control. A value between -1
// and 1. Equivalent to the j and l keys.
//
// Allowed game scenes: any.
func (s *Control) SetRight(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_Right",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// WheelThrottle - the state of the wheel throttle. A value between -1 and 1. A
// value of 1 rotates the wheels forwards, a value of -1 rotates the wheels
// backwards.
//
// Allowed game scenes: any.
func (s *Control) WheelThrottle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_WheelThrottle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// WheelThrottleStream - the state of the wheel throttle. A value between -1 and
// 1. A value of 1 rotates the wheels forwards, a value of -1 rotates the wheels
// backwards.
//
// Allowed game scenes: any.
func (s *Control) WheelThrottleStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_WheelThrottle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetWheelThrottle - the state of the wheel throttle. A value between -1 and 1.
// A value of 1 rotates the wheels forwards, a value of -1 rotates the wheels
// backwards.
//
// Allowed game scenes: any.
func (s *Control) SetWheelThrottle(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_WheelThrottle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// WheelSteering - the state of the wheel steering. A value between -1 and 1. A
// value of 1 steers to the left, and a value of -1 steers to the right.
//
// Allowed game scenes: any.
func (s *Control) WheelSteering() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_WheelSteering",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// WheelSteeringStream - the state of the wheel steering. A value between -1 and
// 1. A value of 1 steers to the left, and a value of -1 steers to the right.
//
// Allowed game scenes: any.
func (s *Control) WheelSteeringStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_WheelSteering",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetWheelSteering - the state of the wheel steering. A value between -1 and 1.
// A value of 1 steers to the left, and a value of -1 steers to the right.
//
// Allowed game scenes: any.
func (s *Control) SetWheelSteering(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_WheelSteering",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CustomAxis01 - the state of CustomAxis01. A value between -1 and 1.
//
// Allowed game scenes: any.
func (s *Control) CustomAxis01() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_CustomAxis01",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CustomAxis01Stream - the state of CustomAxis01Stream. A value between -1 and
// 1.
//
// Allowed game scenes: any.
func (s *Control) CustomAxis01Stream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_CustomAxis01",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetCustomAxis01 - the state of CustomAxis01. A value between -1 and 1.
//
// Allowed game scenes: any.
func (s *Control) SetCustomAxis01(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_CustomAxis01",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CustomAxis02 - the state of CustomAxis02. A value between -1 and 1.
//
// Allowed game scenes: any.
func (s *Control) CustomAxis02() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_CustomAxis02",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CustomAxis02Stream - the state of CustomAxis02Stream. A value between -1 and
// 1.
//
// Allowed game scenes: any.
func (s *Control) CustomAxis02Stream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_CustomAxis02",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetCustomAxis02 - the state of CustomAxis02. A value between -1 and 1.
//
// Allowed game scenes: any.
func (s *Control) SetCustomAxis02(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_CustomAxis02",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CustomAxis03 - the state of CustomAxis03. A value between -1 and 1.
//
// Allowed game scenes: any.
func (s *Control) CustomAxis03() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_CustomAxis03",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CustomAxis03Stream - the state of CustomAxis03Stream. A value between -1 and
// 1.
//
// Allowed game scenes: any.
func (s *Control) CustomAxis03Stream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_CustomAxis03",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetCustomAxis03 - the state of CustomAxis03. A value between -1 and 1.
//
// Allowed game scenes: any.
func (s *Control) SetCustomAxis03(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_CustomAxis03",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CustomAxis04 - the state of CustomAxis04. A value between -1 and 1.
//
// Allowed game scenes: any.
func (s *Control) CustomAxis04() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Control_get_CustomAxis04",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CustomAxis04Stream - the state of CustomAxis04Stream. A value between -1 and
// 1.
//
// Allowed game scenes: any.
func (s *Control) CustomAxis04Stream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_CustomAxis04",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetCustomAxis04 - the state of CustomAxis04. A value between -1 and 1.
//
// Allowed game scenes: any.
func (s *Control) SetCustomAxis04(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_CustomAxis04",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CurrentStage - the current stage of the vessel. Corresponds to the stage
// number in the in-game UI.
//
// Allowed game scenes: any.
func (s *Control) CurrentStage() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "Control_get_CurrentStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CurrentStageStream - the current stage of the vessel. Corresponds to the
// stage number in the in-game UI.
//
// Allowed game scenes: any.
func (s *Control) CurrentStageStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_CurrentStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// StageLock - whether staging is locked on the vessel.
//
// Allowed game scenes: any.
func (s *Control) StageLock() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Control_get_StageLock",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StageLockStream - whether staging is locked on the vessel.
//
// Allowed game scenes: any.
func (s *Control) StageLockStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_StageLock",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetStageLock - whether staging is locked on the vessel.
//
// Allowed game scenes: any.
func (s *Control) SetStageLock(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_set_StageLock",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Nodes - returns a list of all existing maneuver nodes, ordered by time from
// first to last.
//
// Allowed game scenes: any.
func (s *Control) Nodes() ([]*Node, error) {
	var err error
	var argBytes []byte
	var vv []*Node
	request := &types.ProcedureCall{
		Procedure: "Control_get_Nodes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// NodesStream - returns a list of all existing maneuver nodes, ordered by time
// from first to last.
//
// Allowed game scenes: any.
func (s *Control) NodesStream() (*krpcgo.Stream[[]*Node], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Control_get_Nodes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Node {
		var value []*Node
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Name - the crew members name.
//
// Allowed game scenes: any.
func (s *CrewMember) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the crew members name.
//
// Allowed game scenes: any.
func (s *CrewMember) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetName - the crew members name.
//
// Allowed game scenes: any.
func (s *CrewMember) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_set_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Type - the type of crew member.
//
// Allowed game scenes: any.
func (s *CrewMember) Type() (CrewMemberType, error) {
	var err error
	var argBytes []byte
	var vv CrewMemberType
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TypeStream - the type of crew member.
//
// Allowed game scenes: any.
func (s *CrewMember) TypeStream() (*krpcgo.Stream[CrewMemberType], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) CrewMemberType {
		var value CrewMemberType
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// OnMission - whether the crew member is on a mission.
//
// Allowed game scenes: any.
func (s *CrewMember) OnMission() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_OnMission",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OnMissionStream - whether the crew member is on a mission.
//
// Allowed game scenes: any.
func (s *CrewMember) OnMissionStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_OnMission",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Courage - the crew members courage.
//
// Allowed game scenes: any.
func (s *CrewMember) Courage() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Courage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CourageStream - the crew members courage.
//
// Allowed game scenes: any.
func (s *CrewMember) CourageStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Courage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetCourage - the crew members courage.
//
// Allowed game scenes: any.
func (s *CrewMember) SetCourage(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_set_Courage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Stupidity - the crew members stupidity.
//
// Allowed game scenes: any.
func (s *CrewMember) Stupidity() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Stupidity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StupidityStream - the crew members stupidity.
//
// Allowed game scenes: any.
func (s *CrewMember) StupidityStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Stupidity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetStupidity - the crew members stupidity.
//
// Allowed game scenes: any.
func (s *CrewMember) SetStupidity(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_set_Stupidity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Experience - the crew members experience.
//
// Allowed game scenes: any.
func (s *CrewMember) Experience() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Experience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ExperienceStream - the crew members experience.
//
// Allowed game scenes: any.
func (s *CrewMember) ExperienceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Experience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetExperience - the crew members experience.
//
// Allowed game scenes: any.
func (s *CrewMember) SetExperience(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_set_Experience",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Badass - whether the crew member is a badass.
//
// Allowed game scenes: any.
func (s *CrewMember) Badass() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Badass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BadassStream - whether the crew member is a badass.
//
// Allowed game scenes: any.
func (s *CrewMember) BadassStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Badass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetBadass - whether the crew member is a badass.
//
// Allowed game scenes: any.
func (s *CrewMember) SetBadass(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_set_Badass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Veteran - whether the crew member is a veteran.
//
// Allowed game scenes: any.
func (s *CrewMember) Veteran() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Veteran",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VeteranStream - whether the crew member is a veteran.
//
// Allowed game scenes: any.
func (s *CrewMember) VeteranStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Veteran",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetVeteran - whether the crew member is a veteran.
//
// Allowed game scenes: any.
func (s *CrewMember) SetVeteran(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_set_Veteran",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Trait - the crew member's job.
//
// Allowed game scenes: any.
func (s *CrewMember) Trait() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Trait",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TraitStream - the crew member's job.
//
// Allowed game scenes: any.
func (s *CrewMember) TraitStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Trait",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Gender - the crew member's gender.
//
// Allowed game scenes: any.
func (s *CrewMember) Gender() (CrewMemberGender, error) {
	var err error
	var argBytes []byte
	var vv CrewMemberGender
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Gender",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GenderStream - the crew member's gender.
//
// Allowed game scenes: any.
func (s *CrewMember) GenderStream() (*krpcgo.Stream[CrewMemberGender], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_Gender",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) CrewMemberGender {
		var value CrewMemberGender
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RosterStatus - the crew member's current roster status.
//
// Allowed game scenes: any.
func (s *CrewMember) RosterStatus() (RosterStatus, error) {
	var err error
	var argBytes []byte
	var vv RosterStatus
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_RosterStatus",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RosterStatusStream - the crew member's current roster status.
//
// Allowed game scenes: any.
func (s *CrewMember) RosterStatusStream() (*krpcgo.Stream[RosterStatus], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_RosterStatus",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) RosterStatus {
		var value RosterStatus
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SuitType - the crew member's suit type.
//
// Allowed game scenes: any.
func (s *CrewMember) SuitType() (SuitType, error) {
	var err error
	var argBytes []byte
	var vv SuitType
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_SuitType",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SuitTypeStream - the crew member's suit type.
//
// Allowed game scenes: any.
func (s *CrewMember) SuitTypeStream() (*krpcgo.Stream[SuitType], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_SuitType",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) SuitType {
		var value SuitType
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSuitType - the crew member's suit type.
//
// Allowed game scenes: any.
func (s *CrewMember) SetSuitType(value SuitType) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_set_SuitType",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CareerLogFlights - the flight IDs for each entry in the career flight log.
//
// Allowed game scenes: any.
func (s *CrewMember) CareerLogFlights() ([]int32, error) {
	var err error
	var argBytes []byte
	var vv []int32
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_CareerLogFlights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CareerLogFlightsStream - the flight IDs for each entry in the career flight
// log.
//
// Allowed game scenes: any.
func (s *CrewMember) CareerLogFlightsStream() (*krpcgo.Stream[[]int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_CareerLogFlights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []int32 {
		var value []int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CareerLogTypes - the type for each entry in the career flight log.
//
// Allowed game scenes: any.
func (s *CrewMember) CareerLogTypes() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_CareerLogTypes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CareerLogTypesStream - the type for each entry in the career flight log.
//
// Allowed game scenes: any.
func (s *CrewMember) CareerLogTypesStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_CareerLogTypes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CareerLogTargets - the body name for each entry in the career flight log.
//
// Allowed game scenes: any.
func (s *CrewMember) CareerLogTargets() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_CareerLogTargets",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CareerLogTargetsStream - the body name for each entry in the career flight
// log.
//
// Allowed game scenes: any.
func (s *CrewMember) CareerLogTargetsStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CrewMember_get_CareerLogTargets",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SimulateAerodynamicForceAt - simulate and return the total aerodynamic forces
// acting on the vessel, if it where to be traveling with the given velocity at
// the given position in the atmosphere of the given celestial body.
//
// Allowed game scenes: any.
func (s *Flight) SimulateAerodynamicForceAt(body *CelestialBody, position types.Tuple3[float64, float64, float64], velocity types.Tuple3[float64, float64, float64]) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_SimulateAerodynamicForceAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SimulateAerodynamicForceAtStream - simulate and return the total aerodynamic
// forces acting on the vessel, if it where to be traveling with the given
// velocity at the given position in the atmosphere of the given celestial body.
//
// Allowed game scenes: any.
func (s *Flight) SimulateAerodynamicForceAtStream(body *CelestialBody, position types.Tuple3[float64, float64, float64], velocity types.Tuple3[float64, float64, float64]) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_SimulateAerodynamicForceAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// GForce - the current G force acting on the vessel in <math>g</math>.
//
// Allowed game scenes: any.
func (s *Flight) GForce() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_GForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GForceStream - the current G force acting on the vessel in <math>g</math>.
//
// Allowed game scenes: any.
func (s *Flight) GForceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_GForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MeanAltitude - the altitude above sea level, in meters. Measured from the
// center of mass of the vessel.
//
// Allowed game scenes: any.
func (s *Flight) MeanAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Flight_get_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MeanAltitudeStream - the altitude above sea level, in meters. Measured from
// the center of mass of the vessel.
//
// Allowed game scenes: any.
func (s *Flight) MeanAltitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SurfaceAltitude - the altitude above the surface of the body or sea level,
// whichever is closer, in meters. Measured from the center of mass of the
// vessel.
//
// Allowed game scenes: any.
func (s *Flight) SurfaceAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Flight_get_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SurfaceAltitudeStream - the altitude above the surface of the body or sea
// level, whichever is closer, in meters. Measured from the center of mass of
// the vessel.
//
// Allowed game scenes: any.
func (s *Flight) SurfaceAltitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// BedrockAltitude - the altitude above the surface of the body, in meters. When
// over water, this is the altitude above the sea floor. Measured from the
// center of mass of the vessel.
//
// Allowed game scenes: any.
func (s *Flight) BedrockAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Flight_get_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BedrockAltitudeStream - the altitude above the surface of the body, in
// meters. When over water, this is the altitude above the sea floor. Measured
// from the center of mass of the vessel.
//
// Allowed game scenes: any.
func (s *Flight) BedrockAltitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Elevation - the elevation of the terrain under the vessel, in meters. This is
// the height of the terrain above sea level, and is negative when the vessel is
// over the sea.
//
// Allowed game scenes: any.
func (s *Flight) Elevation() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Elevation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ElevationStream - the elevation of the terrain under the vessel, in meters.
// This is the height of the terrain above sea level, and is negative when the
// vessel is over the sea.
//
// Allowed game scenes: any.
func (s *Flight) ElevationStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Elevation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Latitude - the <a href="https://en.wikipedia.org/wiki/Latitude">latitude</a>
// of the vessel for the body being orbited, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) Latitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LatitudeStream - the <a
// href="https://en.wikipedia.org/wiki/LatitudeStream">latitude</a> of the
// vessel for the body being orbited, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) LatitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Longitude - the <a
// href="https://en.wikipedia.org/wiki/Longitude">longitude</a> of the vessel
// for the body being orbited, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) Longitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LongitudeStream - the <a
// href="https://en.wikipedia.org/wiki/LongitudeStream">longitude</a> of the
// vessel for the body being orbited, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) LongitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Velocity - the velocity of the vessel, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Velocity() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VelocityStream - the velocity of the vessel, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) VelocityStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Speed - the speed of the vessel in meters per second, in the reference frame
// <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Speed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpeedStream - the speed of the vessel in meters per second, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) SpeedStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HorizontalSpeed - the horizontal speed of the vessel in meters per second, in
// the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) HorizontalSpeed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Flight_get_HorizontalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HorizontalSpeedStream - the horizontal speed of the vessel in meters per
// second, in the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) HorizontalSpeedStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_HorizontalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// VerticalSpeed - the vertical speed of the vessel in meters per second, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) VerticalSpeed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Flight_get_VerticalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VerticalSpeedStream - the vertical speed of the vessel in meters per second,
// in the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) VerticalSpeedStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_VerticalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CenterOfMass - the position of the center of mass of the vessel, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />
//
// Allowed game scenes: any.
func (s *Flight) CenterOfMass() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_CenterOfMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CenterOfMassStream - the position of the center of mass of the vessel, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />
//
// Allowed game scenes: any.
func (s *Flight) CenterOfMassStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_CenterOfMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rotation - the rotation of the vessel, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />
//
// Allowed game scenes: any.
func (s *Flight) Rotation() (types.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple4[float64, float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationStream - the rotation of the vessel, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />
//
// Allowed game scenes: any.
func (s *Flight) RotationStream() (*krpcgo.Stream[types.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple4[float64, float64, float64, float64] {
		var value types.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Direction - the direction that the vessel is pointing in, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Direction() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DirectionStream - the direction that the vessel is pointing in, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) DirectionStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Pitch - the pitch of the vessel relative to the horizon, in degrees. A value
// between -90° and +90°.
//
// Allowed game scenes: any.
func (s *Flight) Pitch() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PitchStream - the pitch of the vessel relative to the horizon, in degrees. A
// value between -90° and +90°.
//
// Allowed game scenes: any.
func (s *Flight) PitchStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Pitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Heading - the heading of the vessel (its angle relative to north), in
// degrees. A value between 0° and 360°.
//
// Allowed game scenes: any.
func (s *Flight) Heading() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HeadingStream - the heading of the vessel (its angle relative to north), in
// degrees. A value between 0° and 360°.
//
// Allowed game scenes: any.
func (s *Flight) HeadingStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Heading",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Roll - the roll of the vessel relative to the horizon, in degrees. A value
// between -180° and +180°.
//
// Allowed game scenes: any.
func (s *Flight) Roll() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RollStream - the roll of the vessel relative to the horizon, in degrees. A
// value between -180° and +180°.
//
// Allowed game scenes: any.
func (s *Flight) RollStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Roll",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Prograde - the prograde direction of the vessels orbit, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Prograde() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ProgradeStream - the prograde direction of the vessels orbit, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) ProgradeStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Retrograde - the retrograde direction of the vessels orbit, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Retrograde() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Retrograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RetrogradeStream - the retrograde direction of the vessels orbit, in the
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) RetrogradeStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Retrograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Normal - the direction normal to the vessels orbit, in the reference frame
// <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Normal() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NormalStream - the direction normal to the vessels orbit, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) NormalStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AntiNormal - the direction opposite to the normal of the vessels orbit, in
// the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) AntiNormal() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AntiNormal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AntiNormalStream - the direction opposite to the normal of the vessels orbit,
// in the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) AntiNormalStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AntiNormal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Radial - the radial direction of the vessels orbit, in the reference frame
// <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) Radial() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RadialStream - the radial direction of the vessels orbit, in the reference
// frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) RadialStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AntiRadial - the direction opposite to the radial direction of the vessels
// orbit, in the reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) AntiRadial() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AntiRadial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AntiRadialStream - the direction opposite to the radial direction of the
// vessels orbit, in the reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) AntiRadialStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AntiRadial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AtmosphereDensity - the current density of the atmosphere around the vessel,
// in <math>kg/m^3</math>.
//
// Allowed game scenes: any.
func (s *Flight) AtmosphereDensity() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AtmosphereDensity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AtmosphereDensityStream - the current density of the atmosphere around the
// vessel, in <math>kg/m^3</math>.
//
// Allowed game scenes: any.
func (s *Flight) AtmosphereDensityStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AtmosphereDensity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DynamicPressure - the dynamic pressure acting on the vessel, in Pascals. This
// is a measure of the strength of the aerodynamic forces. It is equal to
// <math>\frac{1}{2} . \mbox{air density} . \mbox{velocity}^2</math>. It is
// commonly denoted <math>Q</math>.
//
// Allowed game scenes: any.
func (s *Flight) DynamicPressure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_DynamicPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DynamicPressureStream - the dynamic pressure acting on the vessel, in
// Pascals. This is a measure of the strength of the aerodynamic forces. It is
// equal to <math>\frac{1}{2} . \mbox{air density} . \mbox{velocity}^2</math>.
// It is commonly denoted <math>Q</math>.
//
// Allowed game scenes: any.
func (s *Flight) DynamicPressureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_DynamicPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// StaticPressureAtMSL - the static atmospheric pressure at mean sea level, in
// Pascals.
//
// Allowed game scenes: any.
func (s *Flight) StaticPressureAtMSL() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_StaticPressureAtMSL",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StaticPressureAtMSLStream - the static atmospheric pressure at mean sea
// level, in Pascals.
//
// Allowed game scenes: any.
func (s *Flight) StaticPressureAtMSLStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_StaticPressureAtMSL",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// StaticPressure - the static atmospheric pressure acting on the vessel, in
// Pascals.
//
// Allowed game scenes: any.
func (s *Flight) StaticPressure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_StaticPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StaticPressureStream - the static atmospheric pressure acting on the vessel,
// in Pascals.
//
// Allowed game scenes: any.
func (s *Flight) StaticPressureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_StaticPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AerodynamicForce - the total aerodynamic forces acting on the vessel, in
// reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) AerodynamicForce() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AerodynamicForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AerodynamicForceStream - the total aerodynamic forces acting on the vessel,
// in reference frame <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Flight) AerodynamicForceStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AerodynamicForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Lift - the <a
// href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic lift</a>
// currently acting on the vessel.
//
// Allowed game scenes: any.
func (s *Flight) Lift() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Lift",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LiftStream - the <a
// href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic lift</a>
// currently acting on the vessel.
//
// Allowed game scenes: any.
func (s *Flight) LiftStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Lift",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Drag - the <a
// href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic drag</a>
// currently acting on the vessel.
//
// Allowed game scenes: any.
func (s *Flight) Drag() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Drag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DragStream - the <a
// href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic drag</a>
// currently acting on the vessel.
//
// Allowed game scenes: any.
func (s *Flight) DragStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Drag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SpeedOfSound - the speed of sound, in the atmosphere around the vessel, in
// <math>m/s</math>.
//
// Allowed game scenes: any.
func (s *Flight) SpeedOfSound() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_SpeedOfSound",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpeedOfSoundStream - the speed of sound, in the atmosphere around the vessel,
// in <math>m/s</math>.
//
// Allowed game scenes: any.
func (s *Flight) SpeedOfSoundStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_SpeedOfSound",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Mach - the speed of the vessel, in multiples of the speed of sound.
//
// Allowed game scenes: any.
func (s *Flight) Mach() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Mach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MachStream - the speed of the vessel, in multiples of the speed of sound.
//
// Allowed game scenes: any.
func (s *Flight) MachStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_Mach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReynoldsNumber - the vessels Reynolds number.
//
// Allowed game scenes: any.
func (s *Flight) ReynoldsNumber() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_ReynoldsNumber",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReynoldsNumberStream - the vessels Reynolds number.
//
// Allowed game scenes: any.
func (s *Flight) ReynoldsNumberStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_ReynoldsNumber",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TrueAirSpeed - the <a href="https://en.wikipedia.org/wiki/True_airspeed">true
// air speed</a> of the vessel, in meters per second.
//
// Allowed game scenes: any.
func (s *Flight) TrueAirSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_TrueAirSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TrueAirSpeedStream - the <a
// href="https://en.wikipedia.org/wiki/True_airspeed">true air speed</a> of the
// vessel, in meters per second.
//
// Allowed game scenes: any.
func (s *Flight) TrueAirSpeedStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_TrueAirSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// EquivalentAirSpeed - the <a
// href="https://en.wikipedia.org/wiki/Equivalent_airspeed">equivalent air
// speed</a> of the vessel, in meters per second.
//
// Allowed game scenes: any.
func (s *Flight) EquivalentAirSpeed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_EquivalentAirSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EquivalentAirSpeedStream - the <a
// href="https://en.wikipedia.org/wiki/Equivalent_airspeed">equivalent air
// speed</a> of the vessel, in meters per second.
//
// Allowed game scenes: any.
func (s *Flight) EquivalentAirSpeedStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_EquivalentAirSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TerminalVelocity - an estimate of the current terminal velocity of the
// vessel, in meters per second. This is the speed at which the drag forces
// cancel out the force of gravity.
//
// Allowed game scenes: any.
func (s *Flight) TerminalVelocity() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_TerminalVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TerminalVelocityStream - an estimate of the current terminal velocity of the
// vessel, in meters per second. This is the speed at which the drag forces
// cancel out the force of gravity.
//
// Allowed game scenes: any.
func (s *Flight) TerminalVelocityStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_TerminalVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AngleOfAttack - the pitch angle between the orientation of the vessel and its
// velocity vector, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) AngleOfAttack() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AngleOfAttack",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AngleOfAttackStream - the pitch angle between the orientation of the vessel
// and its velocity vector, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) AngleOfAttackStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_AngleOfAttack",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SideslipAngle - the yaw angle between the orientation of the vessel and its
// velocity vector, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) SideslipAngle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_SideslipAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SideslipAngleStream - the yaw angle between the orientation of the vessel and
// its velocity vector, in degrees.
//
// Allowed game scenes: any.
func (s *Flight) SideslipAngleStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_SideslipAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TotalAirTemperature - the <a
// href="https://en.wikipedia.org/wiki/Total_air_temperature">total air
// temperature</a> of the atmosphere around the vessel, in Kelvin. This includes
// the <see cref="M:SpaceCenter.Flight.StaticAirTemperature" /> and the vessel's
// kinetic energy.
//
// Allowed game scenes: any.
func (s *Flight) TotalAirTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_TotalAirTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TotalAirTemperatureStream - the <a
// href="https://en.wikipedia.org/wiki/Total_air_temperature">total air
// temperature</a> of the atmosphere around the vessel, in Kelvin. This includes
// the <see cref="M:SpaceCenter.Flight.StaticAirTemperature" /> and the vessel's
// kinetic energy.
//
// Allowed game scenes: any.
func (s *Flight) TotalAirTemperatureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_TotalAirTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// StaticAirTemperature - the <a
// href="https://en.wikipedia.org/wiki/Total_air_temperature">static (ambient)
// temperature</a> of the atmosphere around the vessel, in Kelvin.
//
// Allowed game scenes: any.
func (s *Flight) StaticAirTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_StaticAirTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StaticAirTemperatureStream - the <a
// href="https://en.wikipedia.org/wiki/Total_air_temperature">static (ambient)
// temperature</a> of the atmosphere around the vessel, in Kelvin.
//
// Allowed game scenes: any.
func (s *Flight) StaticAirTemperatureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_StaticAirTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// StallFraction - the current amount of stall, between 0 and 1. A value greater
// than 0.005 indicates a minor stall and a value greater than 0.5 indicates a
// large-scale stall.
//
// Allowed game scenes: any.
func (s *Flight) StallFraction() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_StallFraction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StallFractionStream - the current amount of stall, between 0 and 1. A value
// greater than 0.005 indicates a minor stall and a value greater than 0.5
// indicates a large-scale stall.
//
// Allowed game scenes: any.
func (s *Flight) StallFractionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_StallFraction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DragCoefficient - the coefficient of drag. This is the amount of drag
// produced by the vessel. It depends on air speed, air density and wing area.
//
// Allowed game scenes: any.
func (s *Flight) DragCoefficient() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_DragCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DragCoefficientStream - the coefficient of drag. This is the amount of drag
// produced by the vessel. It depends on air speed, air density and wing area.
//
// Allowed game scenes: any.
func (s *Flight) DragCoefficientStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_DragCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// LiftCoefficient - the coefficient of lift. This is the amount of lift
// produced by the vessel, and depends on air speed, air density and wing area.
//
// Allowed game scenes: any.
func (s *Flight) LiftCoefficient() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_LiftCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LiftCoefficientStream - the coefficient of lift. This is the amount of lift
// produced by the vessel, and depends on air speed, air density and wing area.
//
// Allowed game scenes: any.
func (s *Flight) LiftCoefficientStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_LiftCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// BallisticCoefficient - the <a
// href="https://en.wikipedia.org/wiki/Ballistic_coefficient">ballistic
// coefficient</a>.
//
// Allowed game scenes: any.
func (s *Flight) BallisticCoefficient() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_BallisticCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BallisticCoefficientStream - the <a
// href="https://en.wikipedia.org/wiki/Ballistic_coefficient">ballistic
// coefficient</a>.
//
// Allowed game scenes: any.
func (s *Flight) BallisticCoefficientStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_BallisticCoefficient",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThrustSpecificFuelConsumption - the thrust specific fuel consumption for the
// jet engines on the vessel. This is a measure of the efficiency of the
// engines, with a lower value indicating a more efficient vessel. This value is
// the number of Newtons of fuel that are burned, per hour, to produce one
// newton of thrust.
//
// Allowed game scenes: any.
func (s *Flight) ThrustSpecificFuelConsumption() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Flight_get_ThrustSpecificFuelConsumption",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrustSpecificFuelConsumptionStream - the thrust specific fuel consumption
// for the jet engines on the vessel. This is a measure of the efficiency of the
// engines, with a lower value indicating a more efficient vessel. This value is
// the number of Newtons of fuel that are burned, per hour, to produce one
// newton of thrust.
//
// Allowed game scenes: any.
func (s *Flight) ThrustSpecificFuelConsumptionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Flight_get_ThrustSpecificFuelConsumption",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Name - the name of the launch site.
//
// Allowed game scenes: any.
func (s *LaunchSite) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "LaunchSite_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the name of the launch site.
//
// Allowed game scenes: any.
func (s *LaunchSite) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "LaunchSite_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Body - the celestial body the launch site is on.
//
// Allowed game scenes: any.
func (s *LaunchSite) Body() (*CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv CelestialBody
	request := &types.ProcedureCall{
		Procedure: "LaunchSite_get_Body",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// EditorFacility - which editor is normally used for this launch site.
//
// Allowed game scenes: any.
func (s *LaunchSite) EditorFacility() (EditorFacility, error) {
	var err error
	var argBytes []byte
	var vv EditorFacility
	request := &types.ProcedureCall{
		Procedure: "LaunchSite_get_EditorFacility",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EditorFacilityStream - which editor is normally used for this launch site.
//
// Allowed game scenes: any.
func (s *LaunchSite) EditorFacilityStream() (*krpcgo.Stream[EditorFacility], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "LaunchSite_get_EditorFacility",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) EditorFacility {
		var value EditorFacility
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// BurnVector - returns the burn vector for the maneuver node.
//
// Allowed game scenes: any.
func (s *Node) BurnVector(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Node_BurnVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BurnVectorStream - returns the burn vector for the maneuver node.
//
// Allowed game scenes: any.
func (s *Node) BurnVectorStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_BurnVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RemainingBurnVector - returns the remaining burn vector for the maneuver
// node.
//
// Allowed game scenes: any.
func (s *Node) RemainingBurnVector(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Node_RemainingBurnVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RemainingBurnVectorStream - returns the remaining burn vector for the
// maneuver node.
//
// Allowed game scenes: any.
func (s *Node) RemainingBurnVectorStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_RemainingBurnVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Remove - removes the maneuver node.
//
// Allowed game scenes: any.
func (s *Node) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_Remove",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position - the position vector of the maneuver node in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *Node) Position(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Node_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionStream - the position vector of the maneuver node in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Node) PositionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Direction - the direction of the maneuver nodes burn.
//
// Allowed game scenes: any.
func (s *Node) Direction(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Node_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DirectionStream - the direction of the maneuver nodes burn.
//
// Allowed game scenes: any.
func (s *Node) DirectionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Prograde - the magnitude of the maneuver nodes delta-v in the prograde
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) Prograde() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Node_get_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ProgradeStream - the magnitude of the maneuver nodes delta-v in the prograde
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) ProgradeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_get_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPrograde - the magnitude of the maneuver nodes delta-v in the prograde
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) SetPrograde(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_set_Prograde",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Normal - the magnitude of the maneuver nodes delta-v in the normal direction,
// in meters per second.
//
// Allowed game scenes: any.
func (s *Node) Normal() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Node_get_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NormalStream - the magnitude of the maneuver nodes delta-v in the normal
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) NormalStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_get_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetNormal - the magnitude of the maneuver nodes delta-v in the normal
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) SetNormal(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_set_Normal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Radial - the magnitude of the maneuver nodes delta-v in the radial direction,
// in meters per second.
//
// Allowed game scenes: any.
func (s *Node) Radial() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Node_get_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RadialStream - the magnitude of the maneuver nodes delta-v in the radial
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) RadialStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_get_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRadial - the magnitude of the maneuver nodes delta-v in the radial
// direction, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) SetRadial(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_set_Radial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// DeltaV - the delta-v of the maneuver node, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) DeltaV() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Node_get_DeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeltaVStream - the delta-v of the maneuver node, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) DeltaVStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_get_DeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeltaV - the delta-v of the maneuver node, in meters per second.
//
// Allowed game scenes: any.
func (s *Node) SetDeltaV(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_set_DeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RemainingDeltaV - gets the remaining delta-v of the maneuver node, in meters
// per second. Changes as the node is executed. This is equivalent to the
// delta-v reported in-game.
//
// Allowed game scenes: any.
func (s *Node) RemainingDeltaV() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Node_get_RemainingDeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RemainingDeltaVStream - gets the remaining delta-v of the maneuver node, in
// meters per second. Changes as the node is executed. This is equivalent to the
// delta-v reported in-game.
//
// Allowed game scenes: any.
func (s *Node) RemainingDeltaVStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_get_RemainingDeltaV",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// UT - the universal time at which the maneuver will occur, in seconds.
//
// Allowed game scenes: any.
func (s *Node) UT() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Node_get_UT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// UTStream - the universal time at which the maneuver will occur, in seconds.
//
// Allowed game scenes: any.
func (s *Node) UTStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_get_UT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetUT - the universal time at which the maneuver will occur, in seconds.
//
// Allowed game scenes: any.
func (s *Node) SetUT(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_set_UT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TimeTo - the time until the maneuver node will be encountered, in seconds.
//
// Allowed game scenes: any.
func (s *Node) TimeTo() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Node_get_TimeTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TimeToStream - the time until the maneuver node will be encountered, in
// seconds.
//
// Allowed game scenes: any.
func (s *Node) TimeToStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Node_get_TimeTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Orbit - the orbit that results from executing the maneuver node.
//
// Allowed game scenes: any.
func (s *Node) Orbit() (*Orbit, error) {
	var err error
	var argBytes []byte
	var vv Orbit
	request := &types.ProcedureCall{
		Procedure: "Node_get_Orbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ReferenceFrame - the reference frame that is fixed relative to the maneuver
// node's burn. <list type="bullet"><item><description>The origin is at the
// position of the maneuver node.</description></item><item><description>The
// y-axis points in the direction of the
// burn.</description></item><item><description>The x-axis and z-axis point in
// arbitrary but fixed directions.</description></item></list>
//
// Allowed game scenes: any.
func (s *Node) ReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Node_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// OrbitalReferenceFrame - the reference frame that is fixed relative to the
// maneuver node, and orientated with the orbital prograde/normal/radial
// directions of the original orbit at the maneuver node's position. <list
// type="bullet"><item><description>The origin is at the position of the
// maneuver node.</description></item><item><description>The x-axis points in
// the orbital anti-radial direction of the original orbit, at the position of
// the maneuver node.</description></item><item><description>The y-axis points
// in the orbital prograde direction of the original orbit, at the position of
// the maneuver node.</description></item><item><description>The z-axis points
// in the orbital normal direction of the original orbit, at the position of the
// maneuver node.</description></item></list>
//
// Allowed game scenes: any.
func (s *Node) OrbitalReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Node_get_OrbitalReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ReferencePlaneNormal - the direction that is normal to the orbits reference
// plane, in the given reference frame. The reference plane is the plane from
// which the orbits inclination is measured.
//
// Allowed game scenes: any.
func (s *Orbit) ReferencePlaneNormal() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Orbit_static_ReferencePlaneNormal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReferencePlaneNormalStream - the direction that is normal to the orbits
// reference plane, in the given reference frame. The reference plane is the
// plane from which the orbits inclination is measured.
//
// Allowed game scenes: any.
func (s *Orbit) ReferencePlaneNormalStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_static_ReferencePlaneNormal",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReferencePlaneDirection - the direction from which the orbits longitude of
// ascending node is measured, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Orbit) ReferencePlaneDirection() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Orbit_static_ReferencePlaneDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReferencePlaneDirectionStream - the direction from which the orbits longitude
// of ascending node is measured, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Orbit) ReferencePlaneDirectionStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_static_ReferencePlaneDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MeanAnomalyAtUT - the mean anomaly at the given time.
//
// Allowed game scenes: any.
func (s *Orbit) MeanAnomalyAtUT(ut float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_MeanAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MeanAnomalyAtUTStream - the mean anomaly at the given time.
//
// Allowed game scenes: any.
func (s *Orbit) MeanAnomalyAtUTStream(ut float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_MeanAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RadiusAtTrueAnomaly - the orbital radius at the point in the orbit given by
// the true anomaly.
//
// Allowed game scenes: any.
func (s *Orbit) RadiusAtTrueAnomaly(trueAnomaly float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_RadiusAtTrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(trueAnomaly)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RadiusAtTrueAnomalyStream - the orbital radius at the point in the orbit
// given by the true anomaly.
//
// Allowed game scenes: any.
func (s *Orbit) RadiusAtTrueAnomalyStream(trueAnomaly float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_RadiusAtTrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(trueAnomaly)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TrueAnomalyAtRadius - the true anomaly at the given orbital radius.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtRadius(radius float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtRadius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(radius)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TrueAnomalyAtRadiusStream - the true anomaly at the given orbital radius.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtRadiusStream(radius float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtRadius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(radius)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TrueAnomalyAtUT - the true anomaly at the given time.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtUT(ut float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TrueAnomalyAtUTStream - the true anomaly at the given time.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtUTStream(ut float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// UTAtTrueAnomaly - the universal time, in seconds, corresponding to the given
// true anomaly.
//
// Allowed game scenes: any.
func (s *Orbit) UTAtTrueAnomaly(trueAnomaly float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_UTAtTrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(trueAnomaly)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// UTAtTrueAnomalyStream - the universal time, in seconds, corresponding to the
// given true anomaly.
//
// Allowed game scenes: any.
func (s *Orbit) UTAtTrueAnomalyStream(trueAnomaly float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_UTAtTrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(trueAnomaly)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// EccentricAnomalyAtUT - the eccentric anomaly at the given universal time.
//
// Allowed game scenes: any.
func (s *Orbit) EccentricAnomalyAtUT(ut float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_EccentricAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EccentricAnomalyAtUTStream - the eccentric anomaly at the given universal
// time.
//
// Allowed game scenes: any.
func (s *Orbit) EccentricAnomalyAtUTStream(ut float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_EccentricAnomalyAtUT",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// OrbitalSpeedAt - the orbital speed at the given time, in meters per second.
//
// Allowed game scenes: any.
func (s *Orbit) OrbitalSpeedAt(time float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_OrbitalSpeedAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(time)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OrbitalSpeedAtStream - the orbital speed at the given time, in meters per
// second.
//
// Allowed game scenes: any.
func (s *Orbit) OrbitalSpeedAtStream(time float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_OrbitalSpeedAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(time)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RadiusAt - the orbital radius at the given time, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) RadiusAt(ut float64) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_RadiusAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RadiusAtStream - the orbital radius at the given time, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) RadiusAtStream(ut float64) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_RadiusAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PositionAt - the position at a given time, in the specified reference frame.
//
// Allowed game scenes: any.
func (s *Orbit) PositionAt(ut float64, referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Orbit_PositionAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionAtStream - the position at a given time, in the specified reference
// frame.
//
// Allowed game scenes: any.
func (s *Orbit) PositionAtStream(ut float64, referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_PositionAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(ut)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TimeOfClosestApproach - estimates and returns the time at closest approach to
// a target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) TimeOfClosestApproach(target *Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_TimeOfClosestApproach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TimeOfClosestApproachStream - estimates and returns the time at closest
// approach to a target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) TimeOfClosestApproachStream(target *Orbit) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_TimeOfClosestApproach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DistanceAtClosestApproach - estimates and returns the distance at closest
// approach to a target orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) DistanceAtClosestApproach(target *Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_DistanceAtClosestApproach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DistanceAtClosestApproachStream - estimates and returns the distance at
// closest approach to a target orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) DistanceAtClosestApproachStream(target *Orbit) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_DistanceAtClosestApproach",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ListClosestApproaches - returns the times at closest approach and
// corresponding distances, to a target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) ListClosestApproaches(target *Orbit, orbits int32) ([][]float64, error) {
	var err error
	var argBytes []byte
	var vv [][]float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_ListClosestApproaches",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(orbits)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ListClosestApproachesStream - returns the times at closest approach and
// corresponding distances, to a target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) ListClosestApproachesStream(target *Orbit, orbits int32) (*krpcgo.Stream[[][]float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_ListClosestApproaches",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(orbits)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) [][]float64 {
		var value [][]float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TrueAnomalyAtAN - the true anomaly of the ascending node with the given
// target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtAN(target *Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtAN",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TrueAnomalyAtANStream - the true anomaly of the ascending node with the given
// target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtANStream(target *Orbit) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtAN",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TrueAnomalyAtDN - the true anomaly of the descending node with the given
// target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtDN(target *Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtDN",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TrueAnomalyAtDNStream - the true anomaly of the descending node with the
// given target orbit.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyAtDNStream(target *Orbit) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_TrueAnomalyAtDN",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RelativeInclination - relative inclination of this orbit and the target
// orbit, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) RelativeInclination(target *Orbit) (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_RelativeInclination",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RelativeInclinationStream - relative inclination of this orbit and the target
// orbit, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) RelativeInclinationStream(target *Orbit) (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_RelativeInclination",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(target)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Body - the celestial body (e.g. planet or moon) around which the object is
// orbiting.
//
// Allowed game scenes: any.
func (s *Orbit) Body() (*CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv CelestialBody
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Body",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Apoapsis - gets the apoapsis of the orbit, in meters, from the center of mass
// of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) Apoapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Apoapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ApoapsisStream - gets the apoapsis of the orbit, in meters, from the center
// of mass of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) ApoapsisStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Apoapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Periapsis - the periapsis of the orbit, in meters, from the center of mass of
// the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) Periapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Periapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PeriapsisStream - the periapsis of the orbit, in meters, from the center of
// mass of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) PeriapsisStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Periapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ApoapsisAltitude - the apoapsis of the orbit, in meters, above the sea level
// of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) ApoapsisAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_ApoapsisAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ApoapsisAltitudeStream - the apoapsis of the orbit, in meters, above the sea
// level of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) ApoapsisAltitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_ApoapsisAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PeriapsisAltitude - the periapsis of the orbit, in meters, above the sea
// level of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) PeriapsisAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_PeriapsisAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PeriapsisAltitudeStream - the periapsis of the orbit, in meters, above the
// sea level of the body being orbited.
//
// Allowed game scenes: any.
func (s *Orbit) PeriapsisAltitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_PeriapsisAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SemiMajorAxis - the semi-major axis of the orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) SemiMajorAxis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_SemiMajorAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SemiMajorAxisStream - the semi-major axis of the orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) SemiMajorAxisStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_SemiMajorAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SemiMinorAxis - the semi-minor axis of the orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) SemiMinorAxis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_SemiMinorAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SemiMinorAxisStream - the semi-minor axis of the orbit, in meters.
//
// Allowed game scenes: any.
func (s *Orbit) SemiMinorAxisStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_SemiMinorAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Radius - the current radius of the orbit, in meters. This is the distance
// between the center of mass of the object in orbit, and the center of mass of
// the body around which it is orbiting.
//
// Allowed game scenes: any.
func (s *Orbit) Radius() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Radius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RadiusStream - the current radius of the orbit, in meters. This is the
// distance between the center of mass of the object in orbit, and the center of
// mass of the body around which it is orbiting.
//
// Allowed game scenes: any.
func (s *Orbit) RadiusStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Radius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Speed - the current orbital speed of the object in meters per second.
//
// Allowed game scenes: any.
func (s *Orbit) Speed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpeedStream - the current orbital speed of the object in meters per second.
//
// Allowed game scenes: any.
func (s *Orbit) SpeedStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Period - the orbital period, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) Period() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Period",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PeriodStream - the orbital period, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) PeriodStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Period",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TimeToApoapsis - the time until the object reaches apoapsis, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) TimeToApoapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_TimeToApoapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TimeToApoapsisStream - the time until the object reaches apoapsis, in
// seconds.
//
// Allowed game scenes: any.
func (s *Orbit) TimeToApoapsisStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_TimeToApoapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TimeToPeriapsis - the time until the object reaches periapsis, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) TimeToPeriapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_TimeToPeriapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TimeToPeriapsisStream - the time until the object reaches periapsis, in
// seconds.
//
// Allowed game scenes: any.
func (s *Orbit) TimeToPeriapsisStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_TimeToPeriapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Eccentricity - the <a
// href="https://en.wikipedia.org/wiki/Orbital_eccentricity">eccentricity</a> of
// the orbit.
//
// Allowed game scenes: any.
func (s *Orbit) Eccentricity() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Eccentricity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EccentricityStream - the <a
// href="https://en.wikipedia.org/wiki/Orbital_eccentricity">eccentricity</a> of
// the orbit.
//
// Allowed game scenes: any.
func (s *Orbit) EccentricityStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Eccentricity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Inclination - the <a
// href="https://en.wikipedia.org/wiki/Orbital_inclination">inclination</a> of
// the orbit, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) Inclination() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Inclination",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InclinationStream - the <a
// href="https://en.wikipedia.org/wiki/Orbital_inclination">inclination</a> of
// the orbit, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) InclinationStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Inclination",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// LongitudeOfAscendingNode - the <a
// href="https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node">longitude
// of the ascending node</a>, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) LongitudeOfAscendingNode() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_LongitudeOfAscendingNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LongitudeOfAscendingNodeStream - the <a
// href="https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node">longitude
// of the ascending node</a>, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) LongitudeOfAscendingNodeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_LongitudeOfAscendingNode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ArgumentOfPeriapsis - the <a
// href="https://en.wikipedia.org/wiki/Argument_of_periapsis">argument of
// periapsis</a>, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) ArgumentOfPeriapsis() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_ArgumentOfPeriapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ArgumentOfPeriapsisStream - the <a
// href="https://en.wikipedia.org/wiki/Argument_of_periapsis">argument of
// periapsis</a>, in radians.
//
// Allowed game scenes: any.
func (s *Orbit) ArgumentOfPeriapsisStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_ArgumentOfPeriapsis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MeanAnomalyAtEpoch - the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>.
//
// Allowed game scenes: any.
func (s *Orbit) MeanAnomalyAtEpoch() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_MeanAnomalyAtEpoch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MeanAnomalyAtEpochStream - the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>.
//
// Allowed game scenes: any.
func (s *Orbit) MeanAnomalyAtEpochStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_MeanAnomalyAtEpoch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Epoch - the time since the epoch (the point at which the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>
// was measured, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) Epoch() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Epoch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EpochStream - the time since the epoch (the point at which the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>
// was measured, in seconds.
//
// Allowed game scenes: any.
func (s *Orbit) EpochStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_Epoch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MeanAnomaly - the <a href="https://en.wikipedia.org/wiki/Mean_anomaly">mean
// anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) MeanAnomaly() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_MeanAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MeanAnomalyStream - the <a
// href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) MeanAnomalyStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_MeanAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// EccentricAnomaly - the <a
// href="https://en.wikipedia.org/wiki/Eccentric_anomaly">eccentric anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) EccentricAnomaly() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_EccentricAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EccentricAnomalyStream - the <a
// href="https://en.wikipedia.org/wiki/Eccentric_anomaly">eccentric anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) EccentricAnomalyStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_EccentricAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TrueAnomaly - the <a href="https://en.wikipedia.org/wiki/True_anomaly">true
// anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomaly() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_TrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TrueAnomalyStream - the <a
// href="https://en.wikipedia.org/wiki/True_anomaly">true anomaly</a>.
//
// Allowed game scenes: any.
func (s *Orbit) TrueAnomalyStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_TrueAnomaly",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// NextOrbit - if the object is going to change sphere of influence in the
// future, returns the new orbit after the change. Otherwise returns nil.
//
// Allowed game scenes: any.
func (s *Orbit) NextOrbit() (*Orbit, error) {
	var err error
	var argBytes []byte
	var vv Orbit
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_NextOrbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// TimeToSOIChange - the time until the object changes sphere of influence, in
// seconds. Returns NaN if the object is not going to change sphere of
// influence.
//
// Allowed game scenes: any.
func (s *Orbit) TimeToSOIChange() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_TimeToSOIChange",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TimeToSOIChangeStream - the time until the object changes sphere of
// influence, in seconds. Returns NaN if the object is not going to change
// sphere of influence.
//
// Allowed game scenes: any.
func (s *Orbit) TimeToSOIChangeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_TimeToSOIChange",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// OrbitalSpeed - the current orbital speed in meters per second.
//
// Allowed game scenes: any.
func (s *Orbit) OrbitalSpeed() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_OrbitalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OrbitalSpeedStream - the current orbital speed in meters per second.
//
// Allowed game scenes: any.
func (s *Orbit) OrbitalSpeedStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Orbit_get_OrbitalSpeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Transmit - transmit data.
//
// Allowed game scenes: any.
func (s *Antenna) Transmit() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_Transmit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Cancel - cancel current transmission of data.
//
// Allowed game scenes: any.
func (s *Antenna) Cancel() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_Cancel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this antenna.
//
// Allowed game scenes: any.
func (s *Antenna) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// State - the current state of the antenna.
//
// Allowed game scenes: any.
func (s *Antenna) State() (AntennaState, error) {
	var err error
	var argBytes []byte
	var vv AntennaState
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the current state of the antenna.
//
// Allowed game scenes: any.
func (s *Antenna) StateStream() (*krpcgo.Stream[AntennaState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) AntennaState {
		var value AntennaState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deployable - whether the antenna is deployable.
//
// Allowed game scenes: any.
func (s *Antenna) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployableStream - whether the antenna is deployable.
//
// Allowed game scenes: any.
func (s *Antenna) DeployableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deployed - whether the antenna is deployed.
//
// Allowed game scenes: any.
func (s *Antenna) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployedStream - whether the antenna is deployed.
//
// Allowed game scenes: any.
func (s *Antenna) DeployedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeployed - whether the antenna is deployed.
//
// Allowed game scenes: any.
func (s *Antenna) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CanTransmit - whether data can be transmitted by this antenna.
//
// Allowed game scenes: any.
func (s *Antenna) CanTransmit() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_CanTransmit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanTransmitStream - whether data can be transmitted by this antenna.
//
// Allowed game scenes: any.
func (s *Antenna) CanTransmitStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_CanTransmit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AllowPartial - whether partial data transmission is permitted.
//
// Allowed game scenes: any.
func (s *Antenna) AllowPartial() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_AllowPartial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AllowPartialStream - whether partial data transmission is permitted.
//
// Allowed game scenes: any.
func (s *Antenna) AllowPartialStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_AllowPartial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAllowPartial - whether partial data transmission is permitted.
//
// Allowed game scenes: any.
func (s *Antenna) SetAllowPartial(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_set_AllowPartial",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Power - the power of the antenna.
//
// Allowed game scenes: any.
func (s *Antenna) Power() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_Power",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PowerStream - the power of the antenna.
//
// Allowed game scenes: any.
func (s *Antenna) PowerStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_Power",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Combinable - whether the antenna can be combined with other antennae on the
// vessel to boost the power.
//
// Allowed game scenes: any.
func (s *Antenna) Combinable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_Combinable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CombinableStream - whether the antenna can be combined with other antennae on
// the vessel to boost the power.
//
// Allowed game scenes: any.
func (s *Antenna) CombinableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_Combinable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CombinableExponent - exponent used to calculate the combined power of
// multiple antennae on a vessel.
//
// Allowed game scenes: any.
func (s *Antenna) CombinableExponent() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_CombinableExponent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CombinableExponentStream - exponent used to calculate the combined power of
// multiple antennae on a vessel.
//
// Allowed game scenes: any.
func (s *Antenna) CombinableExponentStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_CombinableExponent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PacketInterval - interval between sending packets in seconds.
//
// Allowed game scenes: any.
func (s *Antenna) PacketInterval() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_PacketInterval",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PacketIntervalStream - interval between sending packets in seconds.
//
// Allowed game scenes: any.
func (s *Antenna) PacketIntervalStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_PacketInterval",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PacketSize - amount of data sent per packet in Mits.
//
// Allowed game scenes: any.
func (s *Antenna) PacketSize() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_PacketSize",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PacketSizeStream - amount of data sent per packet in Mits.
//
// Allowed game scenes: any.
func (s *Antenna) PacketSizeStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_PacketSize",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PacketResourceCost - units of electric charge consumed per packet sent.
//
// Allowed game scenes: any.
func (s *Antenna) PacketResourceCost() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_PacketResourceCost",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PacketResourceCostStream - units of electric charge consumed per packet sent.
//
// Allowed game scenes: any.
func (s *Antenna) PacketResourceCostStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Antenna_get_PacketResourceCost",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this cargo bay.
//
// Allowed game scenes: any.
func (s *CargoBay) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "CargoBay_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// State - the state of the cargo bay.
//
// Allowed game scenes: any.
func (s *CargoBay) State() (CargoBayState, error) {
	var err error
	var argBytes []byte
	var vv CargoBayState
	request := &types.ProcedureCall{
		Procedure: "CargoBay_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the state of the cargo bay.
//
// Allowed game scenes: any.
func (s *CargoBay) StateStream() (*krpcgo.Stream[CargoBayState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CargoBay_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) CargoBayState {
		var value CargoBayState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Open - whether the cargo bay is open.
//
// Allowed game scenes: any.
func (s *CargoBay) Open() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "CargoBay_get_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OpenStream - whether the cargo bay is open.
//
// Allowed game scenes: any.
func (s *CargoBay) OpenStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CargoBay_get_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetOpen - whether the cargo bay is open.
//
// Allowed game scenes: any.
func (s *CargoBay) SetOpen(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "CargoBay_set_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this control surface.
//
// Allowed game scenes: any.
func (s *ControlSurface) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// PitchEnabled - whether the control surface has pitch control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) PitchEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PitchEnabledStream - whether the control surface has pitch control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) PitchEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPitchEnabled - whether the control surface has pitch control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetPitchEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_set_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// YawEnabled - whether the control surface has yaw control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) YawEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// YawEnabledStream - whether the control surface has yaw control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) YawEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetYawEnabled - whether the control surface has yaw control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetYawEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_set_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RollEnabled - whether the control surface has roll control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) RollEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RollEnabledStream - whether the control surface has roll control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) RollEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRollEnabled - whether the control surface has roll control enabled.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetRollEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_set_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AuthorityLimiter - the authority limiter for the control surface, which
// controls how far the control surface will move.
//
// Allowed game scenes: any.
func (s *ControlSurface) AuthorityLimiter() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_AuthorityLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AuthorityLimiterStream - the authority limiter for the control surface, which
// controls how far the control surface will move.
//
// Allowed game scenes: any.
func (s *ControlSurface) AuthorityLimiterStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_AuthorityLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAuthorityLimiter - the authority limiter for the control surface, which
// controls how far the control surface will move.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetAuthorityLimiter(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_set_AuthorityLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Inverted - whether the control surface movement is inverted.
//
// Allowed game scenes: any.
func (s *ControlSurface) Inverted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_Inverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InvertedStream - whether the control surface movement is inverted.
//
// Allowed game scenes: any.
func (s *ControlSurface) InvertedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_Inverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetInverted - whether the control surface movement is inverted.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetInverted(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_set_Inverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Deployed - whether the control surface has been fully deployed.
//
// Allowed game scenes: any.
func (s *ControlSurface) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployedStream - whether the control surface has been fully deployed.
//
// Allowed game scenes: any.
func (s *ControlSurface) DeployedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeployed - whether the control surface has been fully deployed.
//
// Allowed game scenes: any.
func (s *ControlSurface) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SurfaceArea - surface area of the control surface in <math>m^2</math>.
//
// Allowed game scenes: any.
func (s *ControlSurface) SurfaceArea() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_SurfaceArea",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SurfaceAreaStream - surface area of the control surface in <math>m^2</math>.
//
// Allowed game scenes: any.
func (s *ControlSurface) SurfaceAreaStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_SurfaceArea",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableTorque - the available torque, in Newton meters, that can be
// produced by this control surface, in the positive and negative pitch, roll
// and yaw axes of the vessel. These axes correspond to the coordinate axes of
// the <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *ControlSurface) AvailableTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableTorqueStream - the available torque, in Newton meters, that can be
// produced by this control surface, in the positive and negative pitch, roll
// and yaw axes of the vessel. These axes correspond to the coordinate axes of
// the <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *ControlSurface) AvailableTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ControlSurface_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Decouple - fires the decoupler. Returns the new vessel created when the
// decoupler fires. Throws an exception if the decoupler has already fired.
//
// Allowed game scenes: any.
func (s *Decoupler) Decouple() (*Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &types.ProcedureCall{
		Procedure: "Decoupler_Decouple",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Part - the part object for this decoupler.
//
// Allowed game scenes: any.
func (s *Decoupler) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Decoupler_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Decoupled - whether the decoupler has fired.
//
// Allowed game scenes: any.
func (s *Decoupler) Decoupled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Decoupler_get_Decoupled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DecoupledStream - whether the decoupler has fired.
//
// Allowed game scenes: any.
func (s *Decoupler) DecoupledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Decoupler_get_Decoupled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Staged - whether the decoupler is enabled in the staging sequence.
//
// Allowed game scenes: any.
func (s *Decoupler) Staged() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Decoupler_get_Staged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StagedStream - whether the decoupler is enabled in the staging sequence.
//
// Allowed game scenes: any.
func (s *Decoupler) StagedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Decoupler_get_Staged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Impulse - the impulse that the decoupler imparts when it is fired, in Newton
// seconds.
//
// Allowed game scenes: any.
func (s *Decoupler) Impulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Decoupler_get_Impulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ImpulseStream - the impulse that the decoupler imparts when it is fired, in
// Newton seconds.
//
// Allowed game scenes: any.
func (s *Decoupler) ImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Decoupler_get_Impulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Undock - undocks the docking port and returns the new <see
// cref="T:SpaceCenter.Vessel" /> that is created. This method can be called for
// either docking port in a docked pair. Throws an exception if the docking port
// is not docked to anything.
//
// Allowed game scenes: any.
func (s *DockingPort) Undock() (*Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &types.ProcedureCall{
		Procedure: "DockingPort_Undock",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Position - the position of the docking port, in the given reference frame.
//
// Allowed game scenes: any.
func (s *DockingPort) Position(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "DockingPort_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionStream - the position of the docking port, in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *DockingPort) PositionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Direction - the direction that docking port points in, in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *DockingPort) Direction(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "DockingPort_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DirectionStream - the direction that docking port points in, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *DockingPort) DirectionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rotation - the rotation of the docking port, in the given reference frame.
//
// Allowed game scenes: any.
func (s *DockingPort) Rotation(referenceFrame *ReferenceFrame) (types.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple4[float64, float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "DockingPort_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationStream - the rotation of the docking port, in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *DockingPort) RotationStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple4[float64, float64, float64, float64] {
		var value types.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this docking port.
//
// Allowed game scenes: any.
func (s *DockingPort) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// State - the current state of the docking port.
//
// Allowed game scenes: any.
func (s *DockingPort) State() (DockingPortState, error) {
	var err error
	var argBytes []byte
	var vv DockingPortState
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the current state of the docking port.
//
// Allowed game scenes: any.
func (s *DockingPort) StateStream() (*krpcgo.Stream[DockingPortState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) DockingPortState {
		var value DockingPortState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DockedPart - the part that this docking port is docked to. Returns nil if
// this docking port is not docked to anything.
//
// Allowed game scenes: any.
func (s *DockingPort) DockedPart() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_DockedPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ReengageDistance - the distance a docking port must move away when it undocks
// before it becomes ready to dock with another port, in meters.
//
// Allowed game scenes: any.
func (s *DockingPort) ReengageDistance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_ReengageDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ReengageDistanceStream - the distance a docking port must move away when it
// undocks before it becomes ready to dock with another port, in meters.
//
// Allowed game scenes: any.
func (s *DockingPort) ReengageDistanceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_ReengageDistance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasShield - whether the docking port has a shield.
//
// Allowed game scenes: any.
func (s *DockingPort) HasShield() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_HasShield",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasShieldStream - whether the docking port has a shield.
//
// Allowed game scenes: any.
func (s *DockingPort) HasShieldStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_HasShield",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Shielded - the state of the docking ports shield, if it has one.  Returns
// true if the docking port has a shield, and the shield is closed. Otherwise
// returns false. When set to true, the shield is closed, and when set to false
// the shield is opened. If the docking port does not have a shield, setting
// this attribute has no effect.
//
// Allowed game scenes: any.
func (s *DockingPort) Shielded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ShieldedStream - the state of the docking ports shield, if it has one.
// Returns true if the docking port has a shield, and the shield is closed.
// Otherwise returns false. When set to true, the shield is closed, and when set
// to false the shield is opened. If the docking port does not have a shield,
// setting this attribute has no effect.
//
// Allowed game scenes: any.
func (s *DockingPort) ShieldedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetShielded - the state of the docking ports shield, if it has one.  Returns
// true if the docking port has a shield, and the shield is closed. Otherwise
// returns false. When set to true, the shield is closed, and when set to false
// the shield is opened. If the docking port does not have a shield, setting
// this attribute has no effect.
//
// Allowed game scenes: any.
func (s *DockingPort) SetShielded(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_set_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CanRotate - whether the docking port can be commanded to rotate while docked.
//
// Allowed game scenes: any.
func (s *DockingPort) CanRotate() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_CanRotate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanRotateStream - whether the docking port can be commanded to rotate while
// docked.
//
// Allowed game scenes: any.
func (s *DockingPort) CanRotateStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_CanRotate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaximumRotation - maximum rotation angle in degrees.
//
// Allowed game scenes: any.
func (s *DockingPort) MaximumRotation() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_MaximumRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaximumRotationStream - maximum rotation angle in degrees.
//
// Allowed game scenes: any.
func (s *DockingPort) MaximumRotationStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_MaximumRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MinimumRotation - minimum rotation angle in degrees.
//
// Allowed game scenes: any.
func (s *DockingPort) MinimumRotation() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_MinimumRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MinimumRotationStream - minimum rotation angle in degrees.
//
// Allowed game scenes: any.
func (s *DockingPort) MinimumRotationStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_MinimumRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RotationTarget - rotation target angle in degrees.
//
// Allowed game scenes: any.
func (s *DockingPort) RotationTarget() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_RotationTarget",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationTargetStream - rotation target angle in degrees.
//
// Allowed game scenes: any.
func (s *DockingPort) RotationTargetStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_RotationTarget",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRotationTarget - rotation target angle in degrees.
//
// Allowed game scenes: any.
func (s *DockingPort) SetRotationTarget(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_set_RotationTarget",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RotationLocked - lock rotation. When locked, allows auto-strut to work across
// the joint.
//
// Allowed game scenes: any.
func (s *DockingPort) RotationLocked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_RotationLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationLockedStream - lock rotation. When locked, allows auto-strut to work
// across the joint.
//
// Allowed game scenes: any.
func (s *DockingPort) RotationLockedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_RotationLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRotationLocked - lock rotation. When locked, allows auto-strut to work
// across the joint.
//
// Allowed game scenes: any.
func (s *DockingPort) SetRotationLocked(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "DockingPort_set_RotationLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame - the reference frame that is fixed relative to this docking
// port, and oriented with the port. <list type="bullet"><item><description>The
// origin is at the position of the docking port.
// </description></item><item><description>The axes rotate with the docking
// port.</description></item><item><description>The x-axis points out to the
// right side of the docking port. </description></item><item><description>The
// y-axis points in the direction the docking port is facing.
// </description></item><item><description>The z-axis points out of the bottom
// off the docking port. </description></item></list>
//
// Allowed game scenes: any.
func (s *DockingPort) ReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "DockingPort_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AvailableThrustAt - the amount of thrust, in Newtons, that would be produced
// by the engine when activated and with its throttle set to 100%. Returns zero
// if the engine does not have any fuel. Takes the given pressure into account.
//
// Allowed game scenes: any.
func (s *Engine) AvailableThrustAt(pressure float64) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_AvailableThrustAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableThrustAtStream - the amount of thrust, in Newtons, that would be
// produced by the engine when activated and with its throttle set to 100%.
// Returns zero if the engine does not have any fuel. Takes the given pressure
// into account.
//
// Allowed game scenes: any.
func (s *Engine) AvailableThrustAtStream(pressure float64) (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_AvailableThrustAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxThrustAt - the amount of thrust, in Newtons, that would be produced by the
// engine when activated and fueled, with its throttle and throttle limiter set
// to 100%. Takes the given pressure into account.
//
// Allowed game scenes: any.
func (s *Engine) MaxThrustAt(pressure float64) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_MaxThrustAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxThrustAtStream - the amount of thrust, in Newtons, that would be produced
// by the engine when activated and fueled, with its throttle and throttle
// limiter set to 100%. Takes the given pressure into account.
//
// Allowed game scenes: any.
func (s *Engine) MaxThrustAtStream(pressure float64) (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_MaxThrustAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SpecificImpulseAt - the specific impulse of the engine under the given
// pressure, in seconds. Returns zero if the engine is not active.
//
// Allowed game scenes: any.
func (s *Engine) SpecificImpulseAt(pressure float64) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_SpecificImpulseAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpecificImpulseAtStream - the specific impulse of the engine under the given
// pressure, in seconds. Returns zero if the engine is not active.
//
// Allowed game scenes: any.
func (s *Engine) SpecificImpulseAtStream(pressure float64) (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_SpecificImpulseAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ToggleMode - toggle the current engine mode.
//
// Allowed game scenes: any.
func (s *Engine) ToggleMode() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_ToggleMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this engine.
//
// Allowed game scenes: any.
func (s *Engine) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Active - whether the engine is active. Setting this attribute may have no
// effect, depending on <see cref="M:SpaceCenter.Engine.CanShutdown" /> and <see
// cref="M:SpaceCenter.Engine.CanRestart" />.
//
// Allowed game scenes: any.
func (s *Engine) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActiveStream - whether the engine is active. Setting this attribute may have
// no effect, depending on <see cref="M:SpaceCenter.Engine.CanShutdown" /> and
// <see cref="M:SpaceCenter.Engine.CanRestart" />.
//
// Allowed game scenes: any.
func (s *Engine) ActiveStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetActive - whether the engine is active. Setting this attribute may have no
// effect, depending on <see cref="M:SpaceCenter.Engine.CanShutdown" /> and <see
// cref="M:SpaceCenter.Engine.CanRestart" />.
//
// Allowed game scenes: any.
func (s *Engine) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thrust - the current amount of thrust being produced by the engine, in
// Newtons.
//
// Allowed game scenes: any.
func (s *Engine) Thrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Thrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrustStream - the current amount of thrust being produced by the engine, in
// Newtons.
//
// Allowed game scenes: any.
func (s *Engine) ThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Thrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableThrust - the amount of thrust, in Newtons, that would be produced by
// the engine when activated and with its throttle set to 100%. Returns zero if
// the engine does not have any fuel. Takes the engine's current <see
// cref="M:SpaceCenter.Engine.ThrustLimit" /> and atmospheric conditions into
// account.
//
// Allowed game scenes: any.
func (s *Engine) AvailableThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableThrustStream - the amount of thrust, in Newtons, that would be
// produced by the engine when activated and with its throttle set to 100%.
// Returns zero if the engine does not have any fuel. Takes the engine's current
// <see cref="M:SpaceCenter.Engine.ThrustLimit" /> and atmospheric conditions
// into account.
//
// Allowed game scenes: any.
func (s *Engine) AvailableThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxThrust - the amount of thrust, in Newtons, that would be produced by the
// engine when activated and fueled, with its throttle and throttle limiter set
// to 100%.
//
// Allowed game scenes: any.
func (s *Engine) MaxThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxThrustStream - the amount of thrust, in Newtons, that would be produced by
// the engine when activated and fueled, with its throttle and throttle limiter
// set to 100%.
//
// Allowed game scenes: any.
func (s *Engine) MaxThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxVacuumThrust - the maximum amount of thrust that can be produced by the
// engine in a vacuum, in Newtons. This is the amount of thrust produced by the
// engine when activated, <see cref="M:SpaceCenter.Engine.ThrustLimit" /> is set
// to 100%, the main vessel's throttle is set to 100% and the engine is in a
// vacuum.
//
// Allowed game scenes: any.
func (s *Engine) MaxVacuumThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxVacuumThrustStream - the maximum amount of thrust that can be produced by
// the engine in a vacuum, in Newtons. This is the amount of thrust produced by
// the engine when activated, <see cref="M:SpaceCenter.Engine.ThrustLimit" /> is
// set to 100%, the main vessel's throttle is set to 100% and the engine is in a
// vacuum.
//
// Allowed game scenes: any.
func (s *Engine) MaxVacuumThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThrustLimit - the thrust limiter of the engine. A value between 0 and 1.
// Setting this attribute may have no effect, for example the thrust limit for a
// solid rocket booster cannot be changed in flight.
//
// Allowed game scenes: any.
func (s *Engine) ThrustLimit() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrustLimitStream - the thrust limiter of the engine. A value between 0 and
// 1. Setting this attribute may have no effect, for example the thrust limit
// for a solid rocket booster cannot be changed in flight.
//
// Allowed game scenes: any.
func (s *Engine) ThrustLimitStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetThrustLimit - the thrust limiter of the engine. A value between 0 and 1.
// Setting this attribute may have no effect, for example the thrust limit for a
// solid rocket booster cannot be changed in flight.
//
// Allowed game scenes: any.
func (s *Engine) SetThrustLimit(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_set_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thrusters - the components of the engine that generate thrust.
//
// Allowed game scenes: any.
func (s *Engine) Thrusters() ([]*Thruster, error) {
	var err error
	var argBytes []byte
	var vv []*Thruster
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Thrusters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ThrustersStream - the components of the engine that generate thrust.
//
// Allowed game scenes: any.
func (s *Engine) ThrustersStream() (*krpcgo.Stream[[]*Thruster], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Thrusters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Thruster {
		var value []*Thruster
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SpecificImpulse - the current specific impulse of the engine, in seconds.
// Returns zero if the engine is not active.
//
// Allowed game scenes: any.
func (s *Engine) SpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpecificImpulseStream - the current specific impulse of the engine, in
// seconds. Returns zero if the engine is not active.
//
// Allowed game scenes: any.
func (s *Engine) SpecificImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// VacuumSpecificImpulse - the vacuum specific impulse of the engine, in
// seconds.
//
// Allowed game scenes: any.
func (s *Engine) VacuumSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VacuumSpecificImpulseStream - the vacuum specific impulse of the engine, in
// seconds.
//
// Allowed game scenes: any.
func (s *Engine) VacuumSpecificImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// KerbinSeaLevelSpecificImpulse - the specific impulse of the engine at sea
// level on Kerbin, in seconds.
//
// Allowed game scenes: any.
func (s *Engine) KerbinSeaLevelSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// KerbinSeaLevelSpecificImpulseStream - the specific impulse of the engine at
// sea level on Kerbin, in seconds.
//
// Allowed game scenes: any.
func (s *Engine) KerbinSeaLevelSpecificImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PropellantNames - the names of the propellants that the engine consumes.
//
// Allowed game scenes: any.
func (s *Engine) PropellantNames() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "Engine_get_PropellantNames",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PropellantNamesStream - the names of the propellants that the engine
// consumes.
//
// Allowed game scenes: any.
func (s *Engine) PropellantNamesStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_PropellantNames",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Propellants - the propellants that the engine consumes.
//
// Allowed game scenes: any.
func (s *Engine) Propellants() ([]*Propellant, error) {
	var err error
	var argBytes []byte
	var vv []*Propellant
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Propellants",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// PropellantsStream - the propellants that the engine consumes.
//
// Allowed game scenes: any.
func (s *Engine) PropellantsStream() (*krpcgo.Stream[[]*Propellant], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Propellants",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Propellant {
		var value []*Propellant
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PropellantRatios - the ratio of resources that the engine consumes. A
// dictionary mapping resource names to the ratio at which they are consumed by
// the engine.
//
// Allowed game scenes: any.
func (s *Engine) PropellantRatios() (map[string]float32, error) {
	var err error
	var argBytes []byte
	var vv map[string]float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_PropellantRatios",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PropellantRatiosStream - the ratio of resources that the engine consumes. A
// dictionary mapping resource names to the ratio at which they are consumed by
// the engine.
//
// Allowed game scenes: any.
func (s *Engine) PropellantRatiosStream() (*krpcgo.Stream[map[string]float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_PropellantRatios",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) map[string]float32 {
		var value map[string]float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasFuel - whether the engine has any fuel available.
//
// Allowed game scenes: any.
func (s *Engine) HasFuel() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_HasFuel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasFuelStream - whether the engine has any fuel available.
//
// Allowed game scenes: any.
func (s *Engine) HasFuelStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_HasFuel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Throttle - the current throttle setting for the engine. A value between 0 and
// 1. This is not necessarily the same as the vessel's main throttle setting, as
// some engines take time to adjust their throttle (such as jet engines), or
// independent throttle may be enabled.  When the engine's independent throttle
// is enabled (see <see cref="M:SpaceCenter.Engine.IndependentThrottle" />), can
// be used to set the throttle percentage.
//
// Allowed game scenes: any.
func (s *Engine) Throttle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrottleStream - the current throttle setting for the engine. A value between
// 0 and 1. This is not necessarily the same as the vessel's main throttle
// setting, as some engines take time to adjust their throttle (such as jet
// engines), or independent throttle may be enabled.  When the engine's
// independent throttle is enabled (see <see
// cref="M:SpaceCenter.Engine.IndependentThrottleStream" />), can be used to set
// the throttle percentage.
//
// Allowed game scenes: any.
func (s *Engine) ThrottleStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetThrottle - the current throttle setting for the engine. A value between 0
// and 1. This is not necessarily the same as the vessel's main throttle
// setting, as some engines take time to adjust their throttle (such as jet
// engines), or independent throttle may be enabled.  When the engine's
// independent throttle is enabled (see <see
// cref="M:SpaceCenter.Engine.IndependentThrottle" />), can be used to set the
// throttle percentage.
//
// Allowed game scenes: any.
func (s *Engine) SetThrottle(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_set_Throttle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ThrottleLocked - whether the <see cref="M:SpaceCenter.Control.Throttle" />
// affects the engine. For example, this is true for liquid fueled rockets, and
// false for solid rocket boosters.
//
// Allowed game scenes: any.
func (s *Engine) ThrottleLocked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_ThrottleLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrottleLockedStream - whether the <see cref="M:SpaceCenter.Control.Throttle"
// /> affects the engine. For example, this is true for liquid fueled rockets,
// and false for solid rocket boosters.
//
// Allowed game scenes: any.
func (s *Engine) ThrottleLockedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_ThrottleLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IndependentThrottle - whether the independent throttle is enabled for the
// engine.
//
// Allowed game scenes: any.
func (s *Engine) IndependentThrottle() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_IndependentThrottle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IndependentThrottleStream - whether the independent throttle is enabled for
// the engine.
//
// Allowed game scenes: any.
func (s *Engine) IndependentThrottleStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_IndependentThrottle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetIndependentThrottle - whether the independent throttle is enabled for the
// engine.
//
// Allowed game scenes: any.
func (s *Engine) SetIndependentThrottle(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_set_IndependentThrottle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CanRestart - whether the engine can be restarted once shutdown. If the engine
// cannot be shutdown, returns false. For example, this is true for liquid
// fueled rockets and false for solid rocket boosters.
//
// Allowed game scenes: any.
func (s *Engine) CanRestart() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_CanRestart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanRestartStream - whether the engine can be restarted once shutdown. If the
// engine cannot be shutdown, returns false. For example, this is true for
// liquid fueled rockets and false for solid rocket boosters.
//
// Allowed game scenes: any.
func (s *Engine) CanRestartStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_CanRestart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CanShutdown - whether the engine can be shutdown once activated. For example,
// this is true for liquid fueled rockets and false for solid rocket boosters.
//
// Allowed game scenes: any.
func (s *Engine) CanShutdown() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_CanShutdown",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CanShutdownStream - whether the engine can be shutdown once activated. For
// example, this is true for liquid fueled rockets and false for solid rocket
// boosters.
//
// Allowed game scenes: any.
func (s *Engine) CanShutdownStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_CanShutdown",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasModes - whether the engine has multiple modes of operation.
//
// Allowed game scenes: any.
func (s *Engine) HasModes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_HasModes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasModesStream - whether the engine has multiple modes of operation.
//
// Allowed game scenes: any.
func (s *Engine) HasModesStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_HasModes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Mode - the name of the current engine mode.
//
// Allowed game scenes: any.
func (s *Engine) Mode() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ModeStream - the name of the current engine mode.
//
// Allowed game scenes: any.
func (s *Engine) ModeStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMode - the name of the current engine mode.
//
// Allowed game scenes: any.
func (s *Engine) SetMode(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_set_Mode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Modes - the available modes for the engine. A dictionary mapping mode names
// to <see cref="T:SpaceCenter.Engine" /> objects.
//
// Allowed game scenes: any.
func (s *Engine) Modes() (map[string]*Engine, error) {
	var err error
	var argBytes []byte
	var vv map[string]*Engine
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Modes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ModesStream - the available modes for the engine. A dictionary mapping mode
// names to <see cref="T:SpaceCenter.Engine" /> objects.
//
// Allowed game scenes: any.
func (s *Engine) ModesStream() (*krpcgo.Stream[map[string]*Engine], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Modes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) map[string]*Engine {
		var value map[string]*Engine
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AutoModeSwitch - whether the engine will automatically switch modes.
//
// Allowed game scenes: any.
func (s *Engine) AutoModeSwitch() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_AutoModeSwitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AutoModeSwitchStream - whether the engine will automatically switch modes.
//
// Allowed game scenes: any.
func (s *Engine) AutoModeSwitchStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_AutoModeSwitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAutoModeSwitch - whether the engine will automatically switch modes.
//
// Allowed game scenes: any.
func (s *Engine) SetAutoModeSwitch(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_set_AutoModeSwitch",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Gimballed - whether the engine is gimballed.
//
// Allowed game scenes: any.
func (s *Engine) Gimballed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Gimballed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GimballedStream - whether the engine is gimballed.
//
// Allowed game scenes: any.
func (s *Engine) GimballedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_Gimballed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// GimbalRange - the range over which the gimbal can move, in degrees. Returns 0
// if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) GimbalRange() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_GimbalRange",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GimbalRangeStream - the range over which the gimbal can move, in degrees.
// Returns 0 if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) GimbalRangeStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_GimbalRange",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// GimbalLocked - whether the engines gimbal is locked in place. Setting this
// attribute has no effect if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) GimbalLocked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Engine_get_GimbalLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GimbalLockedStream - whether the engines gimbal is locked in place. Setting
// this attribute has no effect if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) GimbalLockedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_GimbalLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetGimbalLocked - whether the engines gimbal is locked in place. Setting this
// attribute has no effect if the engine is not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) SetGimbalLocked(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_set_GimbalLocked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// GimbalLimit - the gimbal limiter of the engine. A value between 0 and 1.
// Returns 0 if the gimbal is locked.
//
// Allowed game scenes: any.
func (s *Engine) GimbalLimit() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Engine_get_GimbalLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GimbalLimitStream - the gimbal limiter of the engine. A value between 0 and
// 1. Returns 0 if the gimbal is locked.
//
// Allowed game scenes: any.
func (s *Engine) GimbalLimitStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_GimbalLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetGimbalLimit - the gimbal limiter of the engine. A value between 0 and 1.
// Returns 0 if the gimbal is locked.
//
// Allowed game scenes: any.
func (s *Engine) SetGimbalLimit(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_set_GimbalLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AvailableTorque - the available torque, in Newton meters, that can be
// produced by this engine, in the positive and negative pitch, roll and yaw
// axes of the vessel. These axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if the engine is
// inactive, or not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) AvailableTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Engine_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableTorqueStream - the available torque, in Newton meters, that can be
// produced by this engine, in the positive and negative pitch, roll and yaw
// axes of the vessel. These axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if the engine is
// inactive, or not gimballed.
//
// Allowed game scenes: any.
func (s *Engine) AvailableTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Engine_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Run - run the experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Run() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_Run",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Transmit - transmit all experimental data contained by this part.
//
// Allowed game scenes: any.
func (s *Experiment) Transmit() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_Transmit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Dump - dump the experimental data contained by the experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Dump() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_Dump",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Reset - reset the experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Reset() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_Reset",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Name - internal name of the experiment, as used in <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation">part
// cfg files</a>.
//
// Allowed game scenes: any.
func (s *Experiment) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - internal name of the experiment, as used in <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation">part
// cfg files</a>.
//
// Allowed game scenes: any.
func (s *Experiment) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Title - title of the experiment, as shown on the in-game UI.
//
// Allowed game scenes: any.
func (s *Experiment) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TitleStream - title of the experiment, as shown on the in-game UI.
//
// Allowed game scenes: any.
func (s *Experiment) TitleStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Inoperable - whether the experiment is inoperable.
//
// Allowed game scenes: any.
func (s *Experiment) Inoperable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Inoperable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InoperableStream - whether the experiment is inoperable.
//
// Allowed game scenes: any.
func (s *Experiment) InoperableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Inoperable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deployed - whether the experiment has been deployed.
//
// Allowed game scenes: any.
func (s *Experiment) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployedStream - whether the experiment has been deployed.
//
// Allowed game scenes: any.
func (s *Experiment) DeployedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rerunnable - whether the experiment can be re-run.
//
// Allowed game scenes: any.
func (s *Experiment) Rerunnable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Rerunnable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RerunnableStream - whether the experiment can be re-run.
//
// Allowed game scenes: any.
func (s *Experiment) RerunnableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Rerunnable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasData - whether the experiment contains data.
//
// Allowed game scenes: any.
func (s *Experiment) HasData() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_HasData",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasDataStream - whether the experiment contains data.
//
// Allowed game scenes: any.
func (s *Experiment) HasDataStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_HasData",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Data - the data contained in this experiment.
//
// Allowed game scenes: any.
func (s *Experiment) Data() ([]*ScienceData, error) {
	var err error
	var argBytes []byte
	var vv []*ScienceData
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Data",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// DataStream - the data contained in this experiment.
//
// Allowed game scenes: any.
func (s *Experiment) DataStream() (*krpcgo.Stream[[]*ScienceData], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Data",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*ScienceData {
		var value []*ScienceData
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Available - determines if the experiment is available given the current
// conditions.
//
// Allowed game scenes: any.
func (s *Experiment) Available() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Available",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableStream - determines if the experiment is available given the current
// conditions.
//
// Allowed game scenes: any.
func (s *Experiment) AvailableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Available",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Biome - the name of the biome the experiment is currently in.
//
// Allowed game scenes: any.
func (s *Experiment) Biome() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Biome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BiomeStream - the name of the biome the experiment is currently in.
//
// Allowed game scenes: any.
func (s *Experiment) BiomeStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_Biome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ScienceSubject - containing information on the corresponding specific science
// result for the current conditions. Returns nil if the experiment is
// unavailable.
//
// Allowed game scenes: any.
func (s *Experiment) ScienceSubject() (*ScienceSubject, error) {
	var err error
	var argBytes []byte
	var vv ScienceSubject
	request := &types.ProcedureCall{
		Procedure: "Experiment_get_ScienceSubject",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Jettison - jettison the fairing. Has no effect if it has already been
// jettisoned.
//
// Allowed game scenes: any.
func (s *Fairing) Jettison() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Fairing_Jettison",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this fairing.
//
// Allowed game scenes: any.
func (s *Fairing) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Fairing_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Jettisoned - whether the fairing has been jettisoned.
//
// Allowed game scenes: any.
func (s *Fairing) Jettisoned() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Fairing_get_Jettisoned",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// JettisonedStream - whether the fairing has been jettisoned.
//
// Allowed game scenes: any.
func (s *Fairing) JettisonedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Fairing_get_Jettisoned",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Remove - remove the force.
//
// Allowed game scenes: any.
func (s *Force) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Force_Remove",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part that this force is applied to.
//
// Allowed game scenes: any.
func (s *Force) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Force_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ForceVector - the force vector, in Newtons.
//
// Allowed game scenes: any.
func (s *Force) ForceVector() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Force_get_ForceVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ForceVectorStream - the force vector, in Newtons.
//
// Allowed game scenes: any.
func (s *Force) ForceVectorStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Force_get_ForceVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetForceVector - the force vector, in Newtons.
//
// Allowed game scenes: any.
func (s *Force) SetForceVector(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Force_set_ForceVector",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position - the position at which the force acts, in reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Force) Position() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Force_get_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionStream - the position at which the force acts, in reference frame
// <see cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Force) PositionStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Force_get_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPosition - the position at which the force acts, in reference frame <see
// cref="T:SpaceCenter.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *Force) SetPosition(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Force_set_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ReferenceFrame - the reference frame of the force vector and position.
//
// Allowed game scenes: any.
func (s *Force) ReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Force_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetReferenceFrame - the reference frame of the force vector and position.
//
// Allowed game scenes: any.
func (s *Force) SetReferenceFrame(value *ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Force_set_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this intake.
//
// Allowed game scenes: any.
func (s *Intake) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Intake_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Open - whether the intake is open.
//
// Allowed game scenes: any.
func (s *Intake) Open() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Intake_get_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OpenStream - whether the intake is open.
//
// Allowed game scenes: any.
func (s *Intake) OpenStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Intake_get_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetOpen - whether the intake is open.
//
// Allowed game scenes: any.
func (s *Intake) SetOpen(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Intake_set_Open",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Speed - speed of the flow into the intake, in <math>m/s</math>.
//
// Allowed game scenes: any.
func (s *Intake) Speed() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Intake_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpeedStream - speed of the flow into the intake, in <math>m/s</math>.
//
// Allowed game scenes: any.
func (s *Intake) SpeedStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Intake_get_Speed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Flow - the rate of flow into the intake, in units of resource per second.
//
// Allowed game scenes: any.
func (s *Intake) Flow() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Intake_get_Flow",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FlowStream - the rate of flow into the intake, in units of resource per
// second.
//
// Allowed game scenes: any.
func (s *Intake) FlowStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Intake_get_Flow",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Area - the area of the intake's opening, in square meters.
//
// Allowed game scenes: any.
func (s *Intake) Area() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Intake_get_Area",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AreaStream - the area of the intake's opening, in square meters.
//
// Allowed game scenes: any.
func (s *Intake) AreaStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Intake_get_Area",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Release - releases the docking clamp. Has no effect if the clamp has already
// been released.
//
// Allowed game scenes: any.
func (s *LaunchClamp) Release() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "LaunchClamp_Release",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this launch clamp.
//
// Allowed game scenes: any.
func (s *LaunchClamp) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "LaunchClamp_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Part - the part object for this landing leg.
//
// Allowed game scenes: any.
func (s *Leg) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Leg_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// State - the current state of the landing leg.
//
// Allowed game scenes: any.
func (s *Leg) State() (LegState, error) {
	var err error
	var argBytes []byte
	var vv LegState
	request := &types.ProcedureCall{
		Procedure: "Leg_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the current state of the landing leg.
//
// Allowed game scenes: any.
func (s *Leg) StateStream() (*krpcgo.Stream[LegState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Leg_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) LegState {
		var value LegState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deployable - whether the leg is deployable.
//
// Allowed game scenes: any.
func (s *Leg) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Leg_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployableStream - whether the leg is deployable.
//
// Allowed game scenes: any.
func (s *Leg) DeployableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Leg_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deployed - whether the landing leg is deployed.
//
// Allowed game scenes: any.
func (s *Leg) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Leg_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployedStream - whether the landing leg is deployed.
//
// Allowed game scenes: any.
func (s *Leg) DeployedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Leg_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeployed - whether the landing leg is deployed.
//
// Allowed game scenes: any.
func (s *Leg) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Leg_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// IsGrounded - returns whether the leg is touching the ground.
//
// Allowed game scenes: any.
func (s *Leg) IsGrounded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Leg_get_IsGrounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsGroundedStream - returns whether the leg is touching the ground.
//
// Allowed game scenes: any.
func (s *Leg) IsGroundedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Leg_get_IsGrounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this light.
//
// Allowed game scenes: any.
func (s *Light) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Light_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Active - whether the light is switched on.
//
// Allowed game scenes: any.
func (s *Light) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Light_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActiveStream - whether the light is switched on.
//
// Allowed game scenes: any.
func (s *Light) ActiveStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Light_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetActive - whether the light is switched on.
//
// Allowed game scenes: any.
func (s *Light) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Light_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color - the color of the light, as an RGB triple.
//
// Allowed game scenes: any.
func (s *Light) Color() (types.Tuple3[float32, float32, float32], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float32, float32, float32]
	request := &types.ProcedureCall{
		Procedure: "Light_get_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ColorStream - the color of the light, as an RGB triple.
//
// Allowed game scenes: any.
func (s *Light) ColorStream() (*krpcgo.Stream[types.Tuple3[float32, float32, float32]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Light_get_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float32, float32, float32] {
		var value types.Tuple3[float32, float32, float32]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetColor - the color of the light, as an RGB triple.
//
// Allowed game scenes: any.
func (s *Light) SetColor(value types.Tuple3[float32, float32, float32]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Light_set_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Blink - whether blinking is enabled.
//
// Allowed game scenes: any.
func (s *Light) Blink() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Light_get_Blink",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BlinkStream - whether blinking is enabled.
//
// Allowed game scenes: any.
func (s *Light) BlinkStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Light_get_Blink",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetBlink - whether blinking is enabled.
//
// Allowed game scenes: any.
func (s *Light) SetBlink(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Light_set_Blink",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// BlinkRate - the blink rate of the light.
//
// Allowed game scenes: any.
func (s *Light) BlinkRate() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Light_get_BlinkRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BlinkRateStream - the blink rate of the light.
//
// Allowed game scenes: any.
func (s *Light) BlinkRateStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Light_get_BlinkRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetBlinkRate - the blink rate of the light.
//
// Allowed game scenes: any.
func (s *Light) SetBlinkRate(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Light_set_BlinkRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// PowerUsage - the current power usage, in units of charge per second.
//
// Allowed game scenes: any.
func (s *Light) PowerUsage() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Light_get_PowerUsage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PowerUsageStream - the current power usage, in units of charge per second.
//
// Allowed game scenes: any.
func (s *Light) PowerUsageStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Light_get_PowerUsage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasField - returns true if the module has a field with the given name.
//
// Allowed game scenes: any.
func (s *Module) HasField(name string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Module_HasField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasFieldStream - returns true if the module has a field with the given name.
//
// Allowed game scenes: any.
func (s *Module) HasFieldStream(name string) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_HasField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasFieldWithId - returns true if the module has a field with the given
// identifier.
//
// Allowed game scenes: any.
func (s *Module) HasFieldWithId(id string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Module_HasFieldWithId",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasFieldWithIdStream - returns true if the module has a field with the given
// identifier.
//
// Allowed game scenes: any.
func (s *Module) HasFieldWithIdStream(id string) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_HasFieldWithId",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// GetField - returns the value of a field with the given name.
//
// Allowed game scenes: any.
func (s *Module) GetField(name string) (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Module_GetField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GetFieldStream - returns the value of a field with the given name.
//
// Allowed game scenes: any.
func (s *Module) GetFieldStream(name string) (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_GetField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// GetFieldById - returns the value of a field with the given identifier.
//
// Allowed game scenes: any.
func (s *Module) GetFieldById(id string) (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Module_GetFieldById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GetFieldByIdStream - returns the value of a field with the given identifier.
//
// Allowed game scenes: any.
func (s *Module) GetFieldByIdStream(id string) (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_GetFieldById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetFieldInt - set the value of a field to the given integer number.
//
// Allowed game scenes: any.
func (s *Module) SetFieldInt(name string, value int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetFieldInt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetFieldIntById - set the value of a field to the given integer number.
//
// Allowed game scenes: any.
func (s *Module) SetFieldIntById(id string, value int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetFieldIntById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetFieldFloat - set the value of a field to the given floating point number.
//
// Allowed game scenes: any.
func (s *Module) SetFieldFloat(name string, value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetFieldFloat",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetFieldFloatById - set the value of a field to the given floating point
// number.
//
// Allowed game scenes: any.
func (s *Module) SetFieldFloatById(id string, value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetFieldFloatById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetFieldString - set the value of a field to the given string.
//
// Allowed game scenes: any.
func (s *Module) SetFieldString(name string, value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetFieldString",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetFieldStringById - set the value of a field to the given string.
//
// Allowed game scenes: any.
func (s *Module) SetFieldStringById(id string, value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetFieldStringById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetFieldBool - set the value of a field to true or false.
//
// Allowed game scenes: any.
func (s *Module) SetFieldBool(name string, value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetFieldBool",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetFieldBoolById - set the value of a field to true or false.
//
// Allowed game scenes: any.
func (s *Module) SetFieldBoolById(id string, value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetFieldBoolById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ResetField - set the value of a field to its original value.
//
// Allowed game scenes: any.
func (s *Module) ResetField(name string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_ResetField",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ResetFieldById - set the value of a field to its original value.
//
// Allowed game scenes: any.
func (s *Module) ResetFieldById(id string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_ResetFieldById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// HasEvent - true if the module has an event with the given name.
//
// Allowed game scenes: any.
func (s *Module) HasEvent(name string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Module_HasEvent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasEventStream - true if the module has an event with the given name.
//
// Allowed game scenes: any.
func (s *Module) HasEventStream(name string) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_HasEvent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasEventWithId - true if the module has an event with the given identifier.
//
// Allowed game scenes: any.
func (s *Module) HasEventWithId(id string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Module_HasEventWithId",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasEventWithIdStream - true if the module has an event with the given
// identifier.
//
// Allowed game scenes: any.
func (s *Module) HasEventWithIdStream(id string) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_HasEventWithId",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TriggerEvent - trigger the named event. Equivalent to clicking the button in
// the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) TriggerEvent(name string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_TriggerEvent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TriggerEventById - trigger the event with the given identifier. Equivalent to
// clicking the button in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) TriggerEventById(id string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_TriggerEventById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// HasAction - true if the part has an action with the given name.
//
// Allowed game scenes: any.
func (s *Module) HasAction(name string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Module_HasAction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasActionStream - true if the part has an action with the given name.
//
// Allowed game scenes: any.
func (s *Module) HasActionStream(name string) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_HasAction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasActionWithId - true if the part has an action with the given identifier.
//
// Allowed game scenes: any.
func (s *Module) HasActionWithId(id string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Module_HasActionWithId",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasActionWithIdStream - true if the part has an action with the given
// identifier.
//
// Allowed game scenes: any.
func (s *Module) HasActionWithIdStream(id string) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_HasActionWithId",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAction - set the value of an action with the given name.
//
// Allowed game scenes: any.
func (s *Module) SetAction(name string, value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetAction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SetActionById - set the value of an action with the given identifier.
//
// Allowed game scenes: any.
func (s *Module) SetActionById(id string, value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_SetActionById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(id)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name - name of the PartModule. For example, "ModuleEngines".
//
// Allowed game scenes: any.
func (s *Module) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Module_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - name of the PartModule. For example, "ModuleEngines".
//
// Allowed game scenes: any.
func (s *Module) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part that contains this module.
//
// Allowed game scenes: any.
func (s *Module) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Module_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Fields - the modules field names and their associated values, as a
// dictionary. These are the values visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) Fields() (map[string]string, error) {
	var err error
	var argBytes []byte
	var vv map[string]string
	request := &types.ProcedureCall{
		Procedure: "Module_get_Fields",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FieldsStream - the modules field names and their associated values, as a
// dictionary. These are the values visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) FieldsStream() (*krpcgo.Stream[map[string]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_get_Fields",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) map[string]string {
		var value map[string]string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FieldsById - the modules field identifiers and their associated values, as a
// dictionary. These are the values visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) FieldsById() (map[string]string, error) {
	var err error
	var argBytes []byte
	var vv map[string]string
	request := &types.ProcedureCall{
		Procedure: "Module_get_FieldsById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FieldsByIdStream - the modules field identifiers and their associated values,
// as a dictionary. These are the values visible in the right-click menu of the
// part.
//
// Allowed game scenes: any.
func (s *Module) FieldsByIdStream() (*krpcgo.Stream[map[string]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_get_FieldsById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) map[string]string {
		var value map[string]string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Events - a list of the names of all of the modules events. Events are the
// clickable buttons visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) Events() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "Module_get_Events",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EventsStream - a list of the names of all of the modules events. EventsStream
// are the clickable buttons visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) EventsStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_get_Events",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// EventsById - a list of the identifiers of all of the modules events. Events
// are the clickable buttons visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) EventsById() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "Module_get_EventsById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EventsByIdStream - a list of the identifiers of all of the modules events.
// Events are the clickable buttons visible in the right-click menu of the part.
//
// Allowed game scenes: any.
func (s *Module) EventsByIdStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_get_EventsById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Actions - a list of all the names of the modules actions. These are the parts
// actions that can be assigned to action groups in the in-game editor.
//
// Allowed game scenes: any.
func (s *Module) Actions() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "Module_get_Actions",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActionsStream - a list of all the names of the modules actions. These are the
// parts actions that can be assigned to action groups in the in-game editor.
//
// Allowed game scenes: any.
func (s *Module) ActionsStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_get_Actions",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ActionsById - a list of all the identifiers of the modules actions. These are
// the parts actions that can be assigned to action groups in the in-game
// editor.
//
// Allowed game scenes: any.
func (s *Module) ActionsById() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "Module_get_ActionsById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActionsByIdStream - a list of all the identifiers of the modules actions.
// These are the parts actions that can be assigned to action groups in the
// in-game editor.
//
// Allowed game scenes: any.
func (s *Module) ActionsByIdStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Module_get_ActionsById",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deploy - deploys the parachute. This has no effect if the parachute has
// already been deployed.
//
// Allowed game scenes: any.
func (s *Parachute) Deploy() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_Deploy",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Arm - deploys the parachute. This has no effect if the parachute has already
// been armed or deployed.
//
// Allowed game scenes: any.
func (s *Parachute) Arm() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_Arm",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Cut - cuts the parachute.
//
// Allowed game scenes: any.
func (s *Parachute) Cut() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_Cut",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this parachute.
//
// Allowed game scenes: any.
func (s *Parachute) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Deployed - whether the parachute has been deployed.
//
// Allowed game scenes: any.
func (s *Parachute) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployedStream - whether the parachute has been deployed.
//
// Allowed game scenes: any.
func (s *Parachute) DeployedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Armed - whether the parachute has been armed or deployed.
//
// Allowed game scenes: any.
func (s *Parachute) Armed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_Armed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ArmedStream - whether the parachute has been armed or deployed.
//
// Allowed game scenes: any.
func (s *Parachute) ArmedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_Armed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// State - the current state of the parachute.
//
// Allowed game scenes: any.
func (s *Parachute) State() (ParachuteState, error) {
	var err error
	var argBytes []byte
	var vv ParachuteState
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the current state of the parachute.
//
// Allowed game scenes: any.
func (s *Parachute) StateStream() (*krpcgo.Stream[ParachuteState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ParachuteState {
		var value ParachuteState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DeployAltitude - the altitude at which the parachute will full deploy, in
// meters. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) DeployAltitude() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_DeployAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployAltitudeStream - the altitude at which the parachute will full deploy,
// in meters. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) DeployAltitudeStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_DeployAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeployAltitude - the altitude at which the parachute will full deploy, in
// meters. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) SetDeployAltitude(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_set_DeployAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// DeployMinPressure - the minimum pressure at which the parachute will
// semi-deploy, in atmospheres. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) DeployMinPressure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_DeployMinPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployMinPressureStream - the minimum pressure at which the parachute will
// semi-deploy, in atmospheres. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) DeployMinPressureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_get_DeployMinPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeployMinPressure - the minimum pressure at which the parachute will
// semi-deploy, in atmospheres. Only applicable to stock parachutes.
//
// Allowed game scenes: any.
func (s *Parachute) SetDeployMinPressure(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parachute_set_DeployMinPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Position - the position of the part in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) Position(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Part_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionStream - the position of the part in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) PositionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CenterOfMass - the position of the parts center of mass in the given
// reference frame. If the part is physicsless, this is equivalent to <see
// cref="M:SpaceCenter.Part.Position" />.
//
// Allowed game scenes: any.
func (s *Part) CenterOfMass(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Part_CenterOfMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CenterOfMassStream - the position of the parts center of mass in the given
// reference frame. If the part is physicsless, this is equivalent to <see
// cref="M:SpaceCenter.Part.Position" />.
//
// Allowed game scenes: any.
func (s *Part) CenterOfMassStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_CenterOfMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// BoundingBox - the axis-aligned bounding box of the part in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Part) BoundingBox(referenceFrame *ReferenceFrame) (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Part_BoundingBox",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BoundingBoxStream - the axis-aligned bounding box of the part in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Part) BoundingBoxStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_BoundingBox",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Direction - the direction the part points in, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) Direction(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Part_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DirectionStream - the direction the part points in, in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *Part) DirectionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Velocity - the linear velocity of the part in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) Velocity(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Part_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VelocityStream - the linear velocity of the part in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *Part) VelocityStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rotation - the rotation of the part, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) Rotation(referenceFrame *ReferenceFrame) (types.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple4[float64, float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Part_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationStream - the rotation of the part, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Part) RotationStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple4[float64, float64, float64, float64] {
		var value types.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AddForce - exert a constant force on the part, acting at the given position.
//
// Allowed game scenes: any.
func (s *Part) AddForce(force types.Tuple3[float64, float64, float64], position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) (*Force, error) {
	var err error
	var argBytes []byte
	var vv Force
	request := &types.ProcedureCall{
		Procedure: "Part_AddForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(force)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// InstantaneousForce - exert an instantaneous force on the part, acting at the
// given position.
//
// Allowed game scenes: any.
func (s *Part) InstantaneousForce(force types.Tuple3[float64, float64, float64], position types.Tuple3[float64, float64, float64], referenceFrame *ReferenceFrame) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_InstantaneousForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(force)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name - internal name of the part, as used in <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation">part
// cfg files</a>. For example "Mark1-2Pod".
//
// Allowed game scenes: any.
func (s *Part) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Part_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - internal name of the part, as used in <a
// href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation">part
// cfg files</a>. For example "Mark1-2Pod".
//
// Allowed game scenes: any.
func (s *Part) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Title - title of the part, as shown when the part is right clicked in-game.
// For example "Mk1-2 Command Pod".
//
// Allowed game scenes: any.
func (s *Part) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Part_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TitleStream - title of the part, as shown when the part is right clicked
// in-game. For example "Mk1-2 Command Pod".
//
// Allowed game scenes: any.
func (s *Part) TitleStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Tag - the name tag for the part. Can be set to a custom string using the
// in-game user interface.
//
// Allowed game scenes: any.
func (s *Part) Tag() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Part_get_Tag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TagStream - the name tag for the part. Can be set to a custom string using
// the in-game user interface.
//
// Allowed game scenes: any.
func (s *Part) TagStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Tag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTag - the name tag for the part. Can be set to a custom string using the
// in-game user interface.
//
// Allowed game scenes: any.
func (s *Part) SetTag(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_set_Tag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// FlagURL - the asset URL for the part's flag.
//
// Allowed game scenes: any.
func (s *Part) FlagURL() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Part_get_FlagURL",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FlagURLStream - the asset URL for the part's flag.
//
// Allowed game scenes: any.
func (s *Part) FlagURLStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_FlagURL",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetFlagURL - the asset URL for the part's flag.
//
// Allowed game scenes: any.
func (s *Part) SetFlagURL(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_set_FlagURL",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Highlighted - whether the part is highlighted.
//
// Allowed game scenes: any.
func (s *Part) Highlighted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Part_get_Highlighted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HighlightedStream - whether the part is highlighted.
//
// Allowed game scenes: any.
func (s *Part) HighlightedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Highlighted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetHighlighted - whether the part is highlighted.
//
// Allowed game scenes: any.
func (s *Part) SetHighlighted(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_set_Highlighted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// HighlightColor - the color used to highlight the part, as an RGB triple.
//
// Allowed game scenes: any.
func (s *Part) HighlightColor() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Part_get_HighlightColor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HighlightColorStream - the color used to highlight the part, as an RGB
// triple.
//
// Allowed game scenes: any.
func (s *Part) HighlightColorStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_HighlightColor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetHighlightColor - the color used to highlight the part, as an RGB triple.
//
// Allowed game scenes: any.
func (s *Part) SetHighlightColor(value types.Tuple3[float64, float64, float64]) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_set_HighlightColor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Cost - the cost of the part, in units of funds.
//
// Allowed game scenes: any.
func (s *Part) Cost() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Part_get_Cost",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CostStream - the cost of the part, in units of funds.
//
// Allowed game scenes: any.
func (s *Part) CostStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Cost",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Vessel - the vessel that contains this part.
//
// Allowed game scenes: any.
func (s *Part) Vessel() (*Vessel, error) {
	var err error
	var argBytes []byte
	var vv Vessel
	request := &types.ProcedureCall{
		Procedure: "Part_get_Vessel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Parent - the parts parent. Returns nil if the part does not have a parent.
// This, in combination with <see cref="M:SpaceCenter.Part.Children" />, can be
// used to traverse the vessels parts tree.
//
// Allowed game scenes: any.
func (s *Part) Parent() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Part_get_Parent",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Children - the parts children. Returns an empty list if the part has no
// children. This, in combination with <see cref="M:SpaceCenter.Part.Parent" />,
// can be used to traverse the vessels parts tree.
//
// Allowed game scenes: any.
func (s *Part) Children() ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Part_get_Children",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ChildrenStream - the parts children. Returns an empty list if the part has no
// children. This, in combination with <see cref="M:SpaceCenter.Part.Parent" />,
// can be used to traverse the vessels parts tree.
//
// Allowed game scenes: any.
func (s *Part) ChildrenStream() (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Children",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AxiallyAttached - whether the part is axially attached to its parent, i.e. on
// the top or bottom of its parent. If the part has no parent, returns false.
//
// Allowed game scenes: any.
func (s *Part) AxiallyAttached() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Part_get_AxiallyAttached",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AxiallyAttachedStream - whether the part is axially attached to its parent,
// i.e. on the top or bottom of its parent. If the part has no parent, returns
// false.
//
// Allowed game scenes: any.
func (s *Part) AxiallyAttachedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_AxiallyAttached",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RadiallyAttached - whether the part is radially attached to its parent, i.e.
// on the side of its parent. If the part has no parent, returns false.
//
// Allowed game scenes: any.
func (s *Part) RadiallyAttached() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Part_get_RadiallyAttached",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RadiallyAttachedStream - whether the part is radially attached to its parent,
// i.e. on the side of its parent. If the part has no parent, returns false.
//
// Allowed game scenes: any.
func (s *Part) RadiallyAttachedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_RadiallyAttached",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Stage - the stage in which this part will be activated. Returns -1 if the
// part is not activated by staging.
//
// Allowed game scenes: any.
func (s *Part) Stage() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "Part_get_Stage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StageStream - the stage in which this part will be activated. Returns -1 if
// the part is not activated by staging.
//
// Allowed game scenes: any.
func (s *Part) StageStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Stage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DecoupleStage - the stage in which this part will be decoupled. Returns -1 if
// the part is never decoupled from the vessel.
//
// Allowed game scenes: any.
func (s *Part) DecoupleStage() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "Part_get_DecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DecoupleStageStream - the stage in which this part will be decoupled. Returns
// -1 if the part is never decoupled from the vessel.
//
// Allowed game scenes: any.
func (s *Part) DecoupleStageStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_DecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Massless - whether the part is <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Massless_part">massless</a>.
//
// Allowed game scenes: any.
func (s *Part) Massless() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Part_get_Massless",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MasslessStream - whether the part is <a
// href="https://wiki.kerbalspaceprogram.com/wiki/MasslessStream_part">massless</a>.
//
// Allowed game scenes: any.
func (s *Part) MasslessStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Massless",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Mass - the current mass of the part, including resources it contains, in
// kilograms. Returns zero if the part is massless.
//
// Allowed game scenes: any.
func (s *Part) Mass() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Part_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MassStream - the current mass of the part, including resources it contains,
// in kilograms. Returns zero if the part is massless.
//
// Allowed game scenes: any.
func (s *Part) MassStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DryMass - the mass of the part, not including any resources it contains, in
// kilograms. Returns zero if the part is massless.
//
// Allowed game scenes: any.
func (s *Part) DryMass() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Part_get_DryMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DryMassStream - the mass of the part, not including any resources it
// contains, in kilograms. Returns zero if the part is massless.
//
// Allowed game scenes: any.
func (s *Part) DryMassStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_DryMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Shielded - whether the part is shielded from the exterior of the vessel, for
// example by a fairing.
//
// Allowed game scenes: any.
func (s *Part) Shielded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Part_get_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ShieldedStream - whether the part is shielded from the exterior of the
// vessel, for example by a fairing.
//
// Allowed game scenes: any.
func (s *Part) ShieldedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Shielded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DynamicPressure - the dynamic pressure acting on the part, in Pascals.
//
// Allowed game scenes: any.
func (s *Part) DynamicPressure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Part_get_DynamicPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DynamicPressureStream - the dynamic pressure acting on the part, in Pascals.
//
// Allowed game scenes: any.
func (s *Part) DynamicPressureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_DynamicPressure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ImpactTolerance - the impact tolerance of the part, in meters per second.
//
// Allowed game scenes: any.
func (s *Part) ImpactTolerance() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Part_get_ImpactTolerance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ImpactToleranceStream - the impact tolerance of the part, in meters per
// second.
//
// Allowed game scenes: any.
func (s *Part) ImpactToleranceStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_ImpactTolerance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Temperature - temperature of the part, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) Temperature() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Part_get_Temperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TemperatureStream - temperature of the part, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) TemperatureStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Temperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SkinTemperature - temperature of the skin of the part, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) SkinTemperature() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Part_get_SkinTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SkinTemperatureStream - temperature of the skin of the part, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) SkinTemperatureStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_SkinTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxTemperature - maximum temperature that the part can survive, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) MaxTemperature() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Part_get_MaxTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxTemperatureStream - maximum temperature that the part can survive, in
// Kelvin.
//
// Allowed game scenes: any.
func (s *Part) MaxTemperatureStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_MaxTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxSkinTemperature - maximum temperature that the skin of the part can
// survive, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) MaxSkinTemperature() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Part_get_MaxSkinTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxSkinTemperatureStream - maximum temperature that the skin of the part can
// survive, in Kelvin.
//
// Allowed game scenes: any.
func (s *Part) MaxSkinTemperatureStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_MaxSkinTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalMass - a measure of how much energy it takes to increase the internal
// temperature of the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) ThermalMass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalMassStream - a measure of how much energy it takes to increase the
// internal temperature of the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) ThermalMassStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalSkinMass - a measure of how much energy it takes to increase the skin
// temperature of the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) ThermalSkinMass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalSkinMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalSkinMassStream - a measure of how much energy it takes to increase the
// skin temperature of the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) ThermalSkinMassStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalSkinMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalResourceMass - a measure of how much energy it takes to increase the
// temperature of the resources contained in the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) ThermalResourceMass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalResourceMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalResourceMassStream - a measure of how much energy it takes to increase
// the temperature of the resources contained in the part, in Joules per Kelvin.
//
// Allowed game scenes: any.
func (s *Part) ThermalResourceMassStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalResourceMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalInternalFlux - the rate at which heat energy is begin generated by the
// part. For example, some engines generate heat by combusting fuel. Measured in
// energy per unit time, or power, in Watts. A positive value means the part is
// gaining heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalInternalFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalInternalFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalInternalFluxStream - the rate at which heat energy is begin generated
// by the part. For example, some engines generate heat by combusting fuel.
// Measured in energy per unit time, or power, in Watts. A positive value means
// the part is gaining heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalInternalFluxStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalInternalFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalConductionFlux - the rate at which heat energy is conducting into or
// out of the part via contact with other parts. Measured in energy per unit
// time, or power, in Watts. A positive value means the part is gaining heat
// energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalConductionFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalConductionFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalConductionFluxStream - the rate at which heat energy is conducting
// into or out of the part via contact with other parts. Measured in energy per
// unit time, or power, in Watts. A positive value means the part is gaining
// heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalConductionFluxStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalConductionFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalConvectionFlux - the rate at which heat energy is convecting into or
// out of the part from the surrounding atmosphere. Measured in energy per unit
// time, or power, in Watts. A positive value means the part is gaining heat
// energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalConvectionFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalConvectionFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalConvectionFluxStream - the rate at which heat energy is convecting
// into or out of the part from the surrounding atmosphere. Measured in energy
// per unit time, or power, in Watts. A positive value means the part is gaining
// heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalConvectionFluxStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalConvectionFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalRadiationFlux - the rate at which heat energy is radiating into or out
// of the part from the surrounding environment. Measured in energy per unit
// time, or power, in Watts. A positive value means the part is gaining heat
// energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalRadiationFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalRadiationFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalRadiationFluxStream - the rate at which heat energy is radiating into
// or out of the part from the surrounding environment. Measured in energy per
// unit time, or power, in Watts. A positive value means the part is gaining
// heat energy, and negative means it is losing heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalRadiationFluxStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalRadiationFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalSkinToInternalFlux - the rate at which heat energy is transferring
// between the part's skin and its internals. Measured in energy per unit time,
// or power, in Watts. A positive value means the part's internals are gaining
// heat energy, and negative means its skin is gaining heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalSkinToInternalFlux() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalSkinToInternalFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalSkinToInternalFluxStream - the rate at which heat energy is
// transferring between the part's skin and its internals. Measured in energy
// per unit time, or power, in Watts. A positive value means the part's
// internals are gaining heat energy, and negative means its skin is gaining
// heat energy.
//
// Allowed game scenes: any.
func (s *Part) ThermalSkinToInternalFluxStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_ThermalSkinToInternalFlux",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Resources - a <see cref="T:SpaceCenter.Resources" /> object for the part.
//
// Allowed game scenes: any.
func (s *Part) Resources() (*Resources, error) {
	var err error
	var argBytes []byte
	var vv Resources
	request := &types.ProcedureCall{
		Procedure: "Part_get_Resources",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AvailableSeats - how many open seats the part has.
//
// Allowed game scenes: any.
func (s *Part) AvailableSeats() (uint32, error) {
	var err error
	var argBytes []byte
	var vv uint32
	request := &types.ProcedureCall{
		Procedure: "Part_get_AvailableSeats",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableSeatsStream - how many open seats the part has.
//
// Allowed game scenes: any.
func (s *Part) AvailableSeatsStream() (*krpcgo.Stream[uint32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_AvailableSeats",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) uint32 {
		var value uint32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Crossfeed - whether this part is crossfeed capable.
//
// Allowed game scenes: any.
func (s *Part) Crossfeed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Part_get_Crossfeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CrossfeedStream - whether this part is crossfeed capable.
//
// Allowed game scenes: any.
func (s *Part) CrossfeedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Crossfeed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IsFuelLine - whether this part is a fuel line.
//
// Allowed game scenes: any.
func (s *Part) IsFuelLine() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Part_get_IsFuelLine",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsFuelLineStream - whether this part is a fuel line.
//
// Allowed game scenes: any.
func (s *Part) IsFuelLineStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_IsFuelLine",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FuelLinesFrom - the parts that are connected to this part via fuel lines,
// where the direction of the fuel line is into this part.
//
// Allowed game scenes: any.
func (s *Part) FuelLinesFrom() ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Part_get_FuelLinesFrom",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// FuelLinesFromStream - the parts that are connected to this part via fuel
// lines, where the direction of the fuel line is into this part.
//
// Allowed game scenes: any.
func (s *Part) FuelLinesFromStream() (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_FuelLinesFrom",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FuelLinesTo - the parts that are connected to this part via fuel lines, where
// the direction of the fuel line is out of this part.
//
// Allowed game scenes: any.
func (s *Part) FuelLinesTo() ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Part_get_FuelLinesTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// FuelLinesToStream - the parts that are connected to this part via fuel lines,
// where the direction of the fuel line is out of this part.
//
// Allowed game scenes: any.
func (s *Part) FuelLinesToStream() (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_FuelLinesTo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Modules - the modules for this part.
//
// Allowed game scenes: any.
func (s *Part) Modules() ([]*Module, error) {
	var err error
	var argBytes []byte
	var vv []*Module
	request := &types.ProcedureCall{
		Procedure: "Part_get_Modules",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ModulesStream - the modules for this part.
//
// Allowed game scenes: any.
func (s *Part) ModulesStream() (*krpcgo.Stream[[]*Module], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Modules",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Module {
		var value []*Module
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Antenna - an <see cref="T:SpaceCenter.Antenna" /> if the part is an antenna,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Antenna() (*Antenna, error) {
	var err error
	var argBytes []byte
	var vv Antenna
	request := &types.ProcedureCall{
		Procedure: "Part_get_Antenna",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// CargoBay - a <see cref="T:SpaceCenter.CargoBay" /> if the part is a cargo
// bay, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) CargoBay() (*CargoBay, error) {
	var err error
	var argBytes []byte
	var vv CargoBay
	request := &types.ProcedureCall{
		Procedure: "Part_get_CargoBay",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ControlSurface - a <see cref="T:SpaceCenter.ControlSurface" /> if the part is
// an aerodynamic control surface, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) ControlSurface() (*ControlSurface, error) {
	var err error
	var argBytes []byte
	var vv ControlSurface
	request := &types.ProcedureCall{
		Procedure: "Part_get_ControlSurface",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Decoupler - a <see cref="T:SpaceCenter.Decoupler" /> if the part is a
// decoupler, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Decoupler() (*Decoupler, error) {
	var err error
	var argBytes []byte
	var vv Decoupler
	request := &types.ProcedureCall{
		Procedure: "Part_get_Decoupler",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// DockingPort - a <see cref="T:SpaceCenter.DockingPort" /> if the part is a
// docking port, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) DockingPort() (*DockingPort, error) {
	var err error
	var argBytes []byte
	var vv DockingPort
	request := &types.ProcedureCall{
		Procedure: "Part_get_DockingPort",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ResourceDrain - a <see cref="T:SpaceCenter.ResourceDrain" /> if the part is a
// resource drain, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) ResourceDrain() (*ResourceDrain, error) {
	var err error
	var argBytes []byte
	var vv ResourceDrain
	request := &types.ProcedureCall{
		Procedure: "Part_get_ResourceDrain",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Engine - an <see cref="T:SpaceCenter.Engine" /> if the part is an engine,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Engine() (*Engine, error) {
	var err error
	var argBytes []byte
	var vv Engine
	request := &types.ProcedureCall{
		Procedure: "Part_get_Engine",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Experiment - an <see cref="T:SpaceCenter.Experiment" /> if the part contains
// a single science experiment, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Experiment() (*Experiment, error) {
	var err error
	var argBytes []byte
	var vv Experiment
	request := &types.ProcedureCall{
		Procedure: "Part_get_Experiment",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Experiments - a list of <see cref="T:SpaceCenter.Experiment" /> objects that
// the part contains.
//
// Allowed game scenes: any.
func (s *Part) Experiments() ([]*Experiment, error) {
	var err error
	var argBytes []byte
	var vv []*Experiment
	request := &types.ProcedureCall{
		Procedure: "Part_get_Experiments",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ExperimentsStream - a list of <see cref="T:SpaceCenter.Experiment" /> objects
// that the part contains.
//
// Allowed game scenes: any.
func (s *Part) ExperimentsStream() (*krpcgo.Stream[[]*Experiment], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_Experiments",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Experiment {
		var value []*Experiment
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Fairing - a <see cref="T:SpaceCenter.Fairing" /> if the part is a fairing,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Fairing() (*Fairing, error) {
	var err error
	var argBytes []byte
	var vv Fairing
	request := &types.ProcedureCall{
		Procedure: "Part_get_Fairing",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Intake - an <see cref="T:SpaceCenter.Intake" /> if the part is an intake,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Intake() (*Intake, error) {
	var err error
	var argBytes []byte
	var vv Intake
	request := &types.ProcedureCall{
		Procedure: "Part_get_Intake",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Leg - a <see cref="T:SpaceCenter.Leg" /> if the part is a landing leg,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Leg() (*Leg, error) {
	var err error
	var argBytes []byte
	var vv Leg
	request := &types.ProcedureCall{
		Procedure: "Part_get_Leg",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// LaunchClamp - a <see cref="T:SpaceCenter.LaunchClamp" /> if the part is a
// launch clamp, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) LaunchClamp() (*LaunchClamp, error) {
	var err error
	var argBytes []byte
	var vv LaunchClamp
	request := &types.ProcedureCall{
		Procedure: "Part_get_LaunchClamp",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Light - a <see cref="T:SpaceCenter.Light" /> if the part is a light,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Light() (*Light, error) {
	var err error
	var argBytes []byte
	var vv Light
	request := &types.ProcedureCall{
		Procedure: "Part_get_Light",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Parachute - a <see cref="T:SpaceCenter.Parachute" /> if the part is a
// parachute, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Parachute() (*Parachute, error) {
	var err error
	var argBytes []byte
	var vv Parachute
	request := &types.ProcedureCall{
		Procedure: "Part_get_Parachute",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Radiator - a <see cref="T:SpaceCenter.Radiator" /> if the part is a radiator,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Radiator() (*Radiator, error) {
	var err error
	var argBytes []byte
	var vv Radiator
	request := &types.ProcedureCall{
		Procedure: "Part_get_Radiator",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// RCS - a <see cref="T:SpaceCenter.RCS" /> if the part is an RCS
// block/thruster, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) RCS() (*RCS, error) {
	var err error
	var argBytes []byte
	var vv RCS
	request := &types.ProcedureCall{
		Procedure: "Part_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ReactionWheel - a <see cref="T:SpaceCenter.ReactionWheel" /> if the part is a
// reaction wheel, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) ReactionWheel() (*ReactionWheel, error) {
	var err error
	var argBytes []byte
	var vv ReactionWheel
	request := &types.ProcedureCall{
		Procedure: "Part_get_ReactionWheel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ResourceConverter - a <see cref="T:SpaceCenter.ResourceConverter" /> if the
// part is a resource converter, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) ResourceConverter() (*ResourceConverter, error) {
	var err error
	var argBytes []byte
	var vv ResourceConverter
	request := &types.ProcedureCall{
		Procedure: "Part_get_ResourceConverter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ResourceHarvester - a <see cref="T:SpaceCenter.ResourceHarvester" /> if the
// part is a resource harvester, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) ResourceHarvester() (*ResourceHarvester, error) {
	var err error
	var argBytes []byte
	var vv ResourceHarvester
	request := &types.ProcedureCall{
		Procedure: "Part_get_ResourceHarvester",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Sensor - a <see cref="T:SpaceCenter.Sensor" /> if the part is a sensor,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Sensor() (*Sensor, error) {
	var err error
	var argBytes []byte
	var vv Sensor
	request := &types.ProcedureCall{
		Procedure: "Part_get_Sensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SolarPanel - a <see cref="T:SpaceCenter.SolarPanel" /> if the part is a solar
// panel, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) SolarPanel() (*SolarPanel, error) {
	var err error
	var argBytes []byte
	var vv SolarPanel
	request := &types.ProcedureCall{
		Procedure: "Part_get_SolarPanel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Wheel - a <see cref="T:SpaceCenter.Wheel" /> if the part is a wheel,
// otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) Wheel() (*Wheel, error) {
	var err error
	var argBytes []byte
	var vv Wheel
	request := &types.ProcedureCall{
		Procedure: "Part_get_Wheel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// RoboticController - a <see cref="T:SpaceCenter.RoboticController" /> if the
// part is a robotic controller, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) RoboticController() (*RoboticController, error) {
	var err error
	var argBytes []byte
	var vv RoboticController
	request := &types.ProcedureCall{
		Procedure: "Part_get_RoboticController",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// RoboticHinge - a <see cref="T:SpaceCenter.RoboticHinge" /> if the part is a
// robotic hinge, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) RoboticHinge() (*RoboticHinge, error) {
	var err error
	var argBytes []byte
	var vv RoboticHinge
	request := &types.ProcedureCall{
		Procedure: "Part_get_RoboticHinge",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// RoboticPiston - a <see cref="T:SpaceCenter.RoboticPiston" /> if the part is a
// robotic piston, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) RoboticPiston() (*RoboticPiston, error) {
	var err error
	var argBytes []byte
	var vv RoboticPiston
	request := &types.ProcedureCall{
		Procedure: "Part_get_RoboticPiston",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// RoboticRotation - a <see cref="T:SpaceCenter.RoboticRotation" /> if the part
// is a robotic rotation servo, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) RoboticRotation() (*RoboticRotation, error) {
	var err error
	var argBytes []byte
	var vv RoboticRotation
	request := &types.ProcedureCall{
		Procedure: "Part_get_RoboticRotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// RoboticRotor - a <see cref="T:SpaceCenter.RoboticRotor" /> if the part is a
// robotic rotor, otherwise nil.
//
// Allowed game scenes: any.
func (s *Part) RoboticRotor() (*RoboticRotor, error) {
	var err error
	var argBytes []byte
	var vv RoboticRotor
	request := &types.ProcedureCall{
		Procedure: "Part_get_RoboticRotor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// MomentOfInertia - the moment of inertia of the part in <math>kg.m^2</math>
// around its center of mass in the parts reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />).
//
// Allowed game scenes: any.
func (s *Part) MomentOfInertia() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Part_get_MomentOfInertia",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MomentOfInertiaStream - the moment of inertia of the part in
// <math>kg.m^2</math> around its center of mass in the parts reference frame
// (<see cref="T:SpaceCenter.ReferenceFrame" />).
//
// Allowed game scenes: any.
func (s *Part) MomentOfInertiaStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_MomentOfInertia",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// InertiaTensor - the inertia tensor of the part in the parts reference frame
// (<see cref="T:SpaceCenter.ReferenceFrame" />). Returns the 3x3 matrix as a
// list of elements, in row-major order.
//
// Allowed game scenes: any.
func (s *Part) InertiaTensor() ([]float64, error) {
	var err error
	var argBytes []byte
	var vv []float64
	request := &types.ProcedureCall{
		Procedure: "Part_get_InertiaTensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InertiaTensorStream - the inertia tensor of the part in the parts reference
// frame (<see cref="T:SpaceCenter.ReferenceFrame" />). Returns the 3x3 matrix
// as a list of elements, in row-major order.
//
// Allowed game scenes: any.
func (s *Part) InertiaTensorStream() (*krpcgo.Stream[[]float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_InertiaTensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []float64 {
		var value []float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReferenceFrame - the reference frame that is fixed relative to this part, and
// centered on a fixed position within the part, defined by the parts model.
// <list type="bullet"><item><description>The origin is at the position of the
// part, as returned by <see cref="M:SpaceCenter.Part.Position"
// />.</description></item><item><description>The axes rotate with the
// part.</description></item><item><description>The x, y and z axis directions
// depend on the design of the part. </description></item></list>
//
// Allowed game scenes: any.
func (s *Part) ReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Part_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// CenterOfMassReferenceFrame - the reference frame that is fixed relative to
// this part, and centered on its center of mass. <list
// type="bullet"><item><description>The origin is at the center of mass of the
// part, as returned by <see cref="M:SpaceCenter.Part.CenterOfMass"
// />.</description></item><item><description>The axes rotate with the
// part.</description></item><item><description>The x, y and z axis directions
// depend on the design of the part. </description></item></list>
//
// Allowed game scenes: any.
func (s *Part) CenterOfMassReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Part_get_CenterOfMassReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetGlow - whether the part is glowing.
//
// Allowed game scenes: any.
func (s *Part) SetGlow(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_set_Glow",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AutoStrutMode - auto-strut mode.
//
// Allowed game scenes: any.
func (s *Part) AutoStrutMode() (AutoStrutMode, error) {
	var err error
	var argBytes []byte
	var vv AutoStrutMode
	request := &types.ProcedureCall{
		Procedure: "Part_get_AutoStrutMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AutoStrutModeStream - auto-strut mode.
//
// Allowed game scenes: any.
func (s *Part) AutoStrutModeStream() (*krpcgo.Stream[AutoStrutMode], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Part_get_AutoStrutMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) AutoStrutMode {
		var value AutoStrutMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// WithName - a list of parts whose <see cref="M:SpaceCenter.Part.Name" /> is
// <paramref name="name" />.
//
// Allowed game scenes: any.
func (s *Parts) WithName(name string) ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Parts_WithName",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// WithNameStream - a list of parts whose <see cref="M:SpaceCenter.Part.Name" />
// is <paramref name="name" />.
//
// Allowed game scenes: any.
func (s *Parts) WithNameStream(name string) (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_WithName",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// WithTitle - a list of all parts whose <see cref="M:SpaceCenter.Part.Title" />
// is <paramref name="title" />.
//
// Allowed game scenes: any.
func (s *Parts) WithTitle(title string) ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Parts_WithTitle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// WithTitleStream - a list of all parts whose <see
// cref="M:SpaceCenter.Part.Title" /> is <paramref name="title" />.
//
// Allowed game scenes: any.
func (s *Parts) WithTitleStream(title string) (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_WithTitle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(title)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// WithTag - a list of all parts whose <see cref="M:SpaceCenter.Part.Tag" /> is
// <paramref name="tag" />.
//
// Allowed game scenes: any.
func (s *Parts) WithTag(tag string) ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Parts_WithTag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(tag)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// WithTagStream - a list of all parts whose <see cref="M:SpaceCenter.Part.Tag"
// /> is <paramref name="tag" />.
//
// Allowed game scenes: any.
func (s *Parts) WithTagStream(tag string) (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_WithTag",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(tag)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// WithModule - a list of all parts that contain a <see
// cref="T:SpaceCenter.Module" /> whose <see cref="M:SpaceCenter.Module.Name" />
// is <paramref name="moduleName" />.
//
// Allowed game scenes: any.
func (s *Parts) WithModule(moduleName string) ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Parts_WithModule",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(moduleName)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// WithModuleStream - a list of all parts that contain a <see
// cref="T:SpaceCenter.Module" /> whose <see cref="M:SpaceCenter.Module.Name" />
// is <paramref name="moduleName" />.
//
// Allowed game scenes: any.
func (s *Parts) WithModuleStream(moduleName string) (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_WithModule",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(moduleName)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// InStage - a list of all parts that are activated in the given <paramref
// name="stage" />.
//
// Allowed game scenes: any.
func (s *Parts) InStage(stage int32) ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Parts_InStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// InStageStream - a list of all parts that are activated in the given <paramref
// name="stage" />.
//
// Allowed game scenes: any.
func (s *Parts) InStageStream(stage int32) (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_InStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// InDecoupleStage - a list of all parts that are decoupled in the given
// <paramref name="stage" />.
//
// Allowed game scenes: any.
func (s *Parts) InDecoupleStage(stage int32) ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Parts_InDecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// InDecoupleStageStream - a list of all parts that are decoupled in the given
// <paramref name="stage" />.
//
// Allowed game scenes: any.
func (s *Parts) InDecoupleStageStream(stage int32) (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_InDecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ModulesWithName - a list of modules (combined across all parts in the vessel)
// whose <see cref="M:SpaceCenter.Module.Name" /> is <paramref name="moduleName"
// />.
//
// Allowed game scenes: any.
func (s *Parts) ModulesWithName(moduleName string) ([]*Module, error) {
	var err error
	var argBytes []byte
	var vv []*Module
	request := &types.ProcedureCall{
		Procedure: "Parts_ModulesWithName",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(moduleName)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ModulesWithNameStream - a list of modules (combined across all parts in the
// vessel) whose <see cref="M:SpaceCenter.Module.Name" /> is <paramref
// name="moduleName" />.
//
// Allowed game scenes: any.
func (s *Parts) ModulesWithNameStream(moduleName string) (*krpcgo.Stream[[]*Module], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_ModulesWithName",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(moduleName)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Module {
		var value []*Module
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// All - a list of all of the vessels parts.
//
// Allowed game scenes: any.
func (s *Parts) All() ([]*Part, error) {
	var err error
	var argBytes []byte
	var vv []*Part
	request := &types.ProcedureCall{
		Procedure: "Parts_get_All",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// AllStream - a list of all of the vessels parts.
//
// AllStreamowed game scenes: any.
func (s *Parts) AllStream() (*krpcgo.Stream[[]*Part], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_All",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Part {
		var value []*Part
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Root - the vessels root part.
//
// Allowed game scenes: any.
func (s *Parts) Root() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Root",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Controlling - the part from which the vessel is controlled.
//
// Allowed game scenes: any.
func (s *Parts) Controlling() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Controlling",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetControlling - the part from which the vessel is controlled.
//
// Allowed game scenes: any.
func (s *Parts) SetControlling(value *Part) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_set_Controlling",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Antennas - a list of all antennas in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Antennas() ([]*Antenna, error) {
	var err error
	var argBytes []byte
	var vv []*Antenna
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// AntennasStream - a list of all antennas in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) AntennasStream() (*krpcgo.Stream[[]*Antenna], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Antennas",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Antenna {
		var value []*Antenna
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ControlSurfaces - a list of all control surfaces in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ControlSurfaces() ([]*ControlSurface, error) {
	var err error
	var argBytes []byte
	var vv []*ControlSurface
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ControlSurfaces",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ControlSurfacesStream - a list of all control surfaces in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ControlSurfacesStream() (*krpcgo.Stream[[]*ControlSurface], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ControlSurfaces",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*ControlSurface {
		var value []*ControlSurface
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CargoBays - a list of all cargo bays in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) CargoBays() ([]*CargoBay, error) {
	var err error
	var argBytes []byte
	var vv []*CargoBay
	request := &types.ProcedureCall{
		Procedure: "Parts_get_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// CargoBaysStream - a list of all cargo bays in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) CargoBaysStream() (*krpcgo.Stream[[]*CargoBay], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_CargoBays",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*CargoBay {
		var value []*CargoBay
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Decouplers - a list of all decouplers in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Decouplers() ([]*Decoupler, error) {
	var err error
	var argBytes []byte
	var vv []*Decoupler
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Decouplers",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// DecouplersStream - a list of all decouplers in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) DecouplersStream() (*krpcgo.Stream[[]*Decoupler], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Decouplers",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Decoupler {
		var value []*Decoupler
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DockingPorts - a list of all docking ports in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) DockingPorts() ([]*DockingPort, error) {
	var err error
	var argBytes []byte
	var vv []*DockingPort
	request := &types.ProcedureCall{
		Procedure: "Parts_get_DockingPorts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// DockingPortsStream - a list of all docking ports in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) DockingPortsStream() (*krpcgo.Stream[[]*DockingPort], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_DockingPorts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*DockingPort {
		var value []*DockingPort
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Engines - a list of all engines in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Engines() ([]*Engine, error) {
	var err error
	var argBytes []byte
	var vv []*Engine
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Engines",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// EnginesStream - a list of all engines in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) EnginesStream() (*krpcgo.Stream[[]*Engine], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Engines",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Engine {
		var value []*Engine
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Experiments - a list of all science experiments in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Experiments() ([]*Experiment, error) {
	var err error
	var argBytes []byte
	var vv []*Experiment
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Experiments",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ExperimentsStream - a list of all science experiments in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ExperimentsStream() (*krpcgo.Stream[[]*Experiment], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Experiments",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Experiment {
		var value []*Experiment
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Fairings - a list of all fairings in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Fairings() ([]*Fairing, error) {
	var err error
	var argBytes []byte
	var vv []*Fairing
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Fairings",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// FairingsStream - a list of all fairings in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) FairingsStream() (*krpcgo.Stream[[]*Fairing], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Fairings",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Fairing {
		var value []*Fairing
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Intakes - a list of all intakes in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Intakes() ([]*Intake, error) {
	var err error
	var argBytes []byte
	var vv []*Intake
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// IntakesStream - a list of all intakes in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) IntakesStream() (*krpcgo.Stream[[]*Intake], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Intakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Intake {
		var value []*Intake
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Legs - a list of all landing legs attached to the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Legs() ([]*Leg, error) {
	var err error
	var argBytes []byte
	var vv []*Leg
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// LegsStream - a list of all landing legs attached to the vessel.
//
// Allowed game scenes: any.
func (s *Parts) LegsStream() (*krpcgo.Stream[[]*Leg], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Legs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Leg {
		var value []*Leg
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// LaunchClamps - a list of all launch clamps attached to the vessel.
//
// Allowed game scenes: any.
func (s *Parts) LaunchClamps() ([]*LaunchClamp, error) {
	var err error
	var argBytes []byte
	var vv []*LaunchClamp
	request := &types.ProcedureCall{
		Procedure: "Parts_get_LaunchClamps",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// LaunchClampsStream - a list of all launch clamps attached to the vessel.
//
// Allowed game scenes: any.
func (s *Parts) LaunchClampsStream() (*krpcgo.Stream[[]*LaunchClamp], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_LaunchClamps",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*LaunchClamp {
		var value []*LaunchClamp
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Lights - a list of all lights in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Lights() ([]*Light, error) {
	var err error
	var argBytes []byte
	var vv []*Light
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// LightsStream - a list of all lights in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) LightsStream() (*krpcgo.Stream[[]*Light], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Lights",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Light {
		var value []*Light
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Parachutes - a list of all parachutes in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Parachutes() ([]*Parachute, error) {
	var err error
	var argBytes []byte
	var vv []*Parachute
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ParachutesStream - a list of all parachutes in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ParachutesStream() (*krpcgo.Stream[[]*Parachute], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Parachutes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Parachute {
		var value []*Parachute
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Radiators - a list of all radiators in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Radiators() ([]*Radiator, error) {
	var err error
	var argBytes []byte
	var vv []*Radiator
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// RadiatorsStream - a list of all radiators in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RadiatorsStream() (*krpcgo.Stream[[]*Radiator], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Radiators",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Radiator {
		var value []*Radiator
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RCS - a list of all RCS blocks/thrusters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RCS() ([]*RCS, error) {
	var err error
	var argBytes []byte
	var vv []*RCS
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// RCSStream - a list of all RCSStream blocks/thrusters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RCSStream() (*krpcgo.Stream[[]*RCS], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RCS",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*RCS {
		var value []*RCS
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReactionWheels - a list of all reaction wheels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ReactionWheels() ([]*ReactionWheel, error) {
	var err error
	var argBytes []byte
	var vv []*ReactionWheel
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ReactionWheelsStream - a list of all reaction wheels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ReactionWheelsStream() (*krpcgo.Stream[[]*ReactionWheel], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ReactionWheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*ReactionWheel {
		var value []*ReactionWheel
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ResourceConverters - a list of all resource converters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ResourceConverters() ([]*ResourceConverter, error) {
	var err error
	var argBytes []byte
	var vv []*ResourceConverter
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ResourceConverters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ResourceConvertersStream - a list of all resource converters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ResourceConvertersStream() (*krpcgo.Stream[[]*ResourceConverter], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ResourceConverters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*ResourceConverter {
		var value []*ResourceConverter
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ResourceHarvesters - a list of all resource harvesters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ResourceHarvesters() ([]*ResourceHarvester, error) {
	var err error
	var argBytes []byte
	var vv []*ResourceHarvester
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ResourceHarvestersStream - a list of all resource harvesters in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ResourceHarvestersStream() (*krpcgo.Stream[[]*ResourceHarvester], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ResourceHarvesters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*ResourceHarvester {
		var value []*ResourceHarvester
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Sensors - a list of all sensors in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Sensors() ([]*Sensor, error) {
	var err error
	var argBytes []byte
	var vv []*Sensor
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Sensors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// SensorsStream - a list of all sensors in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) SensorsStream() (*krpcgo.Stream[[]*Sensor], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Sensors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Sensor {
		var value []*Sensor
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SolarPanels - a list of all solar panels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) SolarPanels() ([]*SolarPanel, error) {
	var err error
	var argBytes []byte
	var vv []*SolarPanel
	request := &types.ProcedureCall{
		Procedure: "Parts_get_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// SolarPanelsStream - a list of all solar panels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) SolarPanelsStream() (*krpcgo.Stream[[]*SolarPanel], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_SolarPanels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*SolarPanel {
		var value []*SolarPanel
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Wheels - a list of all wheels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) Wheels() ([]*Wheel, error) {
	var err error
	var argBytes []byte
	var vv []*Wheel
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// WheelsStream - a list of all wheels in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) WheelsStream() (*krpcgo.Stream[[]*Wheel], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_Wheels",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Wheel {
		var value []*Wheel
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RoboticHinges - a list of all robotic hinges in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RoboticHinges() ([]*RoboticHinge, error) {
	var err error
	var argBytes []byte
	var vv []*RoboticHinge
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RoboticHinges",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// RoboticHingesStream - a list of all robotic hinges in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RoboticHingesStream() (*krpcgo.Stream[[]*RoboticHinge], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RoboticHinges",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*RoboticHinge {
		var value []*RoboticHinge
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RoboticPistons - a list of all robotic pistons in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RoboticPistons() ([]*RoboticPiston, error) {
	var err error
	var argBytes []byte
	var vv []*RoboticPiston
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RoboticPistons",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// RoboticPistonsStream - a list of all robotic pistons in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RoboticPistonsStream() (*krpcgo.Stream[[]*RoboticPiston], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RoboticPistons",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*RoboticPiston {
		var value []*RoboticPiston
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RoboticRotations - a list of all robotic rotations in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RoboticRotations() ([]*RoboticRotation, error) {
	var err error
	var argBytes []byte
	var vv []*RoboticRotation
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RoboticRotations",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// RoboticRotationsStream - a list of all robotic rotations in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RoboticRotationsStream() (*krpcgo.Stream[[]*RoboticRotation], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RoboticRotations",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*RoboticRotation {
		var value []*RoboticRotation
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// RoboticRotors - a list of all robotic rotors in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RoboticRotors() ([]*RoboticRotor, error) {
	var err error
	var argBytes []byte
	var vv []*RoboticRotor
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RoboticRotors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// RoboticRotorsStream - a list of all robotic rotors in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) RoboticRotorsStream() (*krpcgo.Stream[[]*RoboticRotor], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_RoboticRotors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*RoboticRotor {
		var value []*RoboticRotor
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ResourceDrains - a list of all resource drains in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ResourceDrains() ([]*ResourceDrain, error) {
	var err error
	var argBytes []byte
	var vv []*ResourceDrain
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ResourceDrains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ResourceDrainsStream - a list of all resource drains in the vessel.
//
// Allowed game scenes: any.
func (s *Parts) ResourceDrainsStream() (*krpcgo.Stream[[]*ResourceDrain], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Parts_get_ResourceDrains",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*ResourceDrain {
		var value []*ResourceDrain
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Name - the name of the propellant.
//
// Allowed game scenes: any.
func (s *Propellant) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the name of the propellant.
//
// Allowed game scenes: any.
func (s *Propellant) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CurrentAmount - the current amount of propellant.
//
// Allowed game scenes: any.
func (s *Propellant) CurrentAmount() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_CurrentAmount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CurrentAmountStream - the current amount of propellant.
//
// Allowed game scenes: any.
func (s *Propellant) CurrentAmountStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_CurrentAmount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CurrentRequirement - the required amount of propellant.
//
// Allowed game scenes: any.
func (s *Propellant) CurrentRequirement() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_CurrentRequirement",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CurrentRequirementStream - the required amount of propellant.
//
// Allowed game scenes: any.
func (s *Propellant) CurrentRequirementStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_CurrentRequirement",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TotalResourceAvailable - the total amount of the underlying resource
// currently reachable given resource flow rules.
//
// Allowed game scenes: any.
func (s *Propellant) TotalResourceAvailable() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_TotalResourceAvailable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TotalResourceAvailableStream - the total amount of the underlying resource
// currently reachable given resource flow rules.
//
// Allowed game scenes: any.
func (s *Propellant) TotalResourceAvailableStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_TotalResourceAvailable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TotalResourceCapacity - the total vehicle capacity for the underlying
// propellant resource, restricted by resource flow rules.
//
// Allowed game scenes: any.
func (s *Propellant) TotalResourceCapacity() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_TotalResourceCapacity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TotalResourceCapacityStream - the total vehicle capacity for the underlying
// propellant resource, restricted by resource flow rules.
//
// Allowed game scenes: any.
func (s *Propellant) TotalResourceCapacityStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_TotalResourceCapacity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IgnoreForIsp - if this propellant should be ignored when calculating required
// mass flow given specific impulse.
//
// Allowed game scenes: any.
func (s *Propellant) IgnoreForIsp() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_IgnoreForIsp",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IgnoreForIspStream - if this propellant should be ignored when calculating
// required mass flow given specific impulse.
//
// Allowed game scenes: any.
func (s *Propellant) IgnoreForIspStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_IgnoreForIsp",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IgnoreForThrustCurve - if this propellant should be ignored for thrust curve
// calculations.
//
// Allowed game scenes: any.
func (s *Propellant) IgnoreForThrustCurve() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_IgnoreForThrustCurve",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IgnoreForThrustCurveStream - if this propellant should be ignored for thrust
// curve calculations.
//
// Allowed game scenes: any.
func (s *Propellant) IgnoreForThrustCurveStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_IgnoreForThrustCurve",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DrawStackGauge - if this propellant has a stack gauge or not.
//
// Allowed game scenes: any.
func (s *Propellant) DrawStackGauge() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_DrawStackGauge",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DrawStackGaugeStream - if this propellant has a stack gauge or not.
//
// Allowed game scenes: any.
func (s *Propellant) DrawStackGaugeStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_DrawStackGauge",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IsDeprived - if this propellant is deprived.
//
// Allowed game scenes: any.
func (s *Propellant) IsDeprived() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_IsDeprived",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsDeprivedStream - if this propellant is deprived.
//
// Allowed game scenes: any.
func (s *Propellant) IsDeprivedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_IsDeprived",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Ratio - the propellant ratio.
//
// Allowed game scenes: any.
func (s *Propellant) Ratio() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_Ratio",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RatioStream - the propellant ratio.
//
// Allowed game scenes: any.
func (s *Propellant) RatioStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Propellant_get_Ratio",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this RCS.
//
// Allowed game scenes: any.
func (s *RCS) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "RCS_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Active - whether the RCS thrusters are active. An RCS thruster is inactive if
// the RCS action group is disabled (<see cref="M:SpaceCenter.Control.RCS" />),
// the RCS thruster itself is not enabled (<see cref="M:SpaceCenter.RCS.Enabled"
// />) or it is covered by a fairing (<see cref="M:SpaceCenter.Part.Shielded"
// />).
//
// Allowed game scenes: any.
func (s *RCS) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RCS_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActiveStream - whether the RCS thrusters are active. An RCS thruster is
// inactive if the RCS action group is disabled (<see
// cref="M:SpaceCenter.Control.RCS" />), the RCS thruster itself is not enabled
// (<see cref="M:SpaceCenter.RCS.Enabled" />) or it is covered by a fairing
// (<see cref="M:SpaceCenter.Part.Shielded" />).
//
// Allowed game scenes: any.
func (s *RCS) ActiveStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Enabled - whether the RCS thrusters are enabled.
//
// Allowed game scenes: any.
func (s *RCS) Enabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RCS_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EnabledStream - whether the RCS thrusters are enabled.
//
// Allowed game scenes: any.
func (s *RCS) EnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetEnabled - whether the RCS thrusters are enabled.
//
// Allowed game scenes: any.
func (s *RCS) SetEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_set_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// PitchEnabled - whether the RCS thruster will fire when pitch control input is
// given.
//
// Allowed game scenes: any.
func (s *RCS) PitchEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RCS_get_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PitchEnabledStream - whether the RCS thruster will fire when pitch control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) PitchEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetPitchEnabled - whether the RCS thruster will fire when pitch control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) SetPitchEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_set_PitchEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// YawEnabled - whether the RCS thruster will fire when yaw control input is
// given.
//
// Allowed game scenes: any.
func (s *RCS) YawEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RCS_get_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// YawEnabledStream - whether the RCS thruster will fire when yaw control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) YawEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetYawEnabled - whether the RCS thruster will fire when yaw control input is
// given.
//
// Allowed game scenes: any.
func (s *RCS) SetYawEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_set_YawEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RollEnabled - whether the RCS thruster will fire when roll control input is
// given.
//
// Allowed game scenes: any.
func (s *RCS) RollEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RCS_get_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RollEnabledStream - whether the RCS thruster will fire when roll control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) RollEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRollEnabled - whether the RCS thruster will fire when roll control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) SetRollEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_set_RollEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ForwardEnabled - whether the RCS thruster will fire when pitch control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) ForwardEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RCS_get_ForwardEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ForwardEnabledStream - whether the RCS thruster will fire when pitch control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) ForwardEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_ForwardEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetForwardEnabled - whether the RCS thruster will fire when pitch control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) SetForwardEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_set_ForwardEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// UpEnabled - whether the RCS thruster will fire when yaw control input is
// given.
//
// Allowed game scenes: any.
func (s *RCS) UpEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RCS_get_UpEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// UpEnabledStream - whether the RCS thruster will fire when yaw control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) UpEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_UpEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetUpEnabled - whether the RCS thruster will fire when yaw control input is
// given.
//
// Allowed game scenes: any.
func (s *RCS) SetUpEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_set_UpEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// RightEnabled - whether the RCS thruster will fire when roll control input is
// given.
//
// Allowed game scenes: any.
func (s *RCS) RightEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RCS_get_RightEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RightEnabledStream - whether the RCS thruster will fire when roll control
// input is given.
//
// Allowed game scenes: any.
func (s *RCS) RightEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_RightEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRightEnabled - whether the RCS thruster will fire when roll control input
// is given.
//
// Allowed game scenes: any.
func (s *RCS) SetRightEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_set_RightEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AvailableTorque - the available torque, in Newton meters, that can be
// produced by this RCS, in the positive and negative pitch, roll and yaw axes
// of the vessel. These axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if RCS is
// disable.
//
// Allowed game scenes: any.
func (s *RCS) AvailableTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "RCS_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableTorqueStream - the available torque, in Newton meters, that can be
// produced by this RCS, in the positive and negative pitch, roll and yaw axes
// of the vessel. These axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if RCS is
// disable.
//
// Allowed game scenes: any.
func (s *RCS) AvailableTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableForce - the available force, in Newtons, that can be produced by
// this RCS, in the positive and negative x, y and z axes of the vessel. These
// axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if RCS is
// disabled.
//
// Allowed game scenes: any.
func (s *RCS) AvailableForce() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "RCS_get_AvailableForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableForceStream - the available force, in Newtons, that can be produced
// by this RCS, in the positive and negative x, y and z axes of the vessel.
// These axes correspond to the coordinate axes of the <see
// cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if RCS is
// disabled.
//
// Allowed game scenes: any.
func (s *RCS) AvailableForceStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_AvailableForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableThrust - the amount of thrust, in Newtons, that would be produced by
// the thruster when activated. Returns zero if the thruster does not have any
// fuel. Takes the thrusters current <see cref="M:SpaceCenter.RCS.ThrustLimit"
// /> and atmospheric conditions into account.
//
// Allowed game scenes: any.
func (s *RCS) AvailableThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RCS_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableThrustStream - the amount of thrust, in Newtons, that would be
// produced by the thruster when activated. Returns zero if the thruster does
// not have any fuel. Takes the thrusters current <see
// cref="M:SpaceCenter.RCS.ThrustLimit" /> and atmospheric conditions into
// account.
//
// Allowed game scenes: any.
func (s *RCS) AvailableThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxThrust - the maximum amount of thrust that can be produced by the RCS
// thrusters when active, in Newtons. Takes the thrusters current <see
// cref="M:SpaceCenter.RCS.ThrustLimit" /> and atmospheric conditions into
// account.
//
// Allowed game scenes: any.
func (s *RCS) MaxThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RCS_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxThrustStream - the maximum amount of thrust that can be produced by the
// RCS thrusters when active, in Newtons. Takes the thrusters current <see
// cref="M:SpaceCenter.RCS.ThrustLimit" /> and atmospheric conditions into
// account.
//
// Allowed game scenes: any.
func (s *RCS) MaxThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxVacuumThrust - the maximum amount of thrust that can be produced by the
// RCS thrusters when active in a vacuum, in Newtons.
//
// Allowed game scenes: any.
func (s *RCS) MaxVacuumThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RCS_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxVacuumThrustStream - the maximum amount of thrust that can be produced by
// the RCS thrusters when active in a vacuum, in Newtons.
//
// Allowed game scenes: any.
func (s *RCS) MaxVacuumThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThrustLimit - the thrust limiter of the thruster. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *RCS) ThrustLimit() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RCS_get_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrustLimitStream - the thrust limiter of the thruster. A value between 0 and
// 1.
//
// Allowed game scenes: any.
func (s *RCS) ThrustLimitStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetThrustLimit - the thrust limiter of the thruster. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *RCS) SetThrustLimit(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_set_ThrustLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Thrusters - a list of thrusters, one of each nozzel in the RCS part.
//
// Allowed game scenes: any.
func (s *RCS) Thrusters() ([]*Thruster, error) {
	var err error
	var argBytes []byte
	var vv []*Thruster
	request := &types.ProcedureCall{
		Procedure: "RCS_get_Thrusters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// ThrustersStream - a list of thrusters, one of each nozzel in the RCS part.
//
// Allowed game scenes: any.
func (s *RCS) ThrustersStream() (*krpcgo.Stream[[]*Thruster], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_Thrusters",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Thruster {
		var value []*Thruster
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SpecificImpulse - the current specific impulse of the RCS, in seconds.
// Returns zero if the RCS is not active.
//
// Allowed game scenes: any.
func (s *RCS) SpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RCS_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpecificImpulseStream - the current specific impulse of the RCS, in seconds.
// Returns zero if the RCS is not active.
//
// Allowed game scenes: any.
func (s *RCS) SpecificImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// VacuumSpecificImpulse - the vacuum specific impulse of the RCS, in seconds.
//
// Allowed game scenes: any.
func (s *RCS) VacuumSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RCS_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VacuumSpecificImpulseStream - the vacuum specific impulse of the RCS, in
// seconds.
//
// Allowed game scenes: any.
func (s *RCS) VacuumSpecificImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// KerbinSeaLevelSpecificImpulse - the specific impulse of the RCS at sea level
// on Kerbin, in seconds.
//
// Allowed game scenes: any.
func (s *RCS) KerbinSeaLevelSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RCS_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// KerbinSeaLevelSpecificImpulseStream - the specific impulse of the RCS at sea
// level on Kerbin, in seconds.
//
// Allowed game scenes: any.
func (s *RCS) KerbinSeaLevelSpecificImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Propellants - the names of resources that the RCS consumes.
//
// Allowed game scenes: any.
func (s *RCS) Propellants() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "RCS_get_Propellants",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PropellantsStream - the names of resources that the RCS consumes.
//
// Allowed game scenes: any.
func (s *RCS) PropellantsStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_Propellants",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// PropellantRatios - the ratios of resources that the RCS consumes. A
// dictionary mapping resource names to the ratios at which they are consumed by
// the RCS.
//
// Allowed game scenes: any.
func (s *RCS) PropellantRatios() (map[string]float32, error) {
	var err error
	var argBytes []byte
	var vv map[string]float32
	request := &types.ProcedureCall{
		Procedure: "RCS_get_PropellantRatios",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PropellantRatiosStream - the ratios of resources that the RCS consumes. A
// dictionary mapping resource names to the ratios at which they are consumed by
// the RCS.
//
// Allowed game scenes: any.
func (s *RCS) PropellantRatiosStream() (*krpcgo.Stream[map[string]float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_PropellantRatios",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) map[string]float32 {
		var value map[string]float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasFuel - whether the RCS has fuel available.
//
// Allowed game scenes: any.
func (s *RCS) HasFuel() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RCS_get_HasFuel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasFuelStream - whether the RCS has fuel available.
//
// Allowed game scenes: any.
func (s *RCS) HasFuelStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RCS_get_HasFuel",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this radiator.
//
// Allowed game scenes: any.
func (s *Radiator) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Radiator_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Deployable - whether the radiator is deployable.
//
// Allowed game scenes: any.
func (s *Radiator) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Radiator_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployableStream - whether the radiator is deployable.
//
// Allowed game scenes: any.
func (s *Radiator) DeployableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Radiator_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deployed - for a deployable radiator, true if the radiator is extended. If
// the radiator is not deployable, this is always true.
//
// Allowed game scenes: any.
func (s *Radiator) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Radiator_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployedStream - for a deployable radiator, true if the radiator is extended.
// If the radiator is not deployable, this is always true.
//
// Allowed game scenes: any.
func (s *Radiator) DeployedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Radiator_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeployed - for a deployable radiator, true if the radiator is extended. If
// the radiator is not deployable, this is always true.
//
// Allowed game scenes: any.
func (s *Radiator) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Radiator_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// State - the current state of the radiator.
//
// Allowed game scenes: any.
func (s *Radiator) State() (RadiatorState, error) {
	var err error
	var argBytes []byte
	var vv RadiatorState
	request := &types.ProcedureCall{
		Procedure: "Radiator_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the current state of the radiator.
//
// Allowed game scenes: any.
func (s *Radiator) StateStream() (*krpcgo.Stream[RadiatorState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Radiator_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) RadiatorState {
		var value RadiatorState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this reaction wheel.
//
// Allowed game scenes: any.
func (s *ReactionWheel) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Active - whether the reaction wheel is active.
//
// Allowed game scenes: any.
func (s *ReactionWheel) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActiveStream - whether the reaction wheel is active.
//
// Allowed game scenes: any.
func (s *ReactionWheel) ActiveStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetActive - whether the reaction wheel is active.
//
// Allowed game scenes: any.
func (s *ReactionWheel) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Broken - whether the reaction wheel is broken.
//
// Allowed game scenes: any.
func (s *ReactionWheel) Broken() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_get_Broken",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BrokenStream - whether the reaction wheel is broken.
//
// Allowed game scenes: any.
func (s *ReactionWheel) BrokenStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_get_Broken",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableTorque - the available torque, in Newton meters, that can be
// produced by this reaction wheel, in the positive and negative pitch, roll and
// yaw axes of the vessel. These axes correspond to the coordinate axes of the
// <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if the
// reaction wheel is inactive or broken.
//
// Allowed game scenes: any.
func (s *ReactionWheel) AvailableTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableTorqueStream - the available torque, in Newton meters, that can be
// produced by this reaction wheel, in the positive and negative pitch, roll and
// yaw axes of the vessel. These axes correspond to the coordinate axes of the
// <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />. Returns zero if the
// reaction wheel is inactive or broken.
//
// Allowed game scenes: any.
func (s *ReactionWheel) AvailableTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxTorque - the maximum torque, in Newton meters, that can be produced by
// this reaction wheel, when it is active, in the positive and negative pitch,
// roll and yaw axes of the vessel. These axes correspond to the coordinate axes
// of the <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *ReactionWheel) MaxTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_get_MaxTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxTorqueStream - the maximum torque, in Newton meters, that can be produced
// by this reaction wheel, when it is active, in the positive and negative
// pitch, roll and yaw axes of the vessel. These axes correspond to the
// coordinate axes of the <see cref="M:SpaceCenter.Vessel.ReferenceFrame" />.
//
// Allowed game scenes: any.
func (s *ReactionWheel) MaxTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ReactionWheel_get_MaxTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Active - true if the specified converter is active.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Active(index int32) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActiveStream - true if the specified converter is active.
//
// Allowed game scenes: any.
func (s *ResourceConverter) ActiveStream(index int32) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Name - the name of the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Name(index int32) (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the name of the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) NameStream(index int32) (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Start - start the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Start(index int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Start",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Stop - stop the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Stop(index int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Stop",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// State - the state of the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) State(index int32) (ResourceConverterState, error) {
	var err error
	var argBytes []byte
	var vv ResourceConverterState
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the state of the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StateStream(index int32) (*krpcgo.Stream[ResourceConverterState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ResourceConverterState {
		var value ResourceConverterState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// StatusInfo - status information for the specified converter. This is the full
// status message shown in the in-game UI.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StatusInfo(index int32) (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_StatusInfo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StatusInfoStream - status information for the specified converter. This is
// the full status message shown in the in-game UI.
//
// Allowed game scenes: any.
func (s *ResourceConverter) StatusInfoStream(index int32) (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_StatusInfo",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Inputs - list of the names of resources consumed by the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Inputs(index int32) ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Inputs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InputsStream - list of the names of resources consumed by the specified
// converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) InputsStream(index int32) (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Inputs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Outputs - list of the names of resources produced by the specified converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Outputs(index int32) ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Outputs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OutputsStream - list of the names of resources produced by the specified
// converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) OutputsStream(index int32) (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_Outputs",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(index)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this converter.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Count - the number of converters in the part.
//
// Allowed game scenes: any.
func (s *ResourceConverter) Count() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_get_Count",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CountStream - the number of converters in the part.
//
// Allowed game scenes: any.
func (s *ResourceConverter) CountStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_get_Count",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalEfficiency - the thermal efficiency of the converter, as a percentage
// of its maximum.
//
// Allowed game scenes: any.
func (s *ResourceConverter) ThermalEfficiency() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_get_ThermalEfficiency",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalEfficiencyStream - the thermal efficiency of the converter, as a
// percentage of its maximum.
//
// Allowed game scenes: any.
func (s *ResourceConverter) ThermalEfficiencyStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_get_ThermalEfficiency",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CoreTemperature - the core temperature of the converter, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceConverter) CoreTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_get_CoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CoreTemperatureStream - the core temperature of the converter, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceConverter) CoreTemperatureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_get_CoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// OptimumCoreTemperature - the core temperature at which the converter will
// operate with peak efficiency, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceConverter) OptimumCoreTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_get_OptimumCoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OptimumCoreTemperatureStream - the core temperature at which the converter
// will operate with peak efficiency, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceConverter) OptimumCoreTemperatureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceConverter_get_OptimumCoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetResource - whether the given resource should be drained.
//
// Allowed game scenes: any.
func (s *ResourceDrain) SetResource(resource *Resource, enabled bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_SetResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(resource)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(enabled)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CheckResource - whether the provided resource is enabled for draining.
//
// Allowed game scenes: any.
func (s *ResourceDrain) CheckResource(resource *Resource) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_CheckResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(resource)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CheckResourceStream - whether the provided resource is enabled for draining.
//
// Allowed game scenes: any.
func (s *ResourceDrain) CheckResourceStream(resource *Resource) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_CheckResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(resource)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Start - activates resource draining for all enabled parts.
//
// Allowed game scenes: any.
func (s *ResourceDrain) Start() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_Start",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Stop - turns off resource draining.
//
// Allowed game scenes: any.
func (s *ResourceDrain) Stop() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_Stop",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this resource drain.
//
// Allowed game scenes: any.
func (s *ResourceDrain) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AvailableResources - list of available resources.
//
// Allowed game scenes: any.
func (s *ResourceDrain) AvailableResources() ([]*Resource, error) {
	var err error
	var argBytes []byte
	var vv []*Resource
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_AvailableResources",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// AvailableResourcesStream - list of available resources.
//
// Allowed game scenes: any.
func (s *ResourceDrain) AvailableResourcesStream() (*krpcgo.Stream[[]*Resource], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_AvailableResources",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Resource {
		var value []*Resource
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DrainMode - the drain mode.
//
// Allowed game scenes: any.
func (s *ResourceDrain) DrainMode() (DrainMode, error) {
	var err error
	var argBytes []byte
	var vv DrainMode
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_DrainMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DrainModeStream - the drain mode.
//
// Allowed game scenes: any.
func (s *ResourceDrain) DrainModeStream() (*krpcgo.Stream[DrainMode], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_DrainMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) DrainMode {
		var value DrainMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDrainMode - the drain mode.
//
// Allowed game scenes: any.
func (s *ResourceDrain) SetDrainMode(value DrainMode) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_set_DrainMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MaxRate - maximum possible drain rate.
//
// Allowed game scenes: any.
func (s *ResourceDrain) MaxRate() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_MaxRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxRateStream - maximum possible drain rate.
//
// Allowed game scenes: any.
func (s *ResourceDrain) MaxRateStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_MaxRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MinRate - minimum possible drain rate
//
// Allowed game scenes: any.
func (s *ResourceDrain) MinRate() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_MinRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MinRateStream - minimum possible drain rate
//
// Allowed game scenes: any.
func (s *ResourceDrain) MinRateStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_MinRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rate - current drain rate.
//
// Allowed game scenes: any.
func (s *ResourceDrain) Rate() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RateStream - current drain rate.
//
// Allowed game scenes: any.
func (s *ResourceDrain) RateStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_get_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRate - current drain rate.
//
// Allowed game scenes: any.
func (s *ResourceDrain) SetRate(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceDrain_set_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this harvester.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// State - the state of the harvester.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) State() (ResourceHarvesterState, error) {
	var err error
	var argBytes []byte
	var vv ResourceHarvesterState
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the state of the harvester.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) StateStream() (*krpcgo.Stream[ResourceHarvesterState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ResourceHarvesterState {
		var value ResourceHarvesterState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deployed - whether the harvester is deployed.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployedStream - whether the harvester is deployed.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) DeployedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeployed - whether the harvester is deployed.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Active - whether the harvester is actively drilling.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActiveStream - whether the harvester is actively drilling.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) ActiveStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetActive - whether the harvester is actively drilling.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ExtractionRate - the rate at which the drill is extracting ore, in units per
// second.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) ExtractionRate() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_ExtractionRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ExtractionRateStream - the rate at which the drill is extracting ore, in
// units per second.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) ExtractionRateStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_ExtractionRate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThermalEfficiency - the thermal efficiency of the drill, as a percentage of
// its maximum.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) ThermalEfficiency() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_ThermalEfficiency",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThermalEfficiencyStream - the thermal efficiency of the drill, as a
// percentage of its maximum.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) ThermalEfficiencyStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_ThermalEfficiency",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CoreTemperature - the core temperature of the drill, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) CoreTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_CoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CoreTemperatureStream - the core temperature of the drill, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) CoreTemperatureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_CoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// OptimumCoreTemperature - the core temperature at which the drill will operate
// with peak efficiency, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) OptimumCoreTemperature() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_OptimumCoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// OptimumCoreTemperatureStream - the core temperature at which the drill will
// operate with peak efficiency, in Kelvin.
//
// Allowed game scenes: any.
func (s *ResourceHarvester) OptimumCoreTemperatureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceHarvester_get_OptimumCoreTemperature",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasPart - whether the controller has a part.
//
// Allowed game scenes: any.
func (s *RoboticController) HasPart(part *Part) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticController_HasPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasPartStream - whether the controller has a part.
//
// Allowed game scenes: any.
func (s *RoboticController) HasPartStream(part *Part) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticController_HasPart",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(part)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Axes - the axes for the controller.
//
// Allowed game scenes: any.
func (s *RoboticController) Axes() ([][]string, error) {
	var err error
	var argBytes []byte
	var vv [][]string
	request := &types.ProcedureCall{
		Procedure: "RoboticController_Axes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AxesStream - the axes for the controller.
//
// Allowed game scenes: any.
func (s *RoboticController) AxesStream() (*krpcgo.Stream[[][]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticController_Axes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) [][]string {
		var value [][]string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AddAxis - add an axis to the controller.
//
// Allowed game scenes: any.
func (s *RoboticController) AddAxis(module *Module, fieldName string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticController_AddAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(module)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(fieldName)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AddAxisStream - add an axis to the controller.
//
// Allowed game scenes: any.
func (s *RoboticController) AddAxisStream(module *Module, fieldName string) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticController_AddAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(module)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(fieldName)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AddKeyFrame - add key frame value for controller axis.
//
// Allowed game scenes: any.
func (s *RoboticController) AddKeyFrame(module *Module, fieldName string, time float32, value float32) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticController_AddKeyFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(module)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(fieldName)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(time)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AddKeyFrameStream - add key frame value for controller axis.
//
// Allowed game scenes: any.
func (s *RoboticController) AddKeyFrameStream(module *Module, fieldName string, time float32, value float32) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticController_AddKeyFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(module)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(fieldName)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(time)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ClearAxis - clear axis.
//
// Allowed game scenes: any.
func (s *RoboticController) ClearAxis(module *Module, fieldName string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticController_ClearAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(module)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(fieldName)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ClearAxisStream - clear axis.
//
// Allowed game scenes: any.
func (s *RoboticController) ClearAxisStream(module *Module, fieldName string) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticController_ClearAxis",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(module)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(fieldName)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this controller.
//
// Allowed game scenes: any.
func (s *RoboticController) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "RoboticController_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// MoveHome - move hinge to it's built position.
//
// Allowed game scenes: any.
func (s *RoboticHinge) MoveHome() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_MoveHome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this robotic hinge.
//
// Allowed game scenes: any.
func (s *RoboticHinge) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// TargetAngle - target angle.
//
// Allowed game scenes: any.
func (s *RoboticHinge) TargetAngle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_TargetAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TargetAngleStream - target angle.
//
// Allowed game scenes: any.
func (s *RoboticHinge) TargetAngleStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_TargetAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTargetAngle - target angle.
//
// Allowed game scenes: any.
func (s *RoboticHinge) SetTargetAngle(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_set_TargetAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CurrentAngle - current angle.
//
// Allowed game scenes: any.
func (s *RoboticHinge) CurrentAngle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_CurrentAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CurrentAngleStream - current angle.
//
// Allowed game scenes: any.
func (s *RoboticHinge) CurrentAngleStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_CurrentAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rate - target movement rate in degrees per second.
//
// Allowed game scenes: any.
func (s *RoboticHinge) Rate() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RateStream - target movement rate in degrees per second.
//
// Allowed game scenes: any.
func (s *RoboticHinge) RateStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRate - target movement rate in degrees per second.
//
// Allowed game scenes: any.
func (s *RoboticHinge) SetRate(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_set_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Damping - damping percentage.
//
// Allowed game scenes: any.
func (s *RoboticHinge) Damping() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_Damping",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DampingStream - damping percentage.
//
// Allowed game scenes: any.
func (s *RoboticHinge) DampingStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_Damping",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDamping - damping percentage.
//
// Allowed game scenes: any.
func (s *RoboticHinge) SetDamping(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_set_Damping",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Locked - lock movement.
//
// Allowed game scenes: any.
func (s *RoboticHinge) Locked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LockedStream - lock movement.
//
// Allowed game scenes: any.
func (s *RoboticHinge) LockedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLocked - lock movement.
//
// Allowed game scenes: any.
func (s *RoboticHinge) SetLocked(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_set_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MotorEngaged - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticHinge) MotorEngaged() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MotorEngagedStream - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticHinge) MotorEngagedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_get_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMotorEngaged - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticHinge) SetMotorEngaged(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticHinge_set_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveHome - move piston to it's built position.
//
// Allowed game scenes: any.
func (s *RoboticPiston) MoveHome() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_MoveHome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this robotic piston.
//
// Allowed game scenes: any.
func (s *RoboticPiston) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// TargetExtension - target extension of the piston.
//
// Allowed game scenes: any.
func (s *RoboticPiston) TargetExtension() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_TargetExtension",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TargetExtensionStream - target extension of the piston.
//
// Allowed game scenes: any.
func (s *RoboticPiston) TargetExtensionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_TargetExtension",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTargetExtension - target extension of the piston.
//
// Allowed game scenes: any.
func (s *RoboticPiston) SetTargetExtension(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_set_TargetExtension",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CurrentExtension - current extension of the piston.
//
// Allowed game scenes: any.
func (s *RoboticPiston) CurrentExtension() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_CurrentExtension",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CurrentExtensionStream - current extension of the piston.
//
// Allowed game scenes: any.
func (s *RoboticPiston) CurrentExtensionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_CurrentExtension",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rate - target movement rate in degrees per second.
//
// Allowed game scenes: any.
func (s *RoboticPiston) Rate() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RateStream - target movement rate in degrees per second.
//
// Allowed game scenes: any.
func (s *RoboticPiston) RateStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRate - target movement rate in degrees per second.
//
// Allowed game scenes: any.
func (s *RoboticPiston) SetRate(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_set_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Damping - damping percentage.
//
// Allowed game scenes: any.
func (s *RoboticPiston) Damping() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_Damping",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DampingStream - damping percentage.
//
// Allowed game scenes: any.
func (s *RoboticPiston) DampingStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_Damping",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDamping - damping percentage.
//
// Allowed game scenes: any.
func (s *RoboticPiston) SetDamping(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_set_Damping",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Locked - lock movement.
//
// Allowed game scenes: any.
func (s *RoboticPiston) Locked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LockedStream - lock movement.
//
// Allowed game scenes: any.
func (s *RoboticPiston) LockedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLocked - lock movement.
//
// Allowed game scenes: any.
func (s *RoboticPiston) SetLocked(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_set_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MotorEngaged - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticPiston) MotorEngaged() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MotorEngagedStream - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticPiston) MotorEngagedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_get_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMotorEngaged - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticPiston) SetMotorEngaged(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticPiston_set_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MoveHome - move rotation servo to it's built position.
//
// Allowed game scenes: any.
func (s *RoboticRotation) MoveHome() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_MoveHome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this robotic rotation servo.
//
// Allowed game scenes: any.
func (s *RoboticRotation) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// TargetAngle - target angle.
//
// Allowed game scenes: any.
func (s *RoboticRotation) TargetAngle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_TargetAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TargetAngleStream - target angle.
//
// Allowed game scenes: any.
func (s *RoboticRotation) TargetAngleStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_TargetAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTargetAngle - target angle.
//
// Allowed game scenes: any.
func (s *RoboticRotation) SetTargetAngle(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_set_TargetAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CurrentAngle - current angle.
//
// Allowed game scenes: any.
func (s *RoboticRotation) CurrentAngle() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_CurrentAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CurrentAngleStream - current angle.
//
// Allowed game scenes: any.
func (s *RoboticRotation) CurrentAngleStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_CurrentAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rate - target movement rate in degrees per second.
//
// Allowed game scenes: any.
func (s *RoboticRotation) Rate() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RateStream - target movement rate in degrees per second.
//
// Allowed game scenes: any.
func (s *RoboticRotation) RateStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetRate - target movement rate in degrees per second.
//
// Allowed game scenes: any.
func (s *RoboticRotation) SetRate(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_set_Rate",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Damping - damping percentage.
//
// Allowed game scenes: any.
func (s *RoboticRotation) Damping() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_Damping",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DampingStream - damping percentage.
//
// Allowed game scenes: any.
func (s *RoboticRotation) DampingStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_Damping",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDamping - damping percentage.
//
// Allowed game scenes: any.
func (s *RoboticRotation) SetDamping(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_set_Damping",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Locked - lock Movement
//
// Allowed game scenes: any.
func (s *RoboticRotation) Locked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LockedStream - lock Movement
//
// Allowed game scenes: any.
func (s *RoboticRotation) LockedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLocked - lock Movement
//
// Allowed game scenes: any.
func (s *RoboticRotation) SetLocked(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_set_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MotorEngaged - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticRotation) MotorEngaged() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MotorEngagedStream - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticRotation) MotorEngagedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_get_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMotorEngaged - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticRotation) SetMotorEngaged(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotation_set_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Part - the part object for this robotic rotor.
//
// Allowed game scenes: any.
func (s *RoboticRotor) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// TargetRPM - target RPM.
//
// Allowed game scenes: any.
func (s *RoboticRotor) TargetRPM() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_TargetRPM",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TargetRPMStream - target RPM.
//
// Allowed game scenes: any.
func (s *RoboticRotor) TargetRPMStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_TargetRPM",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTargetRPM - target RPM.
//
// Allowed game scenes: any.
func (s *RoboticRotor) SetTargetRPM(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_set_TargetRPM",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// CurrentRPM - current RPM.
//
// Allowed game scenes: any.
func (s *RoboticRotor) CurrentRPM() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_CurrentRPM",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CurrentRPMStream - current RPM.
//
// Allowed game scenes: any.
func (s *RoboticRotor) CurrentRPMStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_CurrentRPM",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Inverted - whether the rotor direction is inverted.
//
// Allowed game scenes: any.
func (s *RoboticRotor) Inverted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_Inverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InvertedStream - whether the rotor direction is inverted.
//
// Allowed game scenes: any.
func (s *RoboticRotor) InvertedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_Inverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetInverted - whether the rotor direction is inverted.
//
// Allowed game scenes: any.
func (s *RoboticRotor) SetInverted(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_set_Inverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Locked - lock movement.
//
// Allowed game scenes: any.
func (s *RoboticRotor) Locked() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LockedStream - lock movement.
//
// Allowed game scenes: any.
func (s *RoboticRotor) LockedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLocked - lock movement.
//
// Allowed game scenes: any.
func (s *RoboticRotor) SetLocked(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_set_Locked",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MotorEngaged - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticRotor) MotorEngaged() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MotorEngagedStream - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticRotor) MotorEngagedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMotorEngaged - whether the motor is engaged.
//
// Allowed game scenes: any.
func (s *RoboticRotor) SetMotorEngaged(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_set_MotorEngaged",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TorqueLimit - torque limit percentage.
//
// Allowed game scenes: any.
func (s *RoboticRotor) TorqueLimit() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_TorqueLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TorqueLimitStream - torque limit percentage.
//
// Allowed game scenes: any.
func (s *RoboticRotor) TorqueLimitStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_get_TorqueLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTorqueLimit - torque limit percentage.
//
// Allowed game scenes: any.
func (s *RoboticRotor) SetTorqueLimit(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "RoboticRotor_set_TorqueLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// DataAmount - data amount.
//
// Allowed game scenes: any.
func (s *ScienceData) DataAmount() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ScienceData_get_DataAmount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DataAmountStream - data amount.
//
// Allowed game scenes: any.
func (s *ScienceData) DataAmountStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceData_get_DataAmount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ScienceValue - science value.
//
// Allowed game scenes: any.
func (s *ScienceData) ScienceValue() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ScienceData_get_ScienceValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ScienceValueStream - science value.
//
// Allowed game scenes: any.
func (s *ScienceData) ScienceValueStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceData_get_ScienceValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TransmitValue - transmit value.
//
// Allowed game scenes: any.
func (s *ScienceData) TransmitValue() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ScienceData_get_TransmitValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TransmitValueStream - transmit value.
//
// Allowed game scenes: any.
func (s *ScienceData) TransmitValueStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceData_get_TransmitValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Science - amount of science already earned from this subject, not updated
// until after transmission/recovery.
//
// Allowed game scenes: any.
func (s *ScienceSubject) Science() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_Science",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ScienceStream - amount of science already earned from this subject, not
// updated until after transmission/recovery.
//
// Allowed game scenes: any.
func (s *ScienceSubject) ScienceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_Science",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ScienceCap - total science allowable for this subject.
//
// Allowed game scenes: any.
func (s *ScienceSubject) ScienceCap() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_ScienceCap",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ScienceCapStream - total science allowable for this subject.
//
// Allowed game scenes: any.
func (s *ScienceSubject) ScienceCapStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_ScienceCap",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// IsComplete - whether the experiment has been completed.
//
// Allowed game scenes: any.
func (s *ScienceSubject) IsComplete() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_IsComplete",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IsCompleteStream - whether the experiment has been completed.
//
// Allowed game scenes: any.
func (s *ScienceSubject) IsCompleteStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_IsComplete",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DataScale - multiply science value by this to determine data amount in mits.
//
// Allowed game scenes: any.
func (s *ScienceSubject) DataScale() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_DataScale",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DataScaleStream - multiply science value by this to determine data amount in
// mits.
//
// Allowed game scenes: any.
func (s *ScienceSubject) DataScaleStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_DataScale",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ScientificValue - diminishing value multiplier for decreasing the science
// value returned from repeated experiments.
//
// Allowed game scenes: any.
func (s *ScienceSubject) ScientificValue() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_ScientificValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ScientificValueStream - diminishing value multiplier for decreasing the
// science value returned from repeated experiments.
//
// Allowed game scenes: any.
func (s *ScienceSubject) ScientificValueStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_ScientificValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SubjectValue - multiplier for specific Celestial Body/Experiment Situation
// combination.
//
// Allowed game scenes: any.
func (s *ScienceSubject) SubjectValue() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_SubjectValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SubjectValueStream - multiplier for specific Celestial Body/Experiment
// Situation combination.
//
// Allowed game scenes: any.
func (s *ScienceSubject) SubjectValueStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_SubjectValue",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Title - title of science subject, displayed in science archives
//
// Allowed game scenes: any.
func (s *ScienceSubject) Title() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TitleStream - title of science subject, displayed in science archives
//
// Allowed game scenes: any.
func (s *ScienceSubject) TitleStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ScienceSubject_get_Title",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this sensor.
//
// Allowed game scenes: any.
func (s *Sensor) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Sensor_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Active - whether the sensor is active.
//
// Allowed game scenes: any.
func (s *Sensor) Active() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Sensor_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ActiveStream - whether the sensor is active.
//
// Allowed game scenes: any.
func (s *Sensor) ActiveStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Sensor_get_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetActive - whether the sensor is active.
//
// Allowed game scenes: any.
func (s *Sensor) SetActive(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Sensor_set_Active",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Value - the current value of the sensor.
//
// Allowed game scenes: any.
func (s *Sensor) Value() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Sensor_get_Value",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ValueStream - the current value of the sensor.
//
// Allowed game scenes: any.
func (s *Sensor) ValueStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Sensor_get_Value",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this solar panel.
//
// Allowed game scenes: any.
func (s *SolarPanel) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Deployable - whether the solar panel is deployable.
//
// Allowed game scenes: any.
func (s *SolarPanel) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployableStream - whether the solar panel is deployable.
//
// Allowed game scenes: any.
func (s *SolarPanel) DeployableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deployed - whether the solar panel is extended.
//
// Allowed game scenes: any.
func (s *SolarPanel) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployedStream - whether the solar panel is extended.
//
// Allowed game scenes: any.
func (s *SolarPanel) DeployedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeployed - whether the solar panel is extended.
//
// Allowed game scenes: any.
func (s *SolarPanel) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// State - the current state of the solar panel.
//
// Allowed game scenes: any.
func (s *SolarPanel) State() (SolarPanelState, error) {
	var err error
	var argBytes []byte
	var vv SolarPanelState
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the current state of the solar panel.
//
// Allowed game scenes: any.
func (s *SolarPanel) StateStream() (*krpcgo.Stream[SolarPanelState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) SolarPanelState {
		var value SolarPanelState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// EnergyFlow - the current amount of energy being generated by the solar panel,
// in units of charge per second.
//
// Allowed game scenes: any.
func (s *SolarPanel) EnergyFlow() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_EnergyFlow",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EnergyFlowStream - the current amount of energy being generated by the solar
// panel, in units of charge per second.
//
// Allowed game scenes: any.
func (s *SolarPanel) EnergyFlowStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_EnergyFlow",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SunExposure - the current amount of sunlight that is incident on the solar
// panel, as a percentage. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *SolarPanel) SunExposure() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_SunExposure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SunExposureStream - the current amount of sunlight that is incident on the
// solar panel, as a percentage. A value between 0 and 1.
//
// Allowed game scenes: any.
func (s *SolarPanel) SunExposureStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "SolarPanel_get_SunExposure",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThrustPosition - the position at which the thruster generates thrust, in the
// given reference frame. For gimballed engines, this takes into account the
// current rotation of the gimbal.
//
// Allowed game scenes: any.
func (s *Thruster) ThrustPosition(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Thruster_ThrustPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrustPositionStream - the position at which the thruster generates thrust,
// in the given reference frame. For gimballed engines, this takes into account
// the current rotation of the gimbal.
//
// Allowed game scenes: any.
func (s *Thruster) ThrustPositionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Thruster_ThrustPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ThrustDirection - the direction of the force generated by the thruster, in
// the given reference frame. This is opposite to the direction in which the
// thruster expels propellant. For gimballed engines, this takes into account
// the current rotation of the gimbal.
//
// Allowed game scenes: any.
func (s *Thruster) ThrustDirection(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Thruster_ThrustDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrustDirectionStream - the direction of the force generated by the thruster,
// in the given reference frame. This is opposite to the direction in which the
// thruster expels propellant. For gimballed engines, this takes into account
// the current rotation of the gimbal.
//
// Allowed game scenes: any.
func (s *Thruster) ThrustDirectionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Thruster_ThrustDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// InitialThrustPosition - the position at which the thruster generates thrust,
// when the engine is in its initial position (no gimballing), in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Thruster) InitialThrustPosition(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Thruster_InitialThrustPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InitialThrustPositionStream - the position at which the thruster generates
// thrust, when the engine is in its initial position (no gimballing), in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *Thruster) InitialThrustPositionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Thruster_InitialThrustPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// InitialThrustDirection - the direction of the force generated by the
// thruster, when the engine is in its initial position (no gimballing), in the
// given reference frame. This is opposite to the direction in which the
// thruster expels propellant.
//
// Allowed game scenes: any.
func (s *Thruster) InitialThrustDirection(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Thruster_InitialThrustDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InitialThrustDirectionStream - the direction of the force generated by the
// thruster, when the engine is in its initial position (no gimballing), in the
// given reference frame. This is opposite to the direction in which the
// thruster expels propellant.
//
// Allowed game scenes: any.
func (s *Thruster) InitialThrustDirectionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Thruster_InitialThrustDirection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// GimbalPosition - position around which the gimbal pivots.
//
// Allowed game scenes: any.
func (s *Thruster) GimbalPosition(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Thruster_GimbalPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GimbalPositionStream - position around which the gimbal pivots.
//
// Allowed game scenes: any.
func (s *Thruster) GimbalPositionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Thruster_GimbalPosition",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the <see cref="T:SpaceCenter.Part" /> that contains this thruster.
//
// Allowed game scenes: any.
func (s *Thruster) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Thruster_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ThrustReferenceFrame - a reference frame that is fixed relative to the
// thruster and orientated with its thrust direction (<see
// cref="M:SpaceCenter.Thruster.ThrustDirection" />). For gimballed engines,
// this takes into account the current rotation of the gimbal. <list
// type="bullet"><item><description> The origin is at the position of thrust for
// this thruster (<see cref="M:SpaceCenter.Thruster.ThrustPosition"
// />).</description></item><item><description> The axes rotate with the thrust
// direction. This is the direction in which the thruster expels propellant,
// including any gimballing. </description></item><item><description>The y-axis
// points along the thrust direction.</description></item><item><description>The
// x-axis and z-axis are perpendicular to the thrust direction.
// </description></item></list>
//
// Allowed game scenes: any.
func (s *Thruster) ThrustReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Thruster_get_ThrustReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Gimballed - whether the thruster is gimballed.
//
// Allowed game scenes: any.
func (s *Thruster) Gimballed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Thruster_get_Gimballed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GimballedStream - whether the thruster is gimballed.
//
// Allowed game scenes: any.
func (s *Thruster) GimballedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Thruster_get_Gimballed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// GimbalAngle - the current gimbal angle in the pitch, roll and yaw axes, in
// degrees.
//
// Allowed game scenes: any.
func (s *Thruster) GimbalAngle() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Thruster_get_GimbalAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GimbalAngleStream - the current gimbal angle in the pitch, roll and yaw axes,
// in degrees.
//
// Allowed game scenes: any.
func (s *Thruster) GimbalAngleStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Thruster_get_GimbalAngle",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part object for this wheel.
//
// Allowed game scenes: any.
func (s *Wheel) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// State - the current state of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) State() (WheelState, error) {
	var err error
	var argBytes []byte
	var vv WheelState
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StateStream - the current state of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StateStream() (*krpcgo.Stream[WheelState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_State",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) WheelState {
		var value WheelState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Radius - radius of the wheel, in meters.
//
// Allowed game scenes: any.
func (s *Wheel) Radius() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Radius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RadiusStream - radius of the wheel, in meters.
//
// Allowed game scenes: any.
func (s *Wheel) RadiusStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Radius",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Grounded - whether the wheel is touching the ground.
//
// Allowed game scenes: any.
func (s *Wheel) Grounded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Grounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GroundedStream - whether the wheel is touching the ground.
//
// Allowed game scenes: any.
func (s *Wheel) GroundedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Grounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasBrakes - whether the wheel has brakes.
//
// Allowed game scenes: any.
func (s *Wheel) HasBrakes() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_HasBrakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasBrakesStream - whether the wheel has brakes.
//
// Allowed game scenes: any.
func (s *Wheel) HasBrakesStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_HasBrakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Brakes - the braking force, as a percentage of maximum, when the brakes are
// applied.
//
// Allowed game scenes: any.
func (s *Wheel) Brakes() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BrakesStream - the braking force, as a percentage of maximum, when the brakes
// are applied.
//
// Allowed game scenes: any.
func (s *Wheel) BrakesStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetBrakes - the braking force, as a percentage of maximum, when the brakes
// are applied.
//
// Allowed game scenes: any.
func (s *Wheel) SetBrakes(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_Brakes",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// AutoFrictionControl - whether automatic friction control is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) AutoFrictionControl() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_AutoFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AutoFrictionControlStream - whether automatic friction control is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) AutoFrictionControlStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_AutoFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetAutoFrictionControl - whether automatic friction control is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) SetAutoFrictionControl(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_AutoFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// ManualFrictionControl - manual friction control value. Only has an effect if
// automatic friction control is disabled. A value between 0 and 5 inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) ManualFrictionControl() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_ManualFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ManualFrictionControlStream - manual friction control value. Only has an
// effect if automatic friction control is disabled. A value between 0 and 5
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) ManualFrictionControlStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_ManualFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetManualFrictionControl - manual friction control value. Only has an effect
// if automatic friction control is disabled. A value between 0 and 5 inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) SetManualFrictionControl(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_ManualFrictionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Deployable - whether the wheel is deployable.
//
// Allowed game scenes: any.
func (s *Wheel) Deployable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployableStream - whether the wheel is deployable.
//
// Allowed game scenes: any.
func (s *Wheel) DeployableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Deployable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deployed - whether the wheel is deployed.
//
// Allowed game scenes: any.
func (s *Wheel) Deployed() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeployedStream - whether the wheel is deployed.
//
// Allowed game scenes: any.
func (s *Wheel) DeployedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDeployed - whether the wheel is deployed.
//
// Allowed game scenes: any.
func (s *Wheel) SetDeployed(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_Deployed",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Powered - whether the wheel is powered by a motor.
//
// Allowed game scenes: any.
func (s *Wheel) Powered() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Powered",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PoweredStream - whether the wheel is powered by a motor.
//
// Allowed game scenes: any.
func (s *Wheel) PoweredStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Powered",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MotorEnabled - whether the motor is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) MotorEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_MotorEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MotorEnabledStream - whether the motor is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) MotorEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_MotorEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMotorEnabled - whether the motor is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) SetMotorEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_MotorEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MotorInverted - whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) MotorInverted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_MotorInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MotorInvertedStream - whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) MotorInvertedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_MotorInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMotorInverted - whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) SetMotorInverted(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_MotorInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MotorState - whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) MotorState() (MotorState, error) {
	var err error
	var argBytes []byte
	var vv MotorState
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_MotorState",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MotorStateStream - whether the direction of the motor is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) MotorStateStream() (*krpcgo.Stream[MotorState], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_MotorState",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) MotorState {
		var value MotorState
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MotorOutput - the output of the motor. This is the torque currently being
// generated, in Newton meters.
//
// Allowed game scenes: any.
func (s *Wheel) MotorOutput() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_MotorOutput",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MotorOutputStream - the output of the motor. This is the torque currently
// being generated, in Newton meters.
//
// Allowed game scenes: any.
func (s *Wheel) MotorOutputStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_MotorOutput",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// TractionControlEnabled - whether automatic traction control is enabled. A
// wheel only has traction control if it is powered.
//
// Allowed game scenes: any.
func (s *Wheel) TractionControlEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_TractionControlEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TractionControlEnabledStream - whether automatic traction control is enabled.
// A wheel only has traction control if it is powered.
//
// Allowed game scenes: any.
func (s *Wheel) TractionControlEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_TractionControlEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTractionControlEnabled - whether automatic traction control is enabled. A
// wheel only has traction control if it is powered.
//
// Allowed game scenes: any.
func (s *Wheel) SetTractionControlEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_TractionControlEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// TractionControl - setting for the traction control. Only takes effect if the
// wheel has automatic traction control enabled. A value between 0 and 5
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) TractionControl() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_TractionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TractionControlStream - setting for the traction control. Only takes effect
// if the wheel has automatic traction control enabled. A value between 0 and 5
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) TractionControlStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_TractionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetTractionControl - setting for the traction control. Only takes effect if
// the wheel has automatic traction control enabled. A value between 0 and 5
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) SetTractionControl(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_TractionControl",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// DriveLimiter - manual setting for the motor limiter. Only takes effect if the
// wheel has automatic traction control disabled. A value between 0 and 100
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) DriveLimiter() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_DriveLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DriveLimiterStream - manual setting for the motor limiter. Only takes effect
// if the wheel has automatic traction control disabled. A value between 0 and
// 100 inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) DriveLimiterStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_DriveLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetDriveLimiter - manual setting for the motor limiter. Only takes effect if
// the wheel has automatic traction control disabled. A value between 0 and 100
// inclusive.
//
// Allowed game scenes: any.
func (s *Wheel) SetDriveLimiter(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_DriveLimiter",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Steerable - whether the wheel has steering.
//
// Allowed game scenes: any.
func (s *Wheel) Steerable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Steerable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SteerableStream - whether the wheel has steering.
//
// Allowed game scenes: any.
func (s *Wheel) SteerableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Steerable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SteeringEnabled - whether the wheel steering is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringEnabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SteeringEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SteeringEnabledStream - whether the wheel steering is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringEnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SteeringEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSteeringEnabled - whether the wheel steering is enabled.
//
// Allowed game scenes: any.
func (s *Wheel) SetSteeringEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_SteeringEnabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SteeringInverted - whether the wheel steering is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringInverted() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SteeringInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SteeringInvertedStream - whether the wheel steering is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringInvertedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SteeringInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSteeringInverted - whether the wheel steering is inverted.
//
// Allowed game scenes: any.
func (s *Wheel) SetSteeringInverted(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_SteeringInverted",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SteeringAngleLimit - the steering angle limit.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringAngleLimit() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SteeringAngleLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SteeringAngleLimitStream - the steering angle limit.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringAngleLimitStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SteeringAngleLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSteeringAngleLimit - the steering angle limit.
//
// Allowed game scenes: any.
func (s *Wheel) SetSteeringAngleLimit(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_SteeringAngleLimit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SteeringResponseTime - steering response time.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringResponseTime() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SteeringResponseTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SteeringResponseTimeStream - steering response time.
//
// Allowed game scenes: any.
func (s *Wheel) SteeringResponseTimeStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SteeringResponseTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSteeringResponseTime - steering response time.
//
// Allowed game scenes: any.
func (s *Wheel) SetSteeringResponseTime(value float32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_set_SteeringResponseTime",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// HasSuspension - whether the wheel has suspension.
//
// Allowed game scenes: any.
func (s *Wheel) HasSuspension() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_HasSuspension",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasSuspensionStream - whether the wheel has suspension.
//
// Allowed game scenes: any.
func (s *Wheel) HasSuspensionStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_HasSuspension",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SuspensionSpringStrength - suspension spring strength, as set in the editor.
//
// Allowed game scenes: any.
func (s *Wheel) SuspensionSpringStrength() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SuspensionSpringStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SuspensionSpringStrengthStream - suspension spring strength, as set in the
// editor.
//
// Allowed game scenes: any.
func (s *Wheel) SuspensionSpringStrengthStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SuspensionSpringStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SuspensionDamperStrength - suspension damper strength, as set in the editor.
//
// Allowed game scenes: any.
func (s *Wheel) SuspensionDamperStrength() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SuspensionDamperStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SuspensionDamperStrengthStream - suspension damper strength, as set in the
// editor.
//
// Allowed game scenes: any.
func (s *Wheel) SuspensionDamperStrengthStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_SuspensionDamperStrength",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Broken - whether the wheel is broken.
//
// Allowed game scenes: any.
func (s *Wheel) Broken() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Broken",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BrokenStream - whether the wheel is broken.
//
// Allowed game scenes: any.
func (s *Wheel) BrokenStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Broken",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Repairable - whether the wheel is repairable.
//
// Allowed game scenes: any.
func (s *Wheel) Repairable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Repairable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RepairableStream - whether the wheel is repairable.
//
// Allowed game scenes: any.
func (s *Wheel) RepairableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Repairable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Stress - current stress on the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) Stress() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Stress",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StressStream - current stress on the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StressStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Stress",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// StressTolerance - stress tolerance of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StressTolerance() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_StressTolerance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StressToleranceStream - stress tolerance of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) StressToleranceStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_StressTolerance",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// StressPercentage - current stress on the wheel as a percentage of its stress
// tolerance.
//
// Allowed game scenes: any.
func (s *Wheel) StressPercentage() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_StressPercentage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// StressPercentageStream - current stress on the wheel as a percentage of its
// stress tolerance.
//
// Allowed game scenes: any.
func (s *Wheel) StressPercentageStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_StressPercentage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Deflection - current deflection of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) Deflection() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Deflection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DeflectionStream - current deflection of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) DeflectionStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Deflection",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Slip - current slip of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) Slip() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Slip",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SlipStream - current slip of the wheel.
//
// Allowed game scenes: any.
func (s *Wheel) SlipStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Wheel_get_Slip",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CreateRelative - create a relative reference frame. This is a custom
// reference frame whose components offset the components of a parent reference
// frame.
//
// Allowed game scenes: any.
func (s *ReferenceFrame) CreateRelative(position types.Tuple3[float64, float64, float64], rotation types.Tuple4[float64, float64, float64, float64], velocity types.Tuple3[float64, float64, float64], angularVelocity types.Tuple3[float64, float64, float64]) (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "ReferenceFrame_static_CreateRelative",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(position)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(angularVelocity)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// CreateHybrid - create a hybrid reference frame. This is a custom reference
// frame whose components inherited from other reference frames.
//
// Allowed game scenes: any.
func (s *ReferenceFrame) CreateHybrid(rotation *ReferenceFrame, velocity *ReferenceFrame, angularVelocity *ReferenceFrame) (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "ReferenceFrame_static_CreateHybrid",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(rotation)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(velocity)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(angularVelocity)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Name - the name of the resource.
//
// Allowed game scenes: any.
func (s *Resource) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the name of the resource.
//
// Allowed game scenes: any.
func (s *Resource) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Part - the part containing the resource.
//
// Allowed game scenes: any.
func (s *Resource) Part() (*Part, error) {
	var err error
	var argBytes []byte
	var vv Part
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Part",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Max - the total amount of the resource that can be stored in the part.
//
// Allowed game scenes: any.
func (s *Resource) Max() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Max",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxStream - the total amount of the resource that can be stored in the part.
//
// Allowed game scenes: any.
func (s *Resource) MaxStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Max",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Amount - the amount of the resource that is currently stored in the part.
//
// Allowed game scenes: any.
func (s *Resource) Amount() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AmountStream - the amount of the resource that is currently stored in the
// part.
//
// Allowed game scenes: any.
func (s *Resource) AmountStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Density - the density of the resource, in <math>kg/l</math>.
//
// Allowed game scenes: any.
func (s *Resource) Density() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Density",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DensityStream - the density of the resource, in <math>kg/l</math>.
//
// Allowed game scenes: any.
func (s *Resource) DensityStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Density",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FlowMode - the flow mode of the resource.
//
// Allowed game scenes: any.
func (s *Resource) FlowMode() (ResourceFlowMode, error) {
	var err error
	var argBytes []byte
	var vv ResourceFlowMode
	request := &types.ProcedureCall{
		Procedure: "Resource_get_FlowMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FlowModeStream - the flow mode of the resource.
//
// Allowed game scenes: any.
func (s *Resource) FlowModeStream() (*krpcgo.Stream[ResourceFlowMode], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resource_get_FlowMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ResourceFlowMode {
		var value ResourceFlowMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Enabled - whether use of this resource is enabled.
//
// Allowed game scenes: any.
func (s *Resource) Enabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EnabledStream - whether use of this resource is enabled.
//
// Allowed game scenes: any.
func (s *Resource) EnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resource_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetEnabled - whether use of this resource is enabled.
//
// Allowed game scenes: any.
func (s *Resource) SetEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resource_set_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Start - start transferring a resource transfer between a pair of parts. The
// transfer will move at most <paramref name="maxAmount" /> units of the
// resource, depending on how much of the resource is available in the source
// part and how much storage is available in the destination part. Use <see
// cref="M:SpaceCenter.ResourceTransfer.Complete" /> to check if the transfer is
// complete. Use <see cref="M:SpaceCenter.ResourceTransfer.Amount" /> to see how
// much of the resource has been transferred.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) Start(toPart *Part, resource string, maxAmount float32) (*ResourceTransfer, error) {
	var err error
	var argBytes []byte
	var vv ResourceTransfer
	request := &types.ProcedureCall{
		Procedure: "ResourceTransfer_static_Start",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(toPart)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(resource)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(maxAmount)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Complete - whether the transfer has completed.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) Complete() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "ResourceTransfer_get_Complete",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CompleteStream - whether the transfer has completed.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) CompleteStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceTransfer_get_Complete",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Amount - the amount of the resource that has been transferred.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) Amount() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "ResourceTransfer_get_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AmountStream - the amount of the resource that has been transferred.
//
// Allowed game scenes: any.
func (s *ResourceTransfer) AmountStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "ResourceTransfer_get_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// WithResource - all the individual resources with the given name that can be
// stored.
//
// Allowed game scenes: any.
func (s *Resources) WithResource(name string) ([]*Resource, error) {
	var err error
	var argBytes []byte
	var vv []*Resource
	request := &types.ProcedureCall{
		Procedure: "Resources_WithResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// WithResourceStream - all the individual resources with the given name that
// can be stored.
//
// Allowed game scenes: any.
func (s *Resources) WithResourceStream(name string) (*krpcgo.Stream[[]*Resource], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_WithResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Resource {
		var value []*Resource
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasResource - check whether the named resource can be stored.
//
// Allowed game scenes: any.
func (s *Resources) HasResource(name string) (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Resources_HasResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasResourceStream - check whether the named resource can be stored.
//
// Allowed game scenes: any.
func (s *Resources) HasResourceStream(name string) (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_HasResource",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Max - returns the amount of a resource that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) Max(name string) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Resources_Max",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxStream - returns the amount of a resource that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) MaxStream(name string) (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_Max",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Amount - returns the amount of a resource that is currently stored.
//
// Allowed game scenes: any.
func (s *Resources) Amount(name string) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Resources_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AmountStream - returns the amount of a resource that is currently stored.
//
// Allowed game scenes: any.
func (s *Resources) AmountStream(name string) (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_Amount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Density - returns the density of a resource, in <math>kg/l</math>.
//
// Allowed game scenes: any.
func (s *Resources) Density() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Resources_static_Density",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DensityStream - returns the density of a resource, in <math>kg/l</math>.
//
// Allowed game scenes: any.
func (s *Resources) DensityStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_static_Density",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// FlowMode - returns the flow mode of a resource.
//
// Allowed game scenes: any.
func (s *Resources) FlowMode() (ResourceFlowMode, error) {
	var err error
	var argBytes []byte
	var vv ResourceFlowMode
	request := &types.ProcedureCall{
		Procedure: "Resources_static_FlowMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// FlowModeStream - returns the flow mode of a resource.
//
// Allowed game scenes: any.
func (s *Resources) FlowModeStream() (*krpcgo.Stream[ResourceFlowMode], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_static_FlowMode",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) ResourceFlowMode {
		var value ResourceFlowMode
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// All - all the individual resources that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) All() ([]*Resource, error) {
	var err error
	var argBytes []byte
	var vv []*Resource
	request := &types.ProcedureCall{
		Procedure: "Resources_get_All",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// AllStream - all the individual resources that can be stored.
//
// AllStreamowed game scenes: any.
func (s *Resources) AllStream() (*krpcgo.Stream[[]*Resource], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_get_All",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Resource {
		var value []*Resource
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Names - a list of resource names that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) Names() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "Resources_get_Names",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NamesStream - a list of resource names that can be stored.
//
// Allowed game scenes: any.
func (s *Resources) NamesStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_get_Names",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Enabled - whether use of all the resources are enabled.
//
// Allowed game scenes: any.
func (s *Resources) Enabled() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Resources_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// EnabledStream - whether use of all the resources are enabled.
//
// Allowed game scenes: any.
func (s *Resources) EnabledStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_get_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetEnabled - whether use of all the resources are enabled.
//
// Allowed game scenes: any.
func (s *Resources) SetEnabled(value bool) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Resources_set_Enabled",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Recover - recover the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Recover() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_Recover",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Flight - returns a <see cref="T:SpaceCenter.Flight" /> object that can be
// used to get flight telemetry for the vessel, in the specified reference
// frame.
//
// Allowed game scenes: any.
func (s *Vessel) Flight(referenceFrame *ReferenceFrame) (*Flight, error) {
	var err error
	var argBytes []byte
	var vv Flight
	request := &types.ProcedureCall{
		Procedure: "Vessel_Flight",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// ResourcesInDecoupleStage - returns a <see cref="T:SpaceCenter.Resources" />
// object, that can used to get information about resources stored in a given
// <paramref name="stage" />.
//
// Allowed game scenes: any.
func (s *Vessel) ResourcesInDecoupleStage(stage int32, cumulative bool) (*Resources, error) {
	var err error
	var argBytes []byte
	var vv Resources
	request := &types.ProcedureCall{
		Procedure: "Vessel_ResourcesInDecoupleStage",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(stage)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(cumulative)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AvailableThrustAt - gets the total available thrust that can be produced by
// the vessel's active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.AvailableThrustAt" /> for every active engine in
// the vessel. Takes the given pressure into account.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableThrustAt(pressure float64) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_AvailableThrustAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableThrustAtStream - gets the total available thrust that can be
// produced by the vessel's active engines, in Newtons. This is computed by
// summing <see cref="M:SpaceCenter.Engine.AvailableThrustAtStream" /> for every
// active engine in the vessel. Takes the given pressure into account.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableThrustAtStream(pressure float64) (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_AvailableThrustAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxThrustAt - the total maximum thrust that can be produced by the vessel's
// active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.MaxThrustAt" /> for every active engine. Takes the
// given pressure into account.
//
// Allowed game scenes: any.
func (s *Vessel) MaxThrustAt(pressure float64) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_MaxThrustAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxThrustAtStream - the total maximum thrust that can be produced by the
// vessel's active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.MaxThrustAtStream" /> for every active engine.
// Takes the given pressure into account.
//
// Allowed game scenes: any.
func (s *Vessel) MaxThrustAtStream(pressure float64) (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_MaxThrustAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SpecificImpulseAt - the combined specific impulse of all active engines, in
// seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>. Takes the given pressure into account.
//
// Allowed game scenes: any.
func (s *Vessel) SpecificImpulseAt(pressure float64) (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_SpecificImpulseAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpecificImpulseAtStream - the combined specific impulse of all active
// engines, in seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>. Takes the given pressure into account.
//
// Allowed game scenes: any.
func (s *Vessel) SpecificImpulseAtStream(pressure float64) (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_SpecificImpulseAt",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(pressure)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Position - the position of the center of mass of the vessel, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) Position(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Vessel_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// PositionStream - the position of the center of mass of the vessel, in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) PositionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_Position",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// BoundingBox - the axis-aligned bounding box of the vessel in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) BoundingBox(referenceFrame *ReferenceFrame) (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Vessel_BoundingBox",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BoundingBoxStream - the axis-aligned bounding box of the vessel in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) BoundingBoxStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_BoundingBox",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Velocity - the velocity of the center of mass of the vessel, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) Velocity(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Vessel_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VelocityStream - the velocity of the center of mass of the vessel, in the
// given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) VelocityStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_Velocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Rotation - the rotation of the vessel, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) Rotation(referenceFrame *ReferenceFrame) (types.Tuple4[float64, float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple4[float64, float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Vessel_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RotationStream - the rotation of the vessel, in the given reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) RotationStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple4[float64, float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_Rotation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple4[float64, float64, float64, float64] {
		var value types.Tuple4[float64, float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Direction - the direction in which the vessel is pointing, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) Direction(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Vessel_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DirectionStream - the direction in which the vessel is pointing, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) DirectionStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_Direction",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AngularVelocity - the angular velocity of the vessel, in the given reference
// frame.
//
// Allowed game scenes: any.
func (s *Vessel) AngularVelocity(referenceFrame *ReferenceFrame) (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Vessel_AngularVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AngularVelocityStream - the angular velocity of the vessel, in the given
// reference frame.
//
// Allowed game scenes: any.
func (s *Vessel) AngularVelocityStream(referenceFrame *ReferenceFrame) (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_AngularVelocity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(referenceFrame)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Name - the name of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the name of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetName - the name of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_set_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Type - the type of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Type() (VesselType, error) {
	var err error
	var argBytes []byte
	var vv VesselType
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// TypeStream - the type of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) TypeStream() (*krpcgo.Stream[VesselType], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) VesselType {
		var value VesselType
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetType - the type of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) SetType(value VesselType) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_set_Type",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Situation - the situation the vessel is in.
//
// Allowed game scenes: any.
func (s *Vessel) Situation() (VesselSituation, error) {
	var err error
	var argBytes []byte
	var vv VesselSituation
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Situation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SituationStream - the situation the vessel is in.
//
// Allowed game scenes: any.
func (s *Vessel) SituationStream() (*krpcgo.Stream[VesselSituation], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Situation",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) VesselSituation {
		var value VesselSituation
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Recoverable - whether the vessel is recoverable.
//
// Allowed game scenes: any.
func (s *Vessel) Recoverable() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Recoverable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// RecoverableStream - whether the vessel is recoverable.
//
// Allowed game scenes: any.
func (s *Vessel) RecoverableStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Recoverable",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MET - the mission elapsed time in seconds.
//
// Allowed game scenes: any.
func (s *Vessel) MET() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_MET",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// METStream - the mission elapsed time in seconds.
//
// Allowed game scenes: any.
func (s *Vessel) METStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_MET",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Biome - the name of the biome the vessel is currently in.
//
// Allowed game scenes: any.
func (s *Vessel) Biome() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Biome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BiomeStream - the name of the biome the vessel is currently in.
//
// Allowed game scenes: any.
func (s *Vessel) BiomeStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Biome",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Orbit - the current orbit of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Orbit() (*Orbit, error) {
	var err error
	var argBytes []byte
	var vv Orbit
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Orbit",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Control - returns a <see cref="T:SpaceCenter.Control" /> object that can be
// used to manipulate the vessel's control inputs. For example, its
// pitch/yaw/roll controls, RCS and thrust.
//
// Allowed game scenes: any.
func (s *Vessel) Control() (*Control, error) {
	var err error
	var argBytes []byte
	var vv Control
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Control",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Comms - returns a <see cref="T:SpaceCenter.Comms" /> object that can be used
// to interact with CommNet for this vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Comms() (*Comms, error) {
	var err error
	var argBytes []byte
	var vv Comms
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Comms",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AutoPilot - an <see cref="T:SpaceCenter.AutoPilot" /> object, that can be
// used to perform simple auto-piloting of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AutoPilot() (*AutoPilot, error) {
	var err error
	var argBytes []byte
	var vv AutoPilot
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AutoPilot",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// CrewCapacity - the number of crew that can occupy the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) CrewCapacity() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_CrewCapacity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CrewCapacityStream - the number of crew that can occupy the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) CrewCapacityStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_CrewCapacity",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// CrewCount - the number of crew that are occupying the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) CrewCount() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_CrewCount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// CrewCountStream - the number of crew that are occupying the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) CrewCountStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_CrewCount",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Crew - the crew in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Crew() ([]*CrewMember, error) {
	var err error
	var argBytes []byte
	var vv []*CrewMember
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Crew",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// CrewStream - the crew in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) CrewStream() (*krpcgo.Stream[[]*CrewMember], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Crew",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*CrewMember {
		var value []*CrewMember
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Resources - a <see cref="T:SpaceCenter.Resources" /> object, that can used to
// get information about resources stored in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Resources() (*Resources, error) {
	var err error
	var argBytes []byte
	var vv Resources
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Resources",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Parts - a <see cref="T:SpaceCenter.Parts" /> object, that can used to
// interact with the parts that make up this vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Parts() (*Parts, error) {
	var err error
	var argBytes []byte
	var vv Parts
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Parts",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Mass - the total mass of the vessel, including resources, in kg.
//
// Allowed game scenes: any.
func (s *Vessel) Mass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MassStream - the total mass of the vessel, including resources, in kg.
//
// Allowed game scenes: any.
func (s *Vessel) MassStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Mass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// DryMass - the total mass of the vessel, excluding resources, in kg.
//
// Allowed game scenes: any.
func (s *Vessel) DryMass() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_DryMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// DryMassStream - the total mass of the vessel, excluding resources, in kg.
//
// Allowed game scenes: any.
func (s *Vessel) DryMassStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_DryMass",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Thrust - the total thrust currently being produced by the vessel's engines,
// in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.Thrust" /> for every engine in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) Thrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Thrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ThrustStream - the total thrust currently being produced by the vessel's
// engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.ThrustStream" /> for every engine in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) ThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_Thrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableThrust - gets the total available thrust that can be produced by the
// vessel's active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.AvailableThrust" /> for every active engine in the
// vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableThrustStream - gets the total available thrust that can be produced
// by the vessel's active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.AvailableThrustStream" /> for every active engine
// in the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxThrust - the total maximum thrust that can be produced by the vessel's
// active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.MaxThrust" /> for every active engine.
//
// Allowed game scenes: any.
func (s *Vessel) MaxThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxThrustStream - the total maximum thrust that can be produced by the
// vessel's active engines, in Newtons. This is computed by summing <see
// cref="M:SpaceCenter.Engine.MaxThrustStream" /> for every active engine.
//
// Allowed game scenes: any.
func (s *Vessel) MaxThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_MaxThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MaxVacuumThrust - the total maximum thrust that can be produced by the
// vessel's active engines when the vessel is in a vacuum, in Newtons. This is
// computed by summing <see cref="M:SpaceCenter.Engine.MaxVacuumThrust" /> for
// every active engine.
//
// Allowed game scenes: any.
func (s *Vessel) MaxVacuumThrust() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MaxVacuumThrustStream - the total maximum thrust that can be produced by the
// vessel's active engines when the vessel is in a vacuum, in Newtons. This is
// computed by summing <see cref="M:SpaceCenter.Engine.MaxVacuumThrustStream" />
// for every active engine.
//
// Allowed game scenes: any.
func (s *Vessel) MaxVacuumThrustStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_MaxVacuumThrust",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SpecificImpulse - the combined specific impulse of all active engines, in
// seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) SpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SpecificImpulseStream - the combined specific impulse of all active engines,
// in seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) SpecificImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_SpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// VacuumSpecificImpulse - the combined vacuum specific impulse of all active
// engines, in seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) VacuumSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// VacuumSpecificImpulseStream - the combined vacuum specific impulse of all
// active engines, in seconds. This is computed using the formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) VacuumSpecificImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_VacuumSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// KerbinSeaLevelSpecificImpulse - the combined specific impulse of all active
// engines at sea level on Kerbin, in seconds. This is computed using the
// formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) KerbinSeaLevelSpecificImpulse() (float32, error) {
	var err error
	var argBytes []byte
	var vv float32
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// KerbinSeaLevelSpecificImpulseStream - the combined specific impulse of all
// active engines at sea level on Kerbin, in seconds. This is computed using the
// formula <a
// href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described
// here</a>.
//
// Allowed game scenes: any.
func (s *Vessel) KerbinSeaLevelSpecificImpulseStream() (*krpcgo.Stream[float32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_KerbinSeaLevelSpecificImpulse",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float32 {
		var value float32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// MomentOfInertia - the moment of inertia of the vessel around its center of
// mass in <math>kg.m^2</math>. The inertia values in the returned 3-tuple are
// around the pitch, roll and yaw directions respectively. This corresponds to
// the vessels reference frame (<see cref="T:SpaceCenter.ReferenceFrame" />).
//
// Allowed game scenes: any.
func (s *Vessel) MomentOfInertia() (types.Tuple3[float64, float64, float64], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple3[float64, float64, float64]
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_MomentOfInertia",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MomentOfInertiaStream - the moment of inertia of the vessel around its center
// of mass in <math>kg.m^2</math>. The inertia values in the returned 3-tuple
// are around the pitch, roll and yaw directions respectively. This corresponds
// to the vessels reference frame (<see cref="T:SpaceCenter.ReferenceFrame" />).
//
// Allowed game scenes: any.
func (s *Vessel) MomentOfInertiaStream() (*krpcgo.Stream[types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_MomentOfInertia",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple3[float64, float64, float64] {
		var value types.Tuple3[float64, float64, float64]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// InertiaTensor - the inertia tensor of the vessel around its center of mass,
// in the vessels reference frame (<see cref="T:SpaceCenter.ReferenceFrame" />).
// Returns the 3x3 matrix as a list of elements, in row-major order.
//
// Allowed game scenes: any.
func (s *Vessel) InertiaTensor() ([]float64, error) {
	var err error
	var argBytes []byte
	var vv []float64
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_InertiaTensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// InertiaTensorStream - the inertia tensor of the vessel around its center of
// mass, in the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). Returns the 3x3 matrix as a list of
// elements, in row-major order.
//
// Allowed game scenes: any.
func (s *Vessel) InertiaTensorStream() (*krpcgo.Stream[[]float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_InertiaTensor",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []float64 {
		var value []float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableTorque - the maximum torque that the vessel generates. Includes
// contributions from reaction wheels, RCS, gimballed engines and aerodynamic
// control surfaces. Returns the torques in <math>N.m</math> around each of the
// coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableTorqueStream - the maximum torque that the vessel generates.
// Includes contributions from reaction wheels, RCS, gimballed engines and
// aerodynamic control surfaces. Returns the torques in <math>N.m</math> around
// each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableReactionWheelTorque - the maximum torque that the currently active
// and powered reaction wheels can generate. Returns the torques in
// <math>N.m</math> around each of the coordinate axes of the vessels reference
// frame (<see cref="T:SpaceCenter.ReferenceFrame" />). These axes are
// equivalent to the pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableReactionWheelTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableReactionWheelTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableReactionWheelTorqueStream - the maximum torque that the currently
// active and powered reaction wheels can generate. Returns the torques in
// <math>N.m</math> around each of the coordinate axes of the vessels reference
// frame (<see cref="T:SpaceCenter.ReferenceFrame" />). These axes are
// equivalent to the pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableReactionWheelTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableReactionWheelTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableRCSTorque - the maximum torque that the currently active RCS
// thrusters can generate. Returns the torques in <math>N.m</math> around each
// of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableRCSTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableRCSTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableRCSTorqueStream - the maximum torque that the currently active RCS
// thrusters can generate. Returns the torques in <math>N.m</math> around each
// of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableRCSTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableRCSTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableRCSForce - the maximum force that the currently active RCS thrusters
// can generate. Returns the forces in <math>N</math> along each of the
// coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// right, forward and bottom directions of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableRCSForce() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableRCSForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableRCSForceStream - the maximum force that the currently active RCS
// thrusters can generate. Returns the forces in <math>N</math> along each of
// the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// right, forward and bottom directions of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableRCSForceStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableRCSForce",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableEngineTorque - the maximum torque that the currently active and
// gimballed engines can generate. Returns the torques in <math>N.m</math>
// around each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableEngineTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableEngineTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableEngineTorqueStream - the maximum torque that the currently active
// and gimballed engines can generate. Returns the torques in <math>N.m</math>
// around each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableEngineTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableEngineTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableControlSurfaceTorque - the maximum torque that the aerodynamic
// control surfaces can generate. Returns the torques in <math>N.m</math> around
// each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableControlSurfaceTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableControlSurfaceTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableControlSurfaceTorqueStream - the maximum torque that the aerodynamic
// control surfaces can generate. Returns the torques in <math>N.m</math> around
// each of the coordinate axes of the vessels reference frame (<see
// cref="T:SpaceCenter.ReferenceFrame" />). These axes are equivalent to the
// pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableControlSurfaceTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableControlSurfaceTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// AvailableOtherTorque - the maximum torque that parts (excluding reaction
// wheels, gimballed engines, RCS and control surfaces) can generate. Returns
// the torques in <math>N.m</math> around each of the coordinate axes of the
// vessels reference frame (<see cref="T:SpaceCenter.ReferenceFrame" />). These
// axes are equivalent to the pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableOtherTorque() (types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]], error) {
	var err error
	var argBytes []byte
	var vv types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableOtherTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// AvailableOtherTorqueStream - the maximum torque that parts (excluding
// reaction wheels, gimballed engines, RCS and control surfaces) can generate.
// Returns the torques in <math>N.m</math> around each of the coordinate axes of
// the vessels reference frame (<see cref="T:SpaceCenter.ReferenceFrame" />).
// These axes are equivalent to the pitch, roll and yaw axes of the vessel.
//
// Allowed game scenes: any.
func (s *Vessel) AvailableOtherTorqueStream() (*krpcgo.Stream[types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_AvailableOtherTorque",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]] {
		var value types.Tuple2[types.Tuple3[float64, float64, float64], types.Tuple3[float64, float64, float64]]
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// ReferenceFrame - the reference frame that is fixed relative to the vessel,
// and orientated with the vessel. <list type="bullet"><item><description>The
// origin is at the center of mass of the
// vessel.</description></item><item><description>The axes rotate with the
// vessel.</description></item><item><description>The x-axis points out to the
// right of the vessel.</description></item><item><description>The y-axis points
// in the forward direction of the
// vessel.</description></item><item><description>The z-axis points out of the
// bottom off the vessel.</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) ReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_ReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// OrbitalReferenceFrame - the reference frame that is fixed relative to the
// vessel, and orientated with the vessels orbital prograde/normal/radial
// directions. <list type="bullet"><item><description>The origin is at the
// center of mass of the vessel.</description></item><item><description>The axes
// rotate with the orbital prograde/normal/radial
// directions.</description></item><item><description>The x-axis points in the
// orbital anti-radial direction.</description></item><item><description>The
// y-axis points in the orbital prograde
// direction.</description></item><item><description>The z-axis points in the
// orbital normal direction.</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) OrbitalReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_OrbitalReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SurfaceReferenceFrame - the reference frame that is fixed relative to the
// vessel, and orientated with the surface of the body being orbited. <list
// type="bullet"><item><description>The origin is at the center of mass of the
// vessel.</description></item><item><description>The axes rotate with the north
// and up directions on the surface of the
// body.</description></item><item><description>The x-axis points in the <a
// href="https://en.wikipedia.org/wiki/Zenith">zenith</a> direction (upwards,
// normal to the body being orbited, from the center of the body towards the
// center of mass of the vessel).</description></item><item><description>The
// y-axis points northwards towards the <a
// href="https://en.wikipedia.org/wiki/Horizon">astronomical horizon</a> (north,
// and tangential to the surface of the body -- the direction in which a compass
// would point when on the surface).</description></item><item><description>The
// z-axis points eastwards towards the <a
// href="https://en.wikipedia.org/wiki/Horizon">astronomical horizon</a> (east,
// and tangential to the surface of the body -- east on a compass when on the
// surface).</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) SurfaceReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_SurfaceReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SurfaceVelocityReferenceFrame - the reference frame that is fixed relative to
// the vessel, and orientated with the velocity vector of the vessel relative to
// the surface of the body being orbited. <list
// type="bullet"><item><description>The origin is at the center of mass of the
// vessel.</description></item><item><description>The axes rotate with the
// vessel's velocity vector.</description></item><item><description>The y-axis
// points in the direction of the vessel's velocity vector, relative to the
// surface of the body being orbited.</description></item><item><description>The
// z-axis is in the plane of the <a
// href="https://en.wikipedia.org/wiki/Horizon">astronomical
// horizon</a>.</description></item><item><description>The x-axis is orthogonal
// to the other two axes.</description></item></list>
//
// Allowed game scenes: any.
func (s *Vessel) SurfaceVelocityReferenceFrame() (*ReferenceFrame, error) {
	var err error
	var argBytes []byte
	var vv ReferenceFrame
	request := &types.ProcedureCall{
		Procedure: "Vessel_get_SurfaceVelocityReferenceFrame",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Remove - removes the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) Remove() error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_Remove",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Body - the celestial body the waypoint is attached to.
//
// Allowed game scenes: any.
func (s *Waypoint) Body() (*CelestialBody, error) {
	var err error
	var argBytes []byte
	var vv CelestialBody
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Body",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// SetBody - the celestial body the waypoint is attached to.
//
// Allowed game scenes: any.
func (s *Waypoint) SetBody(value *CelestialBody) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_set_Body",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Name - the name of the waypoint as it appears on the map and the contract.
//
// Allowed game scenes: any.
func (s *Waypoint) Name() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NameStream - the name of the waypoint as it appears on the map and the
// contract.
//
// Allowed game scenes: any.
func (s *Waypoint) NameStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetName - the name of the waypoint as it appears on the map and the contract.
//
// Allowed game scenes: any.
func (s *Waypoint) SetName(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_set_Name",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Color - the seed of the icon color. See <see
// cref="M:SpaceCenter.WaypointManager.Colors" /> for example colors.
//
// Allowed game scenes: any.
func (s *Waypoint) Color() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ColorStream - the seed of the icon color. See <see
// cref="M:SpaceCenter.WaypointManager.ColorStreams" /> for example colors.
//
// Allowed game scenes: any.
func (s *Waypoint) ColorStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetColor - the seed of the icon color. See <see
// cref="M:SpaceCenter.WaypointManager.Colors" /> for example colors.
//
// Allowed game scenes: any.
func (s *Waypoint) SetColor(value int32) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_set_Color",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Icon - the icon of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) Icon() (string, error) {
	var err error
	var argBytes []byte
	var vv string
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Icon",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IconStream - the icon of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) IconStream() (*krpcgo.Stream[string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Icon",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) string {
		var value string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetIcon - the icon of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) SetIcon(value string) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_set_Icon",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Latitude - the latitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) Latitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LatitudeStream - the latitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) LatitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLatitude - the latitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) SetLatitude(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_set_Latitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// Longitude - the longitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) Longitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// LongitudeStream - the longitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) LongitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetLongitude - the longitude of the waypoint.
//
// Allowed game scenes: any.
func (s *Waypoint) SetLongitude(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_set_Longitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// MeanAltitude - the altitude of the waypoint above sea level, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) MeanAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// MeanAltitudeStream - the altitude of the waypoint above sea level, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) MeanAltitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetMeanAltitude - the altitude of the waypoint above sea level, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) SetMeanAltitude(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_set_MeanAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// SurfaceAltitude - the altitude of the waypoint above the surface of the body
// or sea level, whichever is closer, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) SurfaceAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// SurfaceAltitudeStream - the altitude of the waypoint above the surface of the
// body or sea level, whichever is closer, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) SurfaceAltitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetSurfaceAltitude - the altitude of the waypoint above the surface of the
// body or sea level, whichever is closer, in meters.
//
// Allowed game scenes: any.
func (s *Waypoint) SetSurfaceAltitude(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_set_SurfaceAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// BedrockAltitude - the altitude of the waypoint above the surface of the body,
// in meters. When over water, this is the altitude above the sea floor.
//
// Allowed game scenes: any.
func (s *Waypoint) BedrockAltitude() (float64, error) {
	var err error
	var argBytes []byte
	var vv float64
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// BedrockAltitudeStream - the altitude of the waypoint above the surface of the
// body, in meters. When over water, this is the altitude above the sea floor.
//
// Allowed game scenes: any.
func (s *Waypoint) BedrockAltitudeStream() (*krpcgo.Stream[float64], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) float64 {
		var value float64
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// SetBedrockAltitude - the altitude of the waypoint above the surface of the
// body, in meters. When over water, this is the altitude above the sea floor.
//
// Allowed game scenes: any.
func (s *Waypoint) SetBedrockAltitude(value float64) error {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_set_BedrockAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(value)
	if err != nil {
		return tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	_, err = s.Client.Call(request)
	if err != nil {
		return tracerr.Wrap(err)
	}
	return nil
}

// NearSurface - true if the waypoint is near to the surface of a body.
//
// Allowed game scenes: any.
func (s *Waypoint) NearSurface() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_NearSurface",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// NearSurfaceStream - true if the waypoint is near to the surface of a body.
//
// Allowed game scenes: any.
func (s *Waypoint) NearSurfaceStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_NearSurface",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Grounded - true if the waypoint is attached to the ground.
//
// Allowed game scenes: any.
func (s *Waypoint) Grounded() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Grounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// GroundedStream - true if the waypoint is attached to the ground.
//
// Allowed game scenes: any.
func (s *Waypoint) GroundedStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Grounded",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Index - the integer index of this waypoint within its cluster of sibling
// waypoints. In other words, when you have a cluster of waypoints called
// "Somewhere Alpha", "Somewhere Beta" and "Somewhere Gamma", the alpha site has
// index 0, the beta site has index 1 and the gamma site has index 2. When <see
// cref="M:SpaceCenter.Waypoint.Clustered" /> is false, this is zero.
//
// Allowed game scenes: any.
func (s *Waypoint) Index() (int32, error) {
	var err error
	var argBytes []byte
	var vv int32
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Index",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IndexStream - the integer index of this waypoint within its cluster of
// sibling waypoints. In other words, when you have a cluster of waypoints
// called "Somewhere Alpha", "Somewhere Beta" and "Somewhere Gamma", the alpha
// site has index 0, the beta site has index 1 and the gamma site has index 2.
// When <see cref="M:SpaceCenter.Waypoint.Clustered" /> is false, this is zero.
//
// Allowed game scenes: any.
func (s *Waypoint) IndexStream() (*krpcgo.Stream[int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Index",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) int32 {
		var value int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Clustered - true if this waypoint is part of a set of clustered waypoints
// with greek letter names appended (Alpha, Beta, Gamma, etc). If true, there is
// a one-to-one correspondence with the greek letter name and the <see
// cref="M:SpaceCenter.Waypoint.Index" />.
//
// Allowed game scenes: any.
func (s *Waypoint) Clustered() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Clustered",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ClusteredStream - true if this waypoint is part of a set of clustered
// waypoints with greek letter names appended (Alpha, Beta, Gamma, etc). If
// true, there is a one-to-one correspondence with the greek letter name and the
// <see cref="M:SpaceCenter.Waypoint.Index" />.
//
// Allowed game scenes: any.
func (s *Waypoint) ClusteredStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Clustered",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// HasContract - whether the waypoint belongs to a contract.
//
// Allowed game scenes: any.
func (s *Waypoint) HasContract() (bool, error) {
	var err error
	var argBytes []byte
	var vv bool
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_HasContract",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// HasContractStream - whether the waypoint belongs to a contract.
//
// Allowed game scenes: any.
func (s *Waypoint) HasContractStream() (*krpcgo.Stream[bool], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_HasContract",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) bool {
		var value bool
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Contract - the associated contract.
//
// Allowed game scenes: any.
func (s *Waypoint) Contract() (*Contract, error) {
	var err error
	var argBytes []byte
	var vv Contract
	request := &types.ProcedureCall{
		Procedure: "Waypoint_get_Contract",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddWaypoint - creates a waypoint at the given position at ground level, and
// returns a <see cref="T:SpaceCenter.Waypoint" /> object that can be used to
// modify it.
//
// Allowed game scenes: any.
func (s *WaypointManager) AddWaypoint(latitude float64, longitude float64, body *CelestialBody, name string) (*Waypoint, error) {
	var err error
	var argBytes []byte
	var vv Waypoint
	request := &types.ProcedureCall{
		Procedure: "WaypointManager_AddWaypoint",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// AddWaypointAtAltitude - creates a waypoint at the given position and
// altitude, and returns a <see cref="T:SpaceCenter.Waypoint" /> object that can
// be used to modify it.
//
// Allowed game scenes: any.
func (s *WaypointManager) AddWaypointAtAltitude(latitude float64, longitude float64, altitude float64, body *CelestialBody, name string) (*Waypoint, error) {
	var err error
	var argBytes []byte
	var vv Waypoint
	request := &types.ProcedureCall{
		Procedure: "WaypointManager_AddWaypointAtAltitude",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(latitude)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x1),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(longitude)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x2),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(altitude)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x3),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(body)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x4),
		Value:    argBytes,
	})
	argBytes, err = encode.Marshal(name)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x5),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return &vv, tracerr.Wrap(err)
	}
	if vv.ID_internal() == 0 {
		return nil, nil
	}
	vv.Client = s.Client
	return &vv, nil
}

// Waypoints - a list of all existing waypoints.
//
// Allowed game scenes: any.
func (s *WaypointManager) Waypoints() ([]*Waypoint, error) {
	var err error
	var argBytes []byte
	var vv []*Waypoint
	request := &types.ProcedureCall{
		Procedure: "WaypointManager_get_Waypoints",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	for _, v := range vv {
		v.Client = s.Client
	}
	return vv, nil
}

// WaypointsStream - a list of all existing waypoints.
//
// Allowed game scenes: any.
func (s *WaypointManager) WaypointsStream() (*krpcgo.Stream[[]*Waypoint], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "WaypointManager_get_Waypoints",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []*Waypoint {
		var value []*Waypoint
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Icons - returns all available icons (from "GameData/Squad/Contracts/Icons/").
//
// Allowed game scenes: any.
func (s *WaypointManager) Icons() ([]string, error) {
	var err error
	var argBytes []byte
	var vv []string
	request := &types.ProcedureCall{
		Procedure: "WaypointManager_get_Icons",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// IconsStream - returns all available icons (from
// "GameData/Squad/Contracts/IconsStream/").
//
// Allowed game scenes: any.
func (s *WaypointManager) IconsStream() (*krpcgo.Stream[[]string], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "WaypointManager_get_Icons",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) []string {
		var value []string
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}

// Colors - an example map of known color - seed pairs. Any other integers may
// be used as seed.
//
// Allowed game scenes: any.
func (s *WaypointManager) Colors() (map[string]int32, error) {
	var err error
	var argBytes []byte
	var vv map[string]int32
	request := &types.ProcedureCall{
		Procedure: "WaypointManager_get_Colors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	result, err := s.Client.Call(request)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	err = encode.Unmarshal(result.Value, &vv)
	if err != nil {
		return vv, tracerr.Wrap(err)
	}
	return vv, nil
}

// ColorsStream - an example map of known color - seed pairs. Any other integers
// may be used as seed.
//
// Allowed game scenes: any.
func (s *WaypointManager) ColorsStream() (*krpcgo.Stream[map[string]int32], error) {
	var err error
	var argBytes []byte
	request := &types.ProcedureCall{
		Procedure: "WaypointManager_get_Colors",
		Service:   "SpaceCenter",
	}
	argBytes, err = encode.Marshal(s)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	request.Arguments = append(request.Arguments, &types.Argument{
		Position: uint32(0x0),
		Value:    argBytes,
	})
	krpc := krpc.New(s.Client)
	st, err := krpc.AddStream(request, true)
	if err != nil {
		return nil, tracerr.Wrap(err)
	}
	rawStream := s.Client.GetStream(st.Id)
	stream := krpcgo.MapStream(rawStream, func(b []byte) map[string]int32 {
		var value map[string]int32
		encode.Unmarshal(b, &value)
		return value
	})
	stream.AddCloser(func() error {
		return tracerr.Wrap(krpc.RemoveStream(st.Id))
	})
	return stream, nil
}
